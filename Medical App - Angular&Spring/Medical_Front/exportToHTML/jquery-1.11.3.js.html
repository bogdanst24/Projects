<html>
<head>
<title>jquery-1.11.3.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #606366; font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); font-weight: bold; }
.s3 { color: rgb(204,120,50); }
.s4 { color: rgb(106,135,89); }
.s5 { color: rgb(104,151,187); }
.s6 { color: rgb(98,151,85); font-style: italic; }
.s7 { color: rgb(98,151,85); font-weight: bold; font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
jquery-1.11.3.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/*! 
 * jQuery JavaScript Library v1.11.3 
 * http://jquery.com/ 
 * 
 * Includes Sizzle.js 
 * http://sizzlejs.com/ 
 * 
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors 
 * Released under the MIT license 
 * http://jquery.org/license 
 * 
 * Date: 2015-04-28T16:19Z 
 */</span><span class="s1"> 
 
(</span><span class="s2">function</span><span class="s1">( global</span><span class="s3">, </span><span class="s1">factory ) { 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">module === </span><span class="s4">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module.exports === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
        </span><span class="s0">// For CommonJS and CommonJS-like environments where a proper window is present,</span><span class="s1"> 
        </span><span class="s0">// execute the factory and get jQuery</span><span class="s1"> 
        </span><span class="s0">// For environments that do not inherently posses a window with a document</span><span class="s1"> 
        </span><span class="s0">// (such as Node.js), expose a jQuery-making factory as module.exports</span><span class="s1"> 
        </span><span class="s0">// This accentuates the need for the creation of a real window</span><span class="s1"> 
        </span><span class="s0">// e.g. var jQuery = require(&quot;jquery&quot;)(window);</span><span class="s1"> 
        </span><span class="s0">// See ticket #14549 for more info</span><span class="s1"> 
        module.exports = global.document ? 
            factory( global</span><span class="s3">, </span><span class="s2">true </span><span class="s1">) : 
            </span><span class="s2">function</span><span class="s1">( w ) { 
                </span><span class="s2">if </span><span class="s1">( !w.document ) { 
                    </span><span class="s2">throw new </span><span class="s1">Error( </span><span class="s4">&quot;jQuery requires a window with a document&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">return </span><span class="s1">factory( w )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        factory( global )</span><span class="s3">;</span><span class="s1"> 
    } 
 
</span><span class="s0">// Pass this if window is not defined yet</span><span class="s1"> 
}(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">? window : </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( window</span><span class="s3">, </span><span class="s1">noGlobal ) { 
 
</span><span class="s0">// Can't do this because several apps including ASP.NET trace</span><span class="s1"> 
</span><span class="s0">// the stack via arguments.caller.callee and Firefox dies if</span><span class="s1"> 
</span><span class="s0">// you try to trace through &quot;use strict&quot; call chains. (#13335)</span><span class="s1"> 
</span><span class="s0">// Support: Firefox 18+</span><span class="s1"> 
</span><span class="s0">//</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">deletedIds = []</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">slice = deletedIds.slice</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">concat = deletedIds.concat</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">push = deletedIds.push</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">indexOf = deletedIds.indexOf</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">class2type = {}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">toString = class2type.toString</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">hasOwn = class2type.hasOwnProperty</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">support = {}</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s2">var</span><span class="s1"> 
    version = </span><span class="s4">&quot;1.11.3&quot;</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Define a local copy of jQuery</span><span class="s1"> 
    jQuery = </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s0">// The jQuery object is actually just the init constructor 'enhanced'</span><span class="s1"> 
        </span><span class="s0">// Need init if jQuery is called (just allow error to be thrown if not included)</span><span class="s1"> 
        </span><span class="s2">return new </span><span class="s1">jQuery.fn.init( selector</span><span class="s3">, </span><span class="s1">context )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Support: Android&lt;4.1, IE&lt;9</span><span class="s1"> 
    </span><span class="s0">// Make sure we trim BOM and NBSP</span><span class="s1"> 
    rtrim = </span><span class="s4">/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Matches dashed string for camelizing</span><span class="s1"> 
    rmsPrefix = </span><span class="s4">/^-ms-/</span><span class="s3">,</span><span class="s1"> 
    rdashAlpha = </span><span class="s4">/-([\da-z])/gi</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Used by jQuery.camelCase as callback to replace()</span><span class="s1"> 
    fcamelCase = </span><span class="s2">function</span><span class="s1">( all</span><span class="s3">, </span><span class="s1">letter ) { 
        </span><span class="s2">return </span><span class="s1">letter.toUpperCase()</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn = jQuery.prototype = { 
    </span><span class="s0">// The current version of jQuery being used</span><span class="s1"> 
    jquery: version</span><span class="s3">,</span><span class="s1"> 
 
    constructor: jQuery</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Start with an empty selector</span><span class="s1"> 
    selector: </span><span class="s4">&quot;&quot;</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// The default length of a jQuery object is 0</span><span class="s1"> 
    length: </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
    toArray: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">slice.call( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Get the Nth element in the matched element set OR</span><span class="s1"> 
    </span><span class="s0">// Get the whole matched element set as a clean array</span><span class="s1"> 
    get: </span><span class="s2">function</span><span class="s1">( num ) { 
        </span><span class="s2">return </span><span class="s1">num != </span><span class="s2">null </span><span class="s1">? 
 
            </span><span class="s0">// Return just the one element from the set</span><span class="s1"> 
            ( num &lt; </span><span class="s5">0 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">[ num + </span><span class="s2">this</span><span class="s1">.length ] : </span><span class="s2">this</span><span class="s1">[ num ] ) : 
 
            </span><span class="s0">// Return all the elements in a clean array</span><span class="s1"> 
            slice.call( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Take an array of elements and push it onto the stack</span><span class="s1"> 
    </span><span class="s0">// (returning the new matched element set)</span><span class="s1"> 
    pushStack: </span><span class="s2">function</span><span class="s1">( elems ) { 
 
        </span><span class="s0">// Build a new jQuery matched element set</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">ret = jQuery.merge( </span><span class="s2">this</span><span class="s1">.constructor()</span><span class="s3">, </span><span class="s1">elems )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Add the old object onto the stack (as a reference)</span><span class="s1"> 
        ret.prevObject = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
        ret.context = </span><span class="s2">this</span><span class="s1">.context</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Return the newly-formed element set</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Execute a callback for every element in the matched set.</span><span class="s1"> 
    </span><span class="s0">// (You can seed the arguments with an array of args, but this is</span><span class="s1"> 
    </span><span class="s0">// only used internally.)</span><span class="s1"> 
    each: </span><span class="s2">function</span><span class="s1">( callback</span><span class="s3">, </span><span class="s1">args ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.each( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    map: </span><span class="s2">function</span><span class="s1">( callback ) { 
        </span><span class="s2">return this</span><span class="s1">.pushStack( jQuery.map(</span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">i ) { 
            </span><span class="s2">return </span><span class="s1">callback.call( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
        }))</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    slice: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.pushStack( slice.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments ) )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    first: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.eq( </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    last: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.eq( -</span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    eq: </span><span class="s2">function</span><span class="s1">( i ) { 
        </span><span class="s2">var </span><span class="s1">len = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            j = +i + ( i &lt; </span><span class="s5">0 </span><span class="s1">? len : </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return this</span><span class="s1">.pushStack( j &gt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; j &lt; len ? [ </span><span class="s2">this</span><span class="s1">[j] ] : [] )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    end: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.prevObject || </span><span class="s2">this</span><span class="s1">.constructor(</span><span class="s2">null</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// For internal use only.</span><span class="s1"> 
    </span><span class="s0">// Behaves like an Array's method, not like a jQuery method.</span><span class="s1"> 
    push: push</span><span class="s3">,</span><span class="s1"> 
    sort: deletedIds.sort</span><span class="s3">,</span><span class="s1"> 
    splice: deletedIds.splice 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend = jQuery.fn.extend = </span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">var </span><span class="s1">src</span><span class="s3">, </span><span class="s1">copyIsArray</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">clone</span><span class="s3">,</span><span class="s1"> 
        target = arguments[</span><span class="s5">0</span><span class="s1">] || {}</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
        length = arguments.length</span><span class="s3">,</span><span class="s1"> 
        deep = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Handle a deep copy situation</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">target === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">) { 
        deep = target</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// skip the boolean and the target</span><span class="s1"> 
        target = arguments[ i ] || {}</span><span class="s3">;</span><span class="s1"> 
        i++</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Handle case when target is a string or something (possible in deep copy)</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">target !== </span><span class="s4">&quot;object&quot; </span><span class="s1">&amp;&amp; !jQuery.isFunction(target) ) { 
        target = {}</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// extend jQuery itself if only one argument is passed</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( i === length ) { 
        target = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
        i--</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
        </span><span class="s0">// Only deal with non-null/undefined values</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( (options = arguments[ i ]) != </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s0">// Extend the base object</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
                src = target[ name ]</span><span class="s3">;</span><span class="s1"> 
                copy = options[ name ]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Prevent never-ending loop</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( target === copy ) { 
                    </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// Recurse if we're merging plain objects or arrays</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) { 
                    </span><span class="s2">if </span><span class="s1">( copyIsArray ) { 
                        copyIsArray = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                        clone = src &amp;&amp; jQuery.isArray(src) ? src : []</span><span class="s3">;</span><span class="s1"> 
 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {}</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Never move original objects, clone them</span><span class="s1"> 
                    target[ name ] = jQuery.extend( deep</span><span class="s3">, </span><span class="s1">clone</span><span class="s3">, </span><span class="s1">copy )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Don't bring in undefined values</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( copy !== undefined ) { 
                    target[ name ] = copy</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    } 
 
    </span><span class="s0">// Return the modified object</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">target</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    </span><span class="s0">// Unique for each copy of jQuery on the page</span><span class="s1"> 
    expando: </span><span class="s4">&quot;jQuery&quot; </span><span class="s1">+ ( version + Math.random() ).replace( </span><span class="s4">/\D/g</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Assume jQuery is ready without the ready module</span><span class="s1"> 
    isReady: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
 
    error: </span><span class="s2">function</span><span class="s1">( msg ) { 
        </span><span class="s2">throw new </span><span class="s1">Error( msg )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    noop: </span><span class="s2">function</span><span class="s1">() {}</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// See test/unit/core.js for details concerning isFunction.</span><span class="s1"> 
    </span><span class="s0">// Since version 1.3, DOM methods and functions like alert</span><span class="s1"> 
    </span><span class="s0">// aren't supported. They return false on IE (#2968).</span><span class="s1"> 
    isFunction: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.type(obj) === </span><span class="s4">&quot;function&quot;</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    isArray: Array.isArray || </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.type(obj) === </span><span class="s4">&quot;array&quot;</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    isWindow: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s0">/* jshint eqeqeq: false */</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">obj != </span><span class="s2">null </span><span class="s1">&amp;&amp; obj == obj.window</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    isNumeric: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s0">// parseFloat NaNs numeric-cast false positives (null|true|false|&quot;&quot;)</span><span class="s1"> 
        </span><span class="s0">// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)</span><span class="s1"> 
        </span><span class="s0">// subtraction forces infinities to NaN</span><span class="s1"> 
        </span><span class="s0">// adding 1 corrects loss of precision from parseFloat (#15100)</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!jQuery.isArray( obj ) &amp;&amp; (obj - parseFloat( obj ) + </span><span class="s5">1</span><span class="s1">) &gt;= </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    isEmptyObject: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s2">var </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">obj ) { 
            </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    isPlainObject: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s2">var </span><span class="s1">key</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Must be an Object.</span><span class="s1"> 
        </span><span class="s0">// Because of IE, we also have to check the presence of the constructor property.</span><span class="s1"> 
        </span><span class="s0">// Make sure that DOM nodes and window objects don't pass through, as well</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !obj || jQuery.type(obj) !== </span><span class="s4">&quot;object&quot; </span><span class="s1">|| obj.nodeType || jQuery.isWindow( obj ) ) { 
            </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s0">// Not own constructor property must be Object</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( obj.constructor &amp;&amp; 
                !hasOwn.call(obj</span><span class="s3">, </span><span class="s4">&quot;constructor&quot;</span><span class="s1">) &amp;&amp; 
                !hasOwn.call(obj.constructor.prototype</span><span class="s3">, </span><span class="s4">&quot;isPrototypeOf&quot;</span><span class="s1">) ) { 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
        } </span><span class="s2">catch </span><span class="s1">( e ) { 
            </span><span class="s0">// IE8,9 Will throw exceptions on certain host objects #9897</span><span class="s1"> 
            </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// Handle iteration over inherited properties before own properties.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( support.ownLast ) { 
            </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">obj ) { 
                </span><span class="s2">return </span><span class="s1">hasOwn.call( obj</span><span class="s3">, </span><span class="s1">key )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Own properties are enumerated firstly, so to speed up,</span><span class="s1"> 
        </span><span class="s0">// if last one is own, then all properties are own.</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">obj ) {} 
 
        </span><span class="s2">return </span><span class="s1">key === undefined || hasOwn.call( obj</span><span class="s3">, </span><span class="s1">key )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    type: </span><span class="s2">function</span><span class="s1">( obj ) { 
        </span><span class="s2">if </span><span class="s1">( obj == </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">obj + </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return typeof </span><span class="s1">obj === </span><span class="s4">&quot;object&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj === </span><span class="s4">&quot;function&quot; </span><span class="s1">? 
            class2type[ toString.call(obj) ] || </span><span class="s4">&quot;object&quot; </span><span class="s1">: 
            </span><span class="s2">typeof </span><span class="s1">obj</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Evaluates a script in a global context</span><span class="s1"> 
    </span><span class="s0">// Workarounds based on findings by Jim Driscoll</span><span class="s1"> 
    </span><span class="s0">// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context</span><span class="s1"> 
    globalEval: </span><span class="s2">function</span><span class="s1">( data ) { 
        </span><span class="s2">if </span><span class="s1">( data &amp;&amp; jQuery.trim( data ) ) { 
            </span><span class="s0">// We use execScript on Internet Explorer</span><span class="s1"> 
            </span><span class="s0">// We use an anonymous function so that context is window</span><span class="s1"> 
            </span><span class="s0">// rather than jQuery in Firefox</span><span class="s1"> 
            ( window.execScript || </span><span class="s2">function</span><span class="s1">( data ) { 
                window[ </span><span class="s4">&quot;eval&quot; </span><span class="s1">].call( window</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
            } )( data )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Convert dashed to camelCase; used by the css and data modules</span><span class="s1"> 
    </span><span class="s0">// Microsoft forgot to hump their vendor prefix (#9572)</span><span class="s1"> 
    camelCase: </span><span class="s2">function</span><span class="s1">( string ) { 
        </span><span class="s2">return </span><span class="s1">string.replace( rmsPrefix</span><span class="s3">, </span><span class="s4">&quot;ms-&quot; </span><span class="s1">).replace( rdashAlpha</span><span class="s3">, </span><span class="s1">fcamelCase )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    nodeName: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name ) { 
        </span><span class="s2">return </span><span class="s1">elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// args is for internal usage only</span><span class="s1"> 
    each: </span><span class="s2">function</span><span class="s1">( obj</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">args ) { 
        </span><span class="s2">var </span><span class="s1">value</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            length = obj.length</span><span class="s3">,</span><span class="s1"> 
            isArray = isArraylike( obj )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( args ) { 
            </span><span class="s2">if </span><span class="s1">( isArray ) { 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
                    value = callback.apply( obj[ i ]</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">obj ) { 
                    value = callback.apply( obj[ i ]</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
        </span><span class="s0">// A special, fast, case for the most common use of each</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">if </span><span class="s1">( isArray ) { 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
                    value = callback.call( obj[ i ]</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">obj[ i ] )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">obj ) { 
                    value = callback.call( obj[ i ]</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">obj[ i ] )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Support: Android&lt;4.1, IE&lt;9</span><span class="s1"> 
    trim: </span><span class="s2">function</span><span class="s1">( text ) { 
        </span><span class="s2">return </span><span class="s1">text == </span><span class="s2">null </span><span class="s1">? 
            </span><span class="s4">&quot;&quot; </span><span class="s1">: 
            ( text + </span><span class="s4">&quot;&quot; </span><span class="s1">).replace( rtrim</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// results is for internal usage only</span><span class="s1"> 
    makeArray: </span><span class="s2">function</span><span class="s1">( arr</span><span class="s3">, </span><span class="s1">results ) { 
        </span><span class="s2">var </span><span class="s1">ret = results || []</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( arr != </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">( isArraylike( Object(arr) ) ) { 
                jQuery.merge( ret</span><span class="s3">,</span><span class="s1"> 
                    </span><span class="s2">typeof </span><span class="s1">arr === </span><span class="s4">&quot;string&quot; </span><span class="s1">? 
                    [ arr ] : arr 
                )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                push.call( ret</span><span class="s3">, </span><span class="s1">arr )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    inArray: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">i ) { 
        </span><span class="s2">var </span><span class="s1">len</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( arr ) { 
            </span><span class="s2">if </span><span class="s1">( indexOf ) { 
                </span><span class="s2">return </span><span class="s1">indexOf.call( arr</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">i )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            len = arr.length</span><span class="s3">;</span><span class="s1"> 
            i = i ? i &lt; </span><span class="s5">0 </span><span class="s1">? Math.max( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">len + i ) : i : </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                </span><span class="s0">// Skip accessing in sparse arrays</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">arr &amp;&amp; arr[ i ] === elem ) { 
                    </span><span class="s2">return </span><span class="s1">i</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    merge: </span><span class="s2">function</span><span class="s1">( first</span><span class="s3">, </span><span class="s1">second ) { 
        </span><span class="s2">var </span><span class="s1">len = +second.length</span><span class="s3">,</span><span class="s1"> 
            j = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            i = first.length</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">while </span><span class="s1">( j &lt; len ) { 
            first[ i++ ] = second[ j++ ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( len !== len ) { 
            </span><span class="s2">while </span><span class="s1">( second[j] !== undefined ) { 
                first[ i++ ] = second[ j++ ]</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        first.length = i</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">first</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    grep: </span><span class="s2">function</span><span class="s1">( elems</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">invert ) { 
        </span><span class="s2">var </span><span class="s1">callbackInverse</span><span class="s3">,</span><span class="s1"> 
            matches = []</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            length = elems.length</span><span class="s3">,</span><span class="s1"> 
            callbackExpect = !invert</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Go through the array, only saving the items</span><span class="s1"> 
        </span><span class="s0">// that pass the validator function</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
            callbackInverse = !callback( elems[ i ]</span><span class="s3">, </span><span class="s1">i )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( callbackInverse !== callbackExpect ) { 
                matches.push( elems[ i ] )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">matches</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// arg is for internal usage only</span><span class="s1"> 
    map: </span><span class="s2">function</span><span class="s1">( elems</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">arg ) { 
        </span><span class="s2">var </span><span class="s1">value</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            length = elems.length</span><span class="s3">,</span><span class="s1"> 
            isArray = isArraylike( elems )</span><span class="s3">,</span><span class="s1"> 
            ret = []</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Go through the array, translating each of the items to their new values</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( isArray ) { 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
                value = callback( elems[ i ]</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arg )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( value != </span><span class="s2">null </span><span class="s1">) { 
                    ret.push( value )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
        </span><span class="s0">// Go through every key on the object,</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">elems ) { 
                value = callback( elems[ i ]</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">arg )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( value != </span><span class="s2">null </span><span class="s1">) { 
                    ret.push( value )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s0">// Flatten any nested arrays</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">concat.apply( []</span><span class="s3">, </span><span class="s1">ret )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// A global GUID counter for objects</span><span class="s1"> 
    guid: </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Bind a function to a context, optionally partially applying any</span><span class="s1"> 
    </span><span class="s0">// arguments.</span><span class="s1"> 
    proxy: </span><span class="s2">function</span><span class="s1">( fn</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s2">var </span><span class="s1">args</span><span class="s3">, </span><span class="s1">proxy</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            tmp = fn[ context ]</span><span class="s3">;</span><span class="s1"> 
            context = fn</span><span class="s3">;</span><span class="s1"> 
            fn = tmp</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Quick check to determine if target is callable, in the spec</span><span class="s1"> 
        </span><span class="s0">// this throws a TypeError, but we will just return undefined.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !jQuery.isFunction( fn ) ) { 
            </span><span class="s2">return </span><span class="s1">undefined</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Simulated bind</span><span class="s1"> 
        args = slice.call( arguments</span><span class="s3">, </span><span class="s5">2 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        proxy = </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">fn.apply( context || </span><span class="s2">this</span><span class="s3">, </span><span class="s1">args.concat( slice.call( arguments ) ) )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Set the guid of unique handler to the same of original handler, so it can be removed</span><span class="s1"> 
        proxy.guid = fn.guid = fn.guid || jQuery.guid++</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">proxy</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    now: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">+( </span><span class="s2">new </span><span class="s1">Date() )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// jQuery.support is not used in Core but other projects attach their</span><span class="s1"> 
    </span><span class="s0">// properties to it so it needs to exist.</span><span class="s1"> 
    support: support 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Populate the class2type map</span><span class="s1"> 
jQuery.each(</span><span class="s4">&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</span><span class="s1">.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s2">function</span><span class="s1">(i</span><span class="s3">, </span><span class="s1">name) { 
    class2type[ </span><span class="s4">&quot;[object &quot; </span><span class="s1">+ name + </span><span class="s4">&quot;]&quot; </span><span class="s1">] = name.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">isArraylike( obj ) { 
 
    </span><span class="s0">// Support: iOS 8.2 (not reproducible in simulator)</span><span class="s1"> 
    </span><span class="s0">// `in` check used to prevent JIT error (gh-2145)</span><span class="s1"> 
    </span><span class="s0">// hasOwn isn't used here due to false negatives</span><span class="s1"> 
    </span><span class="s0">// regarding Nodelist length in IE</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">length = </span><span class="s4">&quot;length&quot; </span><span class="s2">in </span><span class="s1">obj &amp;&amp; obj.length</span><span class="s3">,</span><span class="s1"> 
        type = jQuery.type( obj )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;function&quot; </span><span class="s1">|| jQuery.isWindow( obj ) ) { 
        </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( obj.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; length ) { 
        </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">type === </span><span class="s4">&quot;array&quot; </span><span class="s1">|| length === </span><span class="s5">0 </span><span class="s1">|| 
        </span><span class="s2">typeof </span><span class="s1">length === </span><span class="s4">&quot;number&quot; </span><span class="s1">&amp;&amp; length &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; ( length - </span><span class="s5">1 </span><span class="s1">) </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">;</span><span class="s1"> 
} 
</span><span class="s2">var </span><span class="s1">Sizzle = 
</span><span class="s0">/*! 
 * Sizzle CSS Selector Engine v2.2.0-pre 
 * http://sizzlejs.com/ 
 * 
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors 
 * Released under the MIT license 
 * http://jquery.org/license 
 * 
 * Date: 2014-12-16 
 */</span><span class="s1"> 
(</span><span class="s2">function</span><span class="s1">( window ) { 
 
</span><span class="s2">var </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
    support</span><span class="s3">,</span><span class="s1"> 
    Expr</span><span class="s3">,</span><span class="s1"> 
    getText</span><span class="s3">,</span><span class="s1"> 
    isXML</span><span class="s3">,</span><span class="s1"> 
    tokenize</span><span class="s3">,</span><span class="s1"> 
    compile</span><span class="s3">,</span><span class="s1"> 
    select</span><span class="s3">,</span><span class="s1"> 
    outermostContext</span><span class="s3">,</span><span class="s1"> 
    sortInput</span><span class="s3">,</span><span class="s1"> 
    hasDuplicate</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Local document vars</span><span class="s1"> 
    setDocument</span><span class="s3">,</span><span class="s1"> 
    document</span><span class="s3">,</span><span class="s1"> 
    docElem</span><span class="s3">,</span><span class="s1"> 
    documentIsHTML</span><span class="s3">,</span><span class="s1"> 
    rbuggyQSA</span><span class="s3">,</span><span class="s1"> 
    rbuggyMatches</span><span class="s3">,</span><span class="s1"> 
    matches</span><span class="s3">,</span><span class="s1"> 
    contains</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Instance-specific data</span><span class="s1"> 
    expando = </span><span class="s4">&quot;sizzle&quot; </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">* </span><span class="s2">new </span><span class="s1">Date()</span><span class="s3">,</span><span class="s1"> 
    preferredDoc = window.document</span><span class="s3">,</span><span class="s1"> 
    dirruns = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
    done = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
    classCache = createCache()</span><span class="s3">,</span><span class="s1"> 
    tokenCache = createCache()</span><span class="s3">,</span><span class="s1"> 
    compilerCache = createCache()</span><span class="s3">,</span><span class="s1"> 
    sortOrder = </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">b ) { 
        </span><span class="s2">if </span><span class="s1">( a === b ) { 
            hasDuplicate = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// General-purpose constants</span><span class="s1"> 
    MAX_NEGATIVE = </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">31</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Instance methods</span><span class="s1"> 
    hasOwn = ({}).hasOwnProperty</span><span class="s3">,</span><span class="s1"> 
    arr = []</span><span class="s3">,</span><span class="s1"> 
    pop = arr.pop</span><span class="s3">,</span><span class="s1"> 
    push_native = arr.push</span><span class="s3">,</span><span class="s1"> 
    push = arr.push</span><span class="s3">,</span><span class="s1"> 
    slice = arr.slice</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// Use a stripped-down indexOf as it's faster than native</span><span class="s1"> 
    </span><span class="s0">// http://jsperf.com/thor-indexof-vs-for/5</span><span class="s1"> 
    indexOf = </span><span class="s2">function</span><span class="s1">( list</span><span class="s3">, </span><span class="s1">elem ) { 
        </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            len = list.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s2">if </span><span class="s1">( list[i] === elem ) { 
                </span><span class="s2">return </span><span class="s1">i</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    booleans = </span><span class="s4">&quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Regular expressions</span><span class="s1"> 
 
    </span><span class="s0">// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace</span><span class="s1"> 
    whitespace = </span><span class="s4">&quot;[</span><span class="s3">\\</span><span class="s4">x20</span><span class="s3">\\</span><span class="s4">t</span><span class="s3">\\</span><span class="s4">r</span><span class="s3">\\</span><span class="s4">n</span><span class="s3">\\</span><span class="s4">f]&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// http://www.w3.org/TR/css3-syntax/#characters</span><span class="s1"> 
    characterEncoding = </span><span class="s4">&quot;(?:</span><span class="s3">\\\\</span><span class="s4">.|[</span><span class="s3">\\</span><span class="s4">w-]|[^</span><span class="s3">\\</span><span class="s4">x00-</span><span class="s3">\\</span><span class="s4">xa0])+&quot;</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Loosely modeled on CSS identifier characters</span><span class="s1"> 
    </span><span class="s0">// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors</span><span class="s1"> 
    </span><span class="s0">// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</span><span class="s1"> 
    identifier = characterEncoding.replace( </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s4">&quot;w#&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors</span><span class="s1"> 
    attributes = </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">[&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*(&quot; </span><span class="s1">+ characterEncoding + </span><span class="s4">&quot;)(?:&quot; </span><span class="s1">+ whitespace + 
        </span><span class="s0">// Operator (capture 2)</span><span class="s1"> 
        </span><span class="s4">&quot;*([*^$|!~]?=)&quot; </span><span class="s1">+ whitespace + 
        </span><span class="s0">// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;</span><span class="s1"> 
        </span><span class="s4">&quot;*(?:'((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\</span><span class="s4">'])*)'|</span><span class="s3">\&quot;</span><span class="s4">((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\\&quot;</span><span class="s4">])*)</span><span class="s3">\&quot;</span><span class="s4">|(&quot; </span><span class="s1">+ identifier + </span><span class="s4">&quot;))|)&quot; </span><span class="s1">+ whitespace + 
        </span><span class="s4">&quot;*</span><span class="s3">\\</span><span class="s4">]&quot;</span><span class="s3">,</span><span class="s1"> 
 
    pseudos = </span><span class="s4">&quot;:(&quot; </span><span class="s1">+ characterEncoding + </span><span class="s4">&quot;)(?:</span><span class="s3">\\</span><span class="s4">((&quot; </span><span class="s1">+ 
        </span><span class="s0">// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:</span><span class="s1"> 
        </span><span class="s0">// 1. quoted (capture 3; capture 4 or capture 5)</span><span class="s1"> 
        </span><span class="s4">&quot;('((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\</span><span class="s4">'])*)'|</span><span class="s3">\&quot;</span><span class="s4">((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\\&quot;</span><span class="s4">])*)</span><span class="s3">\&quot;</span><span class="s4">)|&quot; </span><span class="s1">+ 
        </span><span class="s0">// 2. simple (capture 6)</span><span class="s1"> 
        </span><span class="s4">&quot;((?:</span><span class="s3">\\\\</span><span class="s4">.|[^</span><span class="s3">\\\\</span><span class="s4">()[</span><span class="s3">\\</span><span class="s4">]]|&quot; </span><span class="s1">+ attributes + </span><span class="s4">&quot;)*)|&quot; </span><span class="s1">+ 
        </span><span class="s0">// 3. anything else (capture 2)</span><span class="s1"> 
        </span><span class="s4">&quot;.*&quot; </span><span class="s1">+ 
        </span><span class="s4">&quot;)</span><span class="s3">\\</span><span class="s4">)|)&quot;</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</span><span class="s1"> 
    rwhitespace = </span><span class="s2">new </span><span class="s1">RegExp( whitespace + </span><span class="s4">&quot;+&quot;</span><span class="s3">, </span><span class="s4">&quot;g&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    rtrim = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;+|((?:^|[^</span><span class="s3">\\\\</span><span class="s4">])(?:</span><span class="s3">\\\\</span><span class="s4">.)*)&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;+$&quot;</span><span class="s3">, </span><span class="s4">&quot;g&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    rcomma = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*,&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    rcombinators = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*([&gt;+~]|&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;)&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    rattributeQuotes = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;=&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*([^</span><span class="s3">\\</span><span class="s4">]'</span><span class="s3">\&quot;</span><span class="s4">]*?)&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*</span><span class="s3">\\</span><span class="s4">]&quot;</span><span class="s3">, </span><span class="s4">&quot;g&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    rpseudo = </span><span class="s2">new </span><span class="s1">RegExp( pseudos )</span><span class="s3">,</span><span class="s1"> 
    ridentifier = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ identifier + </span><span class="s4">&quot;$&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    matchExpr = { 
        </span><span class="s4">&quot;ID&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^#(&quot; </span><span class="s1">+ characterEncoding + </span><span class="s4">&quot;)&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;CLASS&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^</span><span class="s3">\\</span><span class="s4">.(&quot; </span><span class="s1">+ characterEncoding + </span><span class="s4">&quot;)&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;TAG&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^(&quot; </span><span class="s1">+ characterEncoding.replace( </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s4">&quot;w*&quot; </span><span class="s1">) + </span><span class="s4">&quot;)&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ attributes )</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ pseudos )</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:</span><span class="s3">\\</span><span class="s4">(&quot; </span><span class="s1">+ whitespace + 
            </span><span class="s4">&quot;*(even|odd|(([+-]|)(</span><span class="s3">\\</span><span class="s4">d*)n|)&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*(?:([+-]|)&quot; </span><span class="s1">+ whitespace + 
            </span><span class="s4">&quot;*(</span><span class="s3">\\</span><span class="s4">d+)|))&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*</span><span class="s3">\\</span><span class="s4">)|)&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;bool&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^(?:&quot; </span><span class="s1">+ booleans + </span><span class="s4">&quot;)$&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// For use in libraries implementing .is()</span><span class="s1"> 
        </span><span class="s0">// We use this for POS matching in `select`</span><span class="s1"> 
        </span><span class="s4">&quot;needsContext&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:</span><span class="s3">\\</span><span class="s4">(&quot; </span><span class="s1">+ 
            whitespace + </span><span class="s4">&quot;*((?:-</span><span class="s3">\\</span><span class="s4">d)?</span><span class="s3">\\</span><span class="s4">d*)&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*</span><span class="s3">\\</span><span class="s4">)|)(?=[^-]|$)&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">) 
    }</span><span class="s3">,</span><span class="s1"> 
 
    rinputs = </span><span class="s4">/^(?:input|select|textarea|button)$/i</span><span class="s3">,</span><span class="s1"> 
    rheader = </span><span class="s4">/^h\d$/i</span><span class="s3">,</span><span class="s1"> 
 
    rnative = </span><span class="s4">/^[^{]+\{\s*\[native \w/</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Easily-parseable/retrievable ID or TAG or CLASS selectors</span><span class="s1"> 
    rquickExpr = </span><span class="s4">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span><span class="s3">,</span><span class="s1"> 
 
    rsibling = </span><span class="s4">/[+~]/</span><span class="s3">,</span><span class="s1"> 
    rescape = </span><span class="s4">/'|\\/g</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</span><span class="s1"> 
    runescape = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;</span><span class="s3">\\\\</span><span class="s4">([</span><span class="s3">\\</span><span class="s4">da-f]{1,6}&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;?|(&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;)|.)&quot;</span><span class="s3">, </span><span class="s4">&quot;ig&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    funescape = </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">escaped</span><span class="s3">, </span><span class="s1">escapedWhitespace ) { 
        </span><span class="s2">var </span><span class="s1">high = </span><span class="s4">&quot;0x&quot; </span><span class="s1">+ escaped - </span><span class="s5">0x10000</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s0">// NaN means non-codepoint</span><span class="s1"> 
        </span><span class="s0">// Support: Firefox&lt;24</span><span class="s1"> 
        </span><span class="s0">// Workaround erroneous numeric interpretation of +&quot;0x&quot;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">high !== high || escapedWhitespace ? 
            escaped : 
            high &lt; </span><span class="s5">0 </span><span class="s1">? 
                </span><span class="s0">// BMP codepoint</span><span class="s1"> 
                String.fromCharCode( high + </span><span class="s5">0x10000 </span><span class="s1">) : 
                </span><span class="s0">// Supplemental Plane codepoint (surrogate pair)</span><span class="s1"> 
                String.fromCharCode( high &gt;&gt; </span><span class="s5">10 </span><span class="s1">| </span><span class="s5">0xD800</span><span class="s3">, </span><span class="s1">high &amp; </span><span class="s5">0x3FF </span><span class="s1">| </span><span class="s5">0xDC00 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Used for iframes</span><span class="s1"> 
    </span><span class="s0">// See setDocument()</span><span class="s1"> 
    </span><span class="s0">// Removing the function wrapper causes a &quot;Permission Denied&quot;</span><span class="s1"> 
    </span><span class="s0">// error in IE</span><span class="s1"> 
    unloadHandler = </span><span class="s2">function</span><span class="s1">() { 
        setDocument()</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Optimize for push.apply( _, NodeList )</span><span class="s1"> 
</span><span class="s2">try </span><span class="s1">{ 
    push.apply( 
        (arr = slice.call( preferredDoc.childNodes ))</span><span class="s3">,</span><span class="s1"> 
        preferredDoc.childNodes 
    )</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s0">// Support: Android&lt;4.0</span><span class="s1"> 
    </span><span class="s0">// Detect silently failing push.apply</span><span class="s1"> 
    arr[ preferredDoc.childNodes.length ].nodeType</span><span class="s3">;</span><span class="s1"> 
} </span><span class="s2">catch </span><span class="s1">( e ) { 
    push = { apply: arr.length ? 
 
        </span><span class="s0">// Leverage slice if possible</span><span class="s1"> 
        </span><span class="s2">function</span><span class="s1">( target</span><span class="s3">, </span><span class="s1">els ) { 
            push_native.apply( target</span><span class="s3">, </span><span class="s1">slice.call(els) )</span><span class="s3">;</span><span class="s1"> 
        } : 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// Otherwise append directly</span><span class="s1"> 
        </span><span class="s2">function</span><span class="s1">( target</span><span class="s3">, </span><span class="s1">els ) { 
            </span><span class="s2">var </span><span class="s1">j = target.length</span><span class="s3">,</span><span class="s1"> 
                i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Can't trust NodeList.length</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( (target[j++] = els[i++]) ) {} 
            target.length = j - </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">Sizzle( selector</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">seed ) { 
    </span><span class="s2">var </span><span class="s1">match</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">nodeType</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// QSA vars</span><span class="s1"> 
        i</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">nid</span><span class="s3">, </span><span class="s1">newContext</span><span class="s3">, </span><span class="s1">newSelector</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) { 
        setDocument( context )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    context = context || document</span><span class="s3">;</span><span class="s1"> 
    results = results || []</span><span class="s3">;</span><span class="s1"> 
    nodeType = context.nodeType</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s4">&quot;string&quot; </span><span class="s1">|| !selector || 
        nodeType !== </span><span class="s5">1 </span><span class="s1">&amp;&amp; nodeType !== </span><span class="s5">9 </span><span class="s1">&amp;&amp; nodeType !== </span><span class="s5">11 </span><span class="s1">) { 
 
        </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( !seed &amp;&amp; documentIsHTML ) { 
 
        </span><span class="s0">// Try to shortcut find operations when possible (e.g., not under DocumentFragment)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( nodeType !== </span><span class="s5">11 </span><span class="s1">&amp;&amp; (match = rquickExpr.exec( selector )) ) { 
            </span><span class="s0">// Speed-up: Sizzle(&quot;#ID&quot;)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( (m = match[</span><span class="s5">1</span><span class="s1">]) ) { 
                </span><span class="s2">if </span><span class="s1">( nodeType === </span><span class="s5">9 </span><span class="s1">) { 
                    elem = context.getElementById( m )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s0">// Check parentNode to catch when Blackberry 4.6 returns</span><span class="s1"> 
                    </span><span class="s0">// nodes that are no longer in the document (jQuery #6963)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( elem &amp;&amp; elem.parentNode ) { 
                        </span><span class="s0">// Handle the case where IE, Opera, and Webkit return items</span><span class="s1"> 
                        </span><span class="s0">// by name instead of ID</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.id === m ) { 
                            results.push( elem )</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s0">// Context is not a document</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp; 
                        contains( context</span><span class="s3">, </span><span class="s1">elem ) &amp;&amp; elem.id === m ) { 
                        results.push( elem )</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
            </span><span class="s0">// Speed-up: Sizzle(&quot;TAG&quot;)</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( match[</span><span class="s5">2</span><span class="s1">] ) { 
                push.apply( results</span><span class="s3">, </span><span class="s1">context.getElementsByTagName( selector ) )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Speed-up: Sizzle(&quot;.CLASS&quot;)</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( (m = match[</span><span class="s5">3</span><span class="s1">]) &amp;&amp; support.getElementsByClassName ) { 
                push.apply( results</span><span class="s3">, </span><span class="s1">context.getElementsByClassName( m ) )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// QSA path</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) { 
            nid = old = expando</span><span class="s3">;</span><span class="s1"> 
            newContext = context</span><span class="s3">;</span><span class="s1"> 
            newSelector = nodeType !== </span><span class="s5">1 </span><span class="s1">&amp;&amp; selector</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// qSA works strangely on Element-rooted queries</span><span class="s1"> 
            </span><span class="s0">// We can work around this by specifying an extra ID on the root</span><span class="s1"> 
            </span><span class="s0">// and working up from there (Thanks to Andrew Dupont for the technique)</span><span class="s1"> 
            </span><span class="s0">// IE 8 doesn't work on object elements</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; context.nodeName.toLowerCase() !== </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
                groups = tokenize( selector )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( (old = context.getAttribute(</span><span class="s4">&quot;id&quot;</span><span class="s1">)) ) { 
                    nid = old.replace( rescape</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">$&amp;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    context.setAttribute( </span><span class="s4">&quot;id&quot;</span><span class="s3">, </span><span class="s1">nid )</span><span class="s3">;</span><span class="s1"> 
                } 
                nid = </span><span class="s4">&quot;[id='&quot; </span><span class="s1">+ nid + </span><span class="s4">&quot;'] &quot;</span><span class="s3">;</span><span class="s1"> 
 
                i = groups.length</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                    groups[i] = nid + toSelector( groups[i] )</span><span class="s3">;</span><span class="s1"> 
                } 
                newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context</span><span class="s3">;</span><span class="s1"> 
                newSelector = groups.join(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( newSelector ) { 
                </span><span class="s2">try </span><span class="s1">{ 
                    push.apply( results</span><span class="s3">,</span><span class="s1"> 
                        newContext.querySelectorAll( newSelector ) 
                    )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">catch</span><span class="s1">(qsaError) { 
                } </span><span class="s2">finally </span><span class="s1">{ 
                    </span><span class="s2">if </span><span class="s1">( !old ) { 
                        context.removeAttribute(</span><span class="s4">&quot;id&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
    } 
 
    </span><span class="s0">// All others</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">select( selector.replace( rtrim</span><span class="s3">, </span><span class="s4">&quot;$1&quot; </span><span class="s1">)</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">seed )</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Create key-value caches of limited size 
 * </span><span class="s7">@returns </span><span class="s6">{Function(string, Object)} Returns the Object data after storing it on itself with 
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) 
 *  deleting the oldest entry 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createCache() { 
    </span><span class="s2">var </span><span class="s1">keys = []</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">function </span><span class="s1">cache( key</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s0">// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( keys.push( key + </span><span class="s4">&quot; &quot; </span><span class="s1">) &gt; Expr.cacheLength ) { 
            </span><span class="s0">// Only keep the most recent entries</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">cache[ keys.shift() ]</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return </span><span class="s1">(cache[ key + </span><span class="s4">&quot; &quot; </span><span class="s1">] = value)</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">cache</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Mark a function for special use by Sizzle 
 * </span><span class="s7">@param </span><span class="s6">{Function} fn The function to mark 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">markFunction( fn ) { 
    fn[ expando ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">fn</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Support testing using an element 
 * </span><span class="s7">@param </span><span class="s6">{Function} fn Passed the created div and expects a boolean result 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">assert( fn ) { 
    </span><span class="s2">var </span><span class="s1">div = document.createElement(</span><span class="s4">&quot;div&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">try </span><span class="s1">{ 
        </span><span class="s2">return </span><span class="s1">!!fn( div )</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">catch </span><span class="s1">(e) { 
        </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">finally </span><span class="s1">{ 
        </span><span class="s0">// Remove from its parent by default</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( div.parentNode ) { 
            div.parentNode.removeChild( div )</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s0">// release memory in IE</span><span class="s1"> 
        div = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s6">/** 
 * Adds the same handler for all of the specified attrs 
 * </span><span class="s7">@param </span><span class="s6">{String} attrs Pipe-separated list of attributes 
 * </span><span class="s7">@param </span><span class="s6">{Function} handler The method that will be applied 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">addHandle( attrs</span><span class="s3">, </span><span class="s1">handler ) { 
    </span><span class="s2">var </span><span class="s1">arr = attrs.split(</span><span class="s4">&quot;|&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        i = attrs.length</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">while </span><span class="s1">( i-- ) { 
        Expr.attrHandle[ arr[i] ] = handler</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s6">/** 
 * Checks document order of two siblings 
 * </span><span class="s7">@param </span><span class="s6">{Element} a 
 * </span><span class="s7">@param </span><span class="s6">{Element} b 
 * </span><span class="s7">@returns </span><span class="s6">{Number} Returns less than 0 if a precedes b, greater than 0 if a follows b 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">siblingCheck( a</span><span class="s3">, </span><span class="s1">b ) { 
    </span><span class="s2">var </span><span class="s1">cur = b &amp;&amp; a</span><span class="s3">,</span><span class="s1"> 
        diff = cur &amp;&amp; a.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; b.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; 
            ( ~b.sourceIndex || MAX_NEGATIVE ) - 
            ( ~a.sourceIndex || MAX_NEGATIVE )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Use IE sourceIndex if available on both nodes</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( diff ) { 
        </span><span class="s2">return </span><span class="s1">diff</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Check if b follows a</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( cur ) { 
        </span><span class="s2">while </span><span class="s1">( (cur = cur.nextSibling) ) { 
            </span><span class="s2">if </span><span class="s1">( cur === b ) { 
                </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">a ? </span><span class="s5">1 </span><span class="s1">: -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Returns a function to use in pseudos for input types 
 * </span><span class="s7">@param </span><span class="s6">{String} type 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createInputPseudo( type ) { 
    </span><span class="s2">return function</span><span class="s1">( elem ) { 
        </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">name === </span><span class="s4">&quot;input&quot; </span><span class="s1">&amp;&amp; elem.type === type</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Returns a function to use in pseudos for buttons 
 * </span><span class="s7">@param </span><span class="s6">{String} type 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createButtonPseudo( type ) { 
    </span><span class="s2">return function</span><span class="s1">( elem ) { 
        </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">(name === </span><span class="s4">&quot;input&quot; </span><span class="s1">|| name === </span><span class="s4">&quot;button&quot;</span><span class="s1">) &amp;&amp; elem.type === type</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Returns a function to use in pseudos for positionals 
 * </span><span class="s7">@param </span><span class="s6">{Function} fn 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createPositionalPseudo( fn ) { 
    </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( argument ) { 
        argument = +argument</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( seed</span><span class="s3">, </span><span class="s1">matches ) { 
            </span><span class="s2">var </span><span class="s1">j</span><span class="s3">,</span><span class="s1"> 
                matchIndexes = fn( []</span><span class="s3">, </span><span class="s1">seed.length</span><span class="s3">, </span><span class="s1">argument )</span><span class="s3">,</span><span class="s1"> 
                i = matchIndexes.length</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Match elements found at the specified indexes</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                </span><span class="s2">if </span><span class="s1">( seed[ (j = matchIndexes[i]) ] ) { 
                    seed[j] = !(matches[j] = seed[j])</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Checks a node for validity as a Sizzle context 
 * </span><span class="s7">@param </span><span class="s6">{Element|Object=} context 
 * </span><span class="s7">@returns </span><span class="s6">{Element|Object|Boolean} The input node if acceptable, otherwise a falsy value 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">testContext( context ) { 
    </span><span class="s2">return </span><span class="s1">context &amp;&amp; </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">&amp;&amp; context</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Expose support vars for convenience</span><span class="s1"> 
support = Sizzle.support = {}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Detects XML nodes 
 * </span><span class="s7">@param </span><span class="s6">{Element|Object} elem An element or a document 
 * </span><span class="s7">@returns </span><span class="s6">{Boolean} True iff elem is a non-HTML XML node 
 */</span><span class="s1"> 
isXML = Sizzle.isXML = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s0">// documentElement is verified for cases where it doesn't yet exist</span><span class="s1"> 
    </span><span class="s0">// (such as loading iframes in IE - #4833)</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">documentElement ? documentElement.nodeName !== </span><span class="s4">&quot;HTML&quot; </span><span class="s1">: </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Sets document-related variables once based on the current document 
 * </span><span class="s7">@param </span><span class="s6">{Element|Object} [doc] An element or document object to use to set the document 
 * </span><span class="s7">@returns </span><span class="s6">{Object} Returns the current document 
 */</span><span class="s1"> 
setDocument = Sizzle.setDocument = </span><span class="s2">function</span><span class="s1">( node ) { 
    </span><span class="s2">var </span><span class="s1">hasCompare</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">,</span><span class="s1"> 
        doc = node ? node.ownerDocument || node : preferredDoc</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// If no document and documentElement is available, return</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( doc === document || doc.nodeType !== </span><span class="s5">9 </span><span class="s1">|| !doc.documentElement ) { 
        </span><span class="s2">return </span><span class="s1">document</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Set our document</span><span class="s1"> 
    document = doc</span><span class="s3">;</span><span class="s1"> 
    docElem = doc.documentElement</span><span class="s3">;</span><span class="s1"> 
    parent = doc.defaultView</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&gt;8</span><span class="s1"> 
    </span><span class="s0">// If iframe document is assigned to &quot;document&quot; variable and if iframe has been reloaded,</span><span class="s1"> 
    </span><span class="s0">// IE will throw &quot;permission denied&quot; error when accessing &quot;document&quot; variable, see jQuery #13936</span><span class="s1"> 
    </span><span class="s0">// IE6-8 do not support the defaultView property so parent will be undefined</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( parent &amp;&amp; parent !== parent.top ) { 
        </span><span class="s0">// IE11 does not have attachEvent, so all must suffer</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( parent.addEventListener ) { 
            parent.addEventListener( </span><span class="s4">&quot;unload&quot;</span><span class="s3">, </span><span class="s1">unloadHandler</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( parent.attachEvent ) { 
            parent.attachEvent( </span><span class="s4">&quot;onunload&quot;</span><span class="s3">, </span><span class="s1">unloadHandler )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">/* Support tests 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
    documentIsHTML = !isXML( doc )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">/* Attributes 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
    </span><span class="s0">// Verify that getAttribute really returns attributes and not properties</span><span class="s1"> 
    </span><span class="s0">// (excepting IE8 booleans)</span><span class="s1"> 
    support.attributes = assert(</span><span class="s2">function</span><span class="s1">( div ) { 
        div.className = </span><span class="s4">&quot;i&quot;</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!div.getAttribute(</span><span class="s4">&quot;className&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">/* getElement(s)By* 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
 
    </span><span class="s0">// Check if getElementsByTagName(&quot;*&quot;) returns only elements</span><span class="s1"> 
    support.getElementsByTagName = assert(</span><span class="s2">function</span><span class="s1">( div ) { 
        div.appendChild( doc.createComment(</span><span class="s4">&quot;&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!div.getElementsByTagName(</span><span class="s4">&quot;*&quot;</span><span class="s1">).length</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
    support.getElementsByClassName = rnative.test( doc.getElementsByClassName )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;10</span><span class="s1"> 
    </span><span class="s0">// Check if getElementById returns elements by name</span><span class="s1"> 
    </span><span class="s0">// The broken getElementById methods don't pick up programatically-set names,</span><span class="s1"> 
    </span><span class="s0">// so use a roundabout getElementsByName test</span><span class="s1"> 
    support.getById = assert(</span><span class="s2">function</span><span class="s1">( div ) { 
        docElem.appendChild( div ).id = expando</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!doc.getElementsByName || !doc.getElementsByName( expando ).length</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// ID find and filter</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( support.getById ) { 
        Expr.find[</span><span class="s4">&quot;ID&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">( id</span><span class="s3">, </span><span class="s1">context ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementById !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">&amp;&amp; documentIsHTML ) { 
                </span><span class="s2">var </span><span class="s1">m = context.getElementById( id )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// Check parentNode to catch when Blackberry 4.6 returns</span><span class="s1"> 
                </span><span class="s0">// nodes that are no longer in the document #6963</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">m &amp;&amp; m.parentNode ? [ m ] : []</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
        Expr.filter[</span><span class="s4">&quot;ID&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">( id ) { 
            </span><span class="s2">var </span><span class="s1">attrId = id.replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">elem.getAttribute(</span><span class="s4">&quot;id&quot;</span><span class="s1">) === attrId</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        </span><span class="s0">// Support: IE6/7</span><span class="s1"> 
        </span><span class="s0">// getElementById is not reliable as a find shortcut</span><span class="s1"> 
        </span><span class="s2">delete </span><span class="s1">Expr.find[</span><span class="s4">&quot;ID&quot;</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
        Expr.filter[</span><span class="s4">&quot;ID&quot;</span><span class="s1">] =  </span><span class="s2">function</span><span class="s1">( id ) { 
            </span><span class="s2">var </span><span class="s1">attrId = id.replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">node = </span><span class="s2">typeof </span><span class="s1">elem.getAttributeNode !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">&amp;&amp; elem.getAttributeNode(</span><span class="s4">&quot;id&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">node &amp;&amp; node.value === attrId</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Tag</span><span class="s1"> 
    Expr.find[</span><span class="s4">&quot;TAG&quot;</span><span class="s1">] = support.getElementsByTagName ? 
        </span><span class="s2">function</span><span class="s1">( tag</span><span class="s3">, </span><span class="s1">context ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">context.getElementsByTagName( tag )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// DocumentFragment nodes don't have gEBTN</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( support.qsa ) { 
                </span><span class="s2">return </span><span class="s1">context.querySelectorAll( tag )</span><span class="s3">;</span><span class="s1"> 
            } 
        } : 
 
        </span><span class="s2">function</span><span class="s1">( tag</span><span class="s3">, </span><span class="s1">context ) { 
            </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
                tmp = []</span><span class="s3">,</span><span class="s1"> 
                i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too</span><span class="s1"> 
                results = context.getElementsByTagName( tag )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Filter out possible comments</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( tag === </span><span class="s4">&quot;*&quot; </span><span class="s1">) { 
                </span><span class="s2">while </span><span class="s1">( (elem = results[i++]) ) { 
                    </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                        tmp.push( elem )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">tmp</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Class</span><span class="s1"> 
    Expr.find[</span><span class="s4">&quot;CLASS&quot;</span><span class="s1">] = support.getElementsByClassName &amp;&amp; </span><span class="s2">function</span><span class="s1">( className</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s2">if </span><span class="s1">( documentIsHTML ) { 
            </span><span class="s2">return </span><span class="s1">context.getElementsByClassName( className )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">/* QSA/matchesSelector 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
 
    </span><span class="s0">// QSA and matchesSelector support</span><span class="s1"> 
 
    </span><span class="s0">// matchesSelector(:active) reports false when true (IE9/Opera 11.5)</span><span class="s1"> 
    rbuggyMatches = []</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// qSa(:focus) reports false when true (Chrome 21)</span><span class="s1"> 
    </span><span class="s0">// We allow this because of a bug in IE8/9 that throws an error</span><span class="s1"> 
    </span><span class="s0">// whenever `document.activeElement` is accessed on an iframe</span><span class="s1"> 
    </span><span class="s0">// So, we allow :focus to pass through QSA all the time to avoid the IE error</span><span class="s1"> 
    </span><span class="s0">// See http://bugs.jquery.com/ticket/13378</span><span class="s1"> 
    rbuggyQSA = []</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( (support.qsa = rnative.test( doc.querySelectorAll )) ) { 
        </span><span class="s0">// Build QSA regex</span><span class="s1"> 
        </span><span class="s0">// Regex strategy adopted from Diego Perini</span><span class="s1"> 
        assert(</span><span class="s2">function</span><span class="s1">( div ) { 
            </span><span class="s0">// Select is set to empty string on purpose</span><span class="s1"> 
            </span><span class="s0">// This is to test IE's treatment of not explicitly</span><span class="s1"> 
            </span><span class="s0">// setting a boolean content attribute,</span><span class="s1"> 
            </span><span class="s0">// since its presence should be enough</span><span class="s1"> 
            </span><span class="s0">// http://bugs.jquery.com/ticket/12359</span><span class="s1"> 
            docElem.appendChild( div ).innerHTML = </span><span class="s4">&quot;&lt;a id='&quot; </span><span class="s1">+ expando + </span><span class="s4">&quot;'&gt;&lt;/a&gt;&quot; </span><span class="s1">+ 
                </span><span class="s4">&quot;&lt;select id='&quot; </span><span class="s1">+ expando + </span><span class="s4">&quot;-</span><span class="s3">\f</span><span class="s4">]' msallowcapture=''&gt;&quot; </span><span class="s1">+ 
                </span><span class="s4">&quot;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Support: IE8, Opera 11-12.16</span><span class="s1"> 
            </span><span class="s0">// Nothing should be selected when empty strings follow ^= or $= or *=</span><span class="s1"> 
            </span><span class="s0">// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT</span><span class="s1"> 
            </span><span class="s0">// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( div.querySelectorAll(</span><span class="s4">&quot;[msallowcapture^='']&quot;</span><span class="s1">).length ) { 
                rbuggyQSA.push( </span><span class="s4">&quot;[*^$]=&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*(?:''|</span><span class="s3">\&quot;\&quot;</span><span class="s4">)&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Support: IE8</span><span class="s1"> 
            </span><span class="s0">// Boolean attributes and &quot;value&quot; are not treated correctly</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div.querySelectorAll(</span><span class="s4">&quot;[selected]&quot;</span><span class="s1">).length ) { 
                rbuggyQSA.push( </span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">[&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*(?:value|&quot; </span><span class="s1">+ booleans + </span><span class="s4">&quot;)&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Support: Chrome&lt;29, Android&lt;4.2+, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.7+</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div.querySelectorAll( </span><span class="s4">&quot;[id~=&quot; </span><span class="s1">+ expando + </span><span class="s4">&quot;-]&quot; </span><span class="s1">).length ) { 
                rbuggyQSA.push(</span><span class="s4">&quot;~=&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Webkit/Opera - :checked should return selected option elements</span><span class="s1"> 
            </span><span class="s0">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span><span class="s1"> 
            </span><span class="s0">// IE8 throws error here and will not see later tests</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div.querySelectorAll(</span><span class="s4">&quot;:checked&quot;</span><span class="s1">).length ) { 
                rbuggyQSA.push(</span><span class="s4">&quot;:checked&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Support: Safari 8+, iOS 8+</span><span class="s1"> 
            </span><span class="s0">// https://bugs.webkit.org/show_bug.cgi?id=136851</span><span class="s1"> 
            </span><span class="s0">// In-page `selector#id sibing-combinator selector` fails</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div.querySelectorAll( </span><span class="s4">&quot;a#&quot; </span><span class="s1">+ expando + </span><span class="s4">&quot;+*&quot; </span><span class="s1">).length ) { 
                rbuggyQSA.push(</span><span class="s4">&quot;.#.+[+~]&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
 
        assert(</span><span class="s2">function</span><span class="s1">( div ) { 
            </span><span class="s0">// Support: Windows 8 Native Apps</span><span class="s1"> 
            </span><span class="s0">// The type and name attributes are restricted during .innerHTML assignment</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">input = doc.createElement(</span><span class="s4">&quot;input&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            input.setAttribute( </span><span class="s4">&quot;type&quot;</span><span class="s3">, </span><span class="s4">&quot;hidden&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            div.appendChild( input ).setAttribute( </span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s4">&quot;D&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Support: IE8</span><span class="s1"> 
            </span><span class="s0">// Enforce case-sensitivity of name attribute</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( div.querySelectorAll(</span><span class="s4">&quot;[name=d]&quot;</span><span class="s1">).length ) { 
                rbuggyQSA.push( </span><span class="s4">&quot;name&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;*[*^$|!~]?=&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)</span><span class="s1"> 
            </span><span class="s0">// IE8 throws error here and will not see later tests</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div.querySelectorAll(</span><span class="s4">&quot;:enabled&quot;</span><span class="s1">).length ) { 
                rbuggyQSA.push( </span><span class="s4">&quot;:enabled&quot;</span><span class="s3">, </span><span class="s4">&quot;:disabled&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Opera 10-11 does not throw on post-comma invalid pseudos</span><span class="s1"> 
            div.querySelectorAll(</span><span class="s4">&quot;*,:x&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            rbuggyQSA.push(</span><span class="s4">&quot;,.*:&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( (support.matchesSelector = rnative.test( (matches = docElem.matches || 
        docElem.webkitMatchesSelector || 
        docElem.mozMatchesSelector || 
        docElem.oMatchesSelector || 
        docElem.msMatchesSelector) )) ) { 
 
        assert(</span><span class="s2">function</span><span class="s1">( div ) { 
            </span><span class="s0">// Check to see if it's possible to do matchesSelector</span><span class="s1"> 
            </span><span class="s0">// on a disconnected node (IE 9)</span><span class="s1"> 
            support.disconnectedMatch = matches.call( div</span><span class="s3">, </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// This should fail with an exception</span><span class="s1"> 
            </span><span class="s0">// Gecko does not error, returns false instead</span><span class="s1"> 
            matches.call( div</span><span class="s3">, </span><span class="s4">&quot;[s!='']:x&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            rbuggyMatches.push( </span><span class="s4">&quot;!=&quot;</span><span class="s3">, </span><span class="s1">pseudos )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
 
    rbuggyQSA = rbuggyQSA.length &amp;&amp; </span><span class="s2">new </span><span class="s1">RegExp( rbuggyQSA.join(</span><span class="s4">&quot;|&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
    rbuggyMatches = rbuggyMatches.length &amp;&amp; </span><span class="s2">new </span><span class="s1">RegExp( rbuggyMatches.join(</span><span class="s4">&quot;|&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">/* Contains 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
    hasCompare = rnative.test( docElem.compareDocumentPosition )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Element contains another</span><span class="s1"> 
    </span><span class="s0">// Purposefully does not implement inclusive descendent</span><span class="s1"> 
    </span><span class="s0">// As in, an element does not contain itself</span><span class="s1"> 
    contains = hasCompare || rnative.test( docElem.contains ) ? 
        </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">b ) { 
            </span><span class="s2">var </span><span class="s1">adown = a.nodeType === </span><span class="s5">9 </span><span class="s1">? a.documentElement : a</span><span class="s3">,</span><span class="s1"> 
                bup = b &amp;&amp; b.parentNode</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">a === bup || !!( bup &amp;&amp; bup.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; ( 
                adown.contains ? 
                    adown.contains( bup ) : 
                    a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; </span><span class="s5">16</span><span class="s1"> 
            ))</span><span class="s3">;</span><span class="s1"> 
        } : 
        </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">b ) { 
            </span><span class="s2">if </span><span class="s1">( b ) { 
                </span><span class="s2">while </span><span class="s1">( (b = b.parentNode) ) { 
                    </span><span class="s2">if </span><span class="s1">( b === a ) { 
                        </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
            </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">/* Sorting 
    ---------------------------------------------------------------------- */</span><span class="s1"> 
 
    </span><span class="s0">// Document order sorting</span><span class="s1"> 
    sortOrder = hasCompare ? 
    </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">b ) { 
 
        </span><span class="s0">// Flag for duplicate removal</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( a === b ) { 
            hasDuplicate = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Sort on method existence if only one input has compareDocumentPosition</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">compare = !a.compareDocumentPosition - !b.compareDocumentPosition</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( compare ) { 
            </span><span class="s2">return </span><span class="s1">compare</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Calculate position if both inputs belong to the same document</span><span class="s1"> 
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ? 
            a.compareDocumentPosition( b ) : 
 
            </span><span class="s0">// Otherwise we know they are disconnected</span><span class="s1"> 
            </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Disconnected nodes</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( compare &amp; </span><span class="s5">1 </span><span class="s1">|| 
            (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) { 
 
            </span><span class="s0">// Choose the first element that is related to our preferred document</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc</span><span class="s3">, </span><span class="s1">a) ) { 
                </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">if </span><span class="s1">( b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc</span><span class="s3">, </span><span class="s1">b) ) { 
                </span><span class="s2">return </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Maintain original order</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">sortInput ? 
                ( indexOf( sortInput</span><span class="s3">, </span><span class="s1">a ) - indexOf( sortInput</span><span class="s3">, </span><span class="s1">b ) ) : 
                </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">compare &amp; </span><span class="s5">4 </span><span class="s1">? -</span><span class="s5">1 </span><span class="s1">: </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
    } : 
    </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">b ) { 
        </span><span class="s0">// Exit early if the nodes are identical</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( a === b ) { 
            hasDuplicate = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">var </span><span class="s1">cur</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            aup = a.parentNode</span><span class="s3">,</span><span class="s1"> 
            bup = b.parentNode</span><span class="s3">,</span><span class="s1"> 
            ap = [ a ]</span><span class="s3">,</span><span class="s1"> 
            bp = [ b ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Parentless nodes are either documents or disconnected</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !aup || !bup ) { 
            </span><span class="s2">return </span><span class="s1">a === doc ? -</span><span class="s5">1 </span><span class="s1">: 
                b === doc ? </span><span class="s5">1 </span><span class="s1">: 
                aup ? -</span><span class="s5">1 </span><span class="s1">: 
                bup ? </span><span class="s5">1 </span><span class="s1">: 
                sortInput ? 
                ( indexOf( sortInput</span><span class="s3">, </span><span class="s1">a ) - indexOf( sortInput</span><span class="s3">, </span><span class="s1">b ) ) : 
                </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If the nodes are siblings, we can do a quick check</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( aup === bup ) { 
            </span><span class="s2">return </span><span class="s1">siblingCheck( a</span><span class="s3">, </span><span class="s1">b )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Otherwise we need full lists of their ancestors for comparison</span><span class="s1"> 
        cur = a</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (cur = cur.parentNode) ) { 
            ap.unshift( cur )</span><span class="s3">;</span><span class="s1"> 
        } 
        cur = b</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (cur = cur.parentNode) ) { 
            bp.unshift( cur )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Walk down the tree looking for a discrepancy</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( ap[i] === bp[i] ) { 
            i++</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">i ? 
            </span><span class="s0">// Do a sibling check if the nodes have a common ancestor</span><span class="s1"> 
            siblingCheck( ap[i]</span><span class="s3">, </span><span class="s1">bp[i] ) : 
 
            </span><span class="s0">// Otherwise nodes in our document sort first</span><span class="s1"> 
            ap[i] === preferredDoc ? -</span><span class="s5">1 </span><span class="s1">: 
            bp[i] === preferredDoc ? </span><span class="s5">1 </span><span class="s1">: 
            </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">doc</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Sizzle.matches = </span><span class="s2">function</span><span class="s1">( expr</span><span class="s3">, </span><span class="s1">elements ) { 
    </span><span class="s2">return </span><span class="s1">Sizzle( expr</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">elements )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Sizzle.matchesSelector = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">expr ) { 
    </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( ( elem.ownerDocument || elem ) !== document ) { 
        setDocument( elem )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Make sure that attribute selectors are quoted</span><span class="s1"> 
    expr = expr.replace( rattributeQuotes</span><span class="s3">, </span><span class="s4">&quot;='$1']&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp; 
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp; 
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) { 
 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">var </span><span class="s1">ret = matches.call( elem</span><span class="s3">, </span><span class="s1">expr )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// IE 9's matchesSelector returns false on disconnected nodes</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( ret || support.disconnectedMatch || 
                    </span><span class="s0">// As well, disconnected nodes are said to be in a document</span><span class="s1"> 
                    </span><span class="s0">// fragment in IE 9</span><span class="s1"> 
                    elem.document &amp;&amp; elem.document.nodeType !== </span><span class="s5">11 </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
            } 
        } </span><span class="s2">catch </span><span class="s1">(e) {} 
    } 
 
    </span><span class="s2">return </span><span class="s1">Sizzle( expr</span><span class="s3">, </span><span class="s1">document</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">[ elem ] ).length &gt; </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Sizzle.contains = </span><span class="s2">function</span><span class="s1">( context</span><span class="s3">, </span><span class="s1">elem ) { 
    </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( ( context.ownerDocument || context ) !== document ) { 
        setDocument( context )</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">contains( context</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Sizzle.attr = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name ) { 
    </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( ( elem.ownerDocument || elem ) !== document ) { 
        setDocument( elem )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">fn = Expr.attrHandle[ name.toLowerCase() ]</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Don't get fooled by Object.prototype properties (jQuery #13807)</span><span class="s1"> 
        val = fn &amp;&amp; hasOwn.call( Expr.attrHandle</span><span class="s3">, </span><span class="s1">name.toLowerCase() ) ? 
            fn( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">!documentIsHTML ) : 
            undefined</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">val !== undefined ? 
        val : 
        support.attributes || !documentIsHTML ? 
            elem.getAttribute( name ) : 
            (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ? 
                val.value : 
                </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Sizzle.error = </span><span class="s2">function</span><span class="s1">( msg ) { 
    </span><span class="s2">throw new </span><span class="s1">Error( </span><span class="s4">&quot;Syntax error, unrecognized expression: &quot; </span><span class="s1">+ msg )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Document sorting and removing duplicates 
 * </span><span class="s7">@param </span><span class="s6">{ArrayLike} results 
 */</span><span class="s1"> 
Sizzle.uniqueSort = </span><span class="s2">function</span><span class="s1">( results ) { 
    </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
        duplicates = []</span><span class="s3">,</span><span class="s1"> 
        j = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Unless we *know* we can detect duplicates, assume their presence</span><span class="s1"> 
    hasDuplicate = !support.detectDuplicates</span><span class="s3">;</span><span class="s1"> 
    sortInput = !support.sortStable &amp;&amp; results.slice( </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    results.sort( sortOrder )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( hasDuplicate ) { 
        </span><span class="s2">while </span><span class="s1">( (elem = results[i++]) ) { 
            </span><span class="s2">if </span><span class="s1">( elem === results[ i ] ) { 
                j = duplicates.push( i )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
        </span><span class="s2">while </span><span class="s1">( j-- ) { 
            results.splice( duplicates[ j ]</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Clear input after sorting to release objects</span><span class="s1"> 
    </span><span class="s0">// See https://github.com/jquery/sizzle/pull/225</span><span class="s1"> 
    sortInput = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Utility function for retrieving the text value of an array of DOM nodes 
 * </span><span class="s7">@param </span><span class="s6">{Array|Element} elem 
 */</span><span class="s1"> 
getText = Sizzle.getText = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s2">var </span><span class="s1">node</span><span class="s3">,</span><span class="s1"> 
        ret = </span><span class="s4">&quot;&quot;</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        nodeType = elem.nodeType</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( !nodeType ) { 
        </span><span class="s0">// If no nodeType, this is expected to be an array</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (node = elem[i++]) ) { 
            </span><span class="s0">// Do not traverse comment nodes</span><span class="s1"> 
            ret += getText( node )</span><span class="s3">;</span><span class="s1"> 
        } 
    } </span><span class="s2">else if </span><span class="s1">( nodeType === </span><span class="s5">1 </span><span class="s1">|| nodeType === </span><span class="s5">9 </span><span class="s1">|| nodeType === </span><span class="s5">11 </span><span class="s1">) { 
        </span><span class="s0">// Use textContent for elements</span><span class="s1"> 
        </span><span class="s0">// innerText usage removed for consistency of new lines (jQuery #11153)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.textContent === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">elem.textContent</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// Traverse its children</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( elem = elem.firstChild</span><span class="s3">; </span><span class="s1">elem</span><span class="s3">; </span><span class="s1">elem = elem.nextSibling ) { 
                ret += getText( elem )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } </span><span class="s2">else if </span><span class="s1">( nodeType === </span><span class="s5">3 </span><span class="s1">|| nodeType === </span><span class="s5">4 </span><span class="s1">) { 
        </span><span class="s2">return </span><span class="s1">elem.nodeValue</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s0">// Do not include comment or processing instruction nodes</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
Expr = Sizzle.selectors = { 
 
    </span><span class="s0">// Can be adjusted by the user</span><span class="s1"> 
    cacheLength: </span><span class="s5">50</span><span class="s3">,</span><span class="s1"> 
 
    createPseudo: markFunction</span><span class="s3">,</span><span class="s1"> 
 
    match: matchExpr</span><span class="s3">,</span><span class="s1"> 
 
    attrHandle: {}</span><span class="s3">,</span><span class="s1"> 
 
    find: {}</span><span class="s3">,</span><span class="s1"> 
 
    relative: { 
        </span><span class="s4">&quot;&gt;&quot;</span><span class="s1">: { dir: </span><span class="s4">&quot;parentNode&quot;</span><span class="s3">, </span><span class="s1">first: </span><span class="s2">true </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot; &quot;</span><span class="s1">: { dir: </span><span class="s4">&quot;parentNode&quot; </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;+&quot;</span><span class="s1">: { dir: </span><span class="s4">&quot;previousSibling&quot;</span><span class="s3">, </span><span class="s1">first: </span><span class="s2">true </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;~&quot;</span><span class="s1">: { dir: </span><span class="s4">&quot;previousSibling&quot; </span><span class="s1">} 
    }</span><span class="s3">,</span><span class="s1"> 
 
    preFilter: { 
        </span><span class="s4">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
            match[</span><span class="s5">1</span><span class="s1">] = match[</span><span class="s5">1</span><span class="s1">].replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Move the given value to match[3] whether quoted or unquoted</span><span class="s1"> 
            match[</span><span class="s5">3</span><span class="s1">] = ( match[</span><span class="s5">3</span><span class="s1">] || match[</span><span class="s5">4</span><span class="s1">] || match[</span><span class="s5">5</span><span class="s1">] || </span><span class="s4">&quot;&quot; </span><span class="s1">).replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( match[</span><span class="s5">2</span><span class="s1">] === </span><span class="s4">&quot;~=&quot; </span><span class="s1">) { 
                match[</span><span class="s5">3</span><span class="s1">] = </span><span class="s4">&quot; &quot; </span><span class="s1">+ match[</span><span class="s5">3</span><span class="s1">] + </span><span class="s4">&quot; &quot;</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">match.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
            </span><span class="s0">/* matches from matchExpr[&quot;CHILD&quot;] 
                1 type (only|nth|...) 
                2 what (child|of-type) 
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...) 
                4 xn-component of xn+y argument ([+-]?\d*n|) 
                5 sign of xn-component 
                6 x of xn-component 
                7 sign of y-component 
                8 y of y-component 
            */</span><span class="s1"> 
            match[</span><span class="s5">1</span><span class="s1">] = match[</span><span class="s5">1</span><span class="s1">].toLowerCase()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( match[</span><span class="s5">1</span><span class="s1">].slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3 </span><span class="s1">) === </span><span class="s4">&quot;nth&quot; </span><span class="s1">) { 
                </span><span class="s0">// nth-* requires argument</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !match[</span><span class="s5">3</span><span class="s1">] ) { 
                    Sizzle.error( match[</span><span class="s5">0</span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// numeric x and y parameters for Expr.filter.CHILD</span><span class="s1"> 
                </span><span class="s0">// remember that false/true cast respectively to 0/1</span><span class="s1"> 
                match[</span><span class="s5">4</span><span class="s1">] = +( match[</span><span class="s5">4</span><span class="s1">] ? match[</span><span class="s5">5</span><span class="s1">] + (match[</span><span class="s5">6</span><span class="s1">] || </span><span class="s5">1</span><span class="s1">) : </span><span class="s5">2 </span><span class="s1">* ( match[</span><span class="s5">3</span><span class="s1">] === </span><span class="s4">&quot;even&quot; </span><span class="s1">|| match[</span><span class="s5">3</span><span class="s1">] === </span><span class="s4">&quot;odd&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                match[</span><span class="s5">5</span><span class="s1">] = +( ( match[</span><span class="s5">7</span><span class="s1">] + match[</span><span class="s5">8</span><span class="s1">] ) || match[</span><span class="s5">3</span><span class="s1">] === </span><span class="s4">&quot;odd&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// other types prohibit arguments</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( match[</span><span class="s5">3</span><span class="s1">] ) { 
                Sizzle.error( match[</span><span class="s5">0</span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">match</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
            </span><span class="s2">var </span><span class="s1">excess</span><span class="s3">,</span><span class="s1"> 
                unquoted = !match[</span><span class="s5">6</span><span class="s1">] &amp;&amp; match[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( matchExpr[</span><span class="s4">&quot;CHILD&quot;</span><span class="s1">].test( match[</span><span class="s5">0</span><span class="s1">] ) ) { 
                </span><span class="s2">return null</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Accept quoted arguments as-is</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( match[</span><span class="s5">3</span><span class="s1">] ) { 
                match[</span><span class="s5">2</span><span class="s1">] = match[</span><span class="s5">4</span><span class="s1">] || match[</span><span class="s5">5</span><span class="s1">] || </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Strip excess characters from unquoted arguments</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp; 
                </span><span class="s0">// Get excess from tokenize (recursively)</span><span class="s1"> 
                (excess = tokenize( unquoted</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)) &amp;&amp; 
                </span><span class="s0">// advance to the next closing parenthesis</span><span class="s1"> 
                (excess = unquoted.indexOf( </span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s1">unquoted.length - excess ) - unquoted.length) ) { 
 
                </span><span class="s0">// excess is a negative index</span><span class="s1"> 
                match[</span><span class="s5">0</span><span class="s1">] = match[</span><span class="s5">0</span><span class="s1">].slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">excess )</span><span class="s3">;</span><span class="s1"> 
                match[</span><span class="s5">2</span><span class="s1">] = unquoted.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">excess )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Return only captures needed by the pseudo filter method (type and argument)</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">match.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    filter: { 
 
        </span><span class="s4">&quot;TAG&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( nodeNameSelector ) { 
            </span><span class="s2">var </span><span class="s1">nodeName = nodeNameSelector.replace( runescape</span><span class="s3">, </span><span class="s1">funescape ).toLowerCase()</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">nodeNameSelector === </span><span class="s4">&quot;*&quot; </span><span class="s1">? 
                </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return true</span><span class="s3">; </span><span class="s1">} : 
                </span><span class="s2">function</span><span class="s1">( elem ) { 
                    </span><span class="s2">return </span><span class="s1">elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;CLASS&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( className ) { 
            </span><span class="s2">var </span><span class="s1">pattern = classCache[ className + </span><span class="s4">&quot; &quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">pattern || 
                (pattern = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;(^|&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;)&quot; </span><span class="s1">+ className + </span><span class="s4">&quot;(&quot; </span><span class="s1">+ whitespace + </span><span class="s4">&quot;|$)&quot; </span><span class="s1">)) &amp;&amp; 
                classCache( className</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
                    </span><span class="s2">return </span><span class="s1">pattern.test( </span><span class="s2">typeof </span><span class="s1">elem.className === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; elem.className || </span><span class="s2">typeof </span><span class="s1">elem.getAttribute !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">&amp;&amp; elem.getAttribute(</span><span class="s4">&quot;class&quot;</span><span class="s1">) || </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                })</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">, </span><span class="s1">check ) { 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">result = Sizzle.attr( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( result == </span><span class="s2">null </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">operator === </span><span class="s4">&quot;!=&quot;</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">if </span><span class="s1">( !operator ) { 
                    </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                } 
 
                result += </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">return </span><span class="s1">operator === </span><span class="s4">&quot;=&quot; </span><span class="s1">? result === check : 
                    operator === </span><span class="s4">&quot;!=&quot; </span><span class="s1">? result !== check : 
                    operator === </span><span class="s4">&quot;^=&quot; </span><span class="s1">? check &amp;&amp; result.indexOf( check ) === </span><span class="s5">0 </span><span class="s1">: 
                    operator === </span><span class="s4">&quot;*=&quot; </span><span class="s1">? check &amp;&amp; result.indexOf( check ) &gt; -</span><span class="s5">1 </span><span class="s1">: 
                    operator === </span><span class="s4">&quot;$=&quot; </span><span class="s1">? check &amp;&amp; result.slice( -check.length ) === check : 
                    operator === </span><span class="s4">&quot;~=&quot; </span><span class="s1">? ( </span><span class="s4">&quot; &quot; </span><span class="s1">+ result.replace( rwhitespace</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">) + </span><span class="s4">&quot; &quot; </span><span class="s1">).indexOf( check ) &gt; -</span><span class="s5">1 </span><span class="s1">: 
                    operator === </span><span class="s4">&quot;|=&quot; </span><span class="s1">? result === check || result.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">check.length + </span><span class="s5">1 </span><span class="s1">) === check + </span><span class="s4">&quot;-&quot; </span><span class="s1">: 
                    </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">what</span><span class="s3">, </span><span class="s1">argument</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">last ) { 
            </span><span class="s2">var </span><span class="s1">simple = type.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3 </span><span class="s1">) !== </span><span class="s4">&quot;nth&quot;</span><span class="s3">,</span><span class="s1"> 
                forward = type.slice( -</span><span class="s5">4 </span><span class="s1">) !== </span><span class="s4">&quot;last&quot;</span><span class="s3">,</span><span class="s1"> 
                ofType = what === </span><span class="s4">&quot;of-type&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">first === </span><span class="s5">1 </span><span class="s1">&amp;&amp; last === </span><span class="s5">0 </span><span class="s1">? 
 
                </span><span class="s0">// Shortcut for :nth-*(n)</span><span class="s1"> 
                </span><span class="s2">function</span><span class="s1">( elem ) { 
                    </span><span class="s2">return </span><span class="s1">!!elem.parentNode</span><span class="s3">;</span><span class="s1"> 
                } : 
 
                </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
                    </span><span class="s2">var </span><span class="s1">cache</span><span class="s3">, </span><span class="s1">outerCache</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">diff</span><span class="s3">, </span><span class="s1">nodeIndex</span><span class="s3">, </span><span class="s1">start</span><span class="s3">,</span><span class="s1"> 
                        dir = simple !== forward ? </span><span class="s4">&quot;nextSibling&quot; </span><span class="s1">: </span><span class="s4">&quot;previousSibling&quot;</span><span class="s3">,</span><span class="s1"> 
                        parent = elem.parentNode</span><span class="s3">,</span><span class="s1"> 
                        name = ofType &amp;&amp; elem.nodeName.toLowerCase()</span><span class="s3">,</span><span class="s1"> 
                        useCache = !xml &amp;&amp; !ofType</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( parent ) { 
 
                        </span><span class="s0">// :(first|last|only)-(child|of-type)</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( simple ) { 
                            </span><span class="s2">while </span><span class="s1">( dir ) { 
                                node = elem</span><span class="s3">;</span><span class="s1"> 
                                </span><span class="s2">while </span><span class="s1">( (node = node[ dir ]) ) { 
                                    </span><span class="s2">if </span><span class="s1">( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                                        </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                                    } 
                                } 
                                </span><span class="s0">// Reverse direction for :only-* (if we haven't yet done so)</span><span class="s1"> 
                                start = dir = type === </span><span class="s4">&quot;only&quot; </span><span class="s1">&amp;&amp; !start &amp;&amp; </span><span class="s4">&quot;nextSibling&quot;</span><span class="s3">;</span><span class="s1"> 
                            } 
                            </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        start = [ forward ? parent.firstChild : parent.lastChild ]</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// non-xml :nth-child(...) stores cache data on `parent`</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( forward &amp;&amp; useCache ) { 
                            </span><span class="s0">// Seek `elem` from a previously-cached index</span><span class="s1"> 
                            outerCache = parent[ expando ] || (parent[ expando ] = {})</span><span class="s3">;</span><span class="s1"> 
                            cache = outerCache[ type ] || []</span><span class="s3">;</span><span class="s1"> 
                            nodeIndex = cache[</span><span class="s5">0</span><span class="s1">] === dirruns &amp;&amp; cache[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                            diff = cache[</span><span class="s5">0</span><span class="s1">] === dirruns &amp;&amp; cache[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                            node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ]</span><span class="s3">;</span><span class="s1"> 
 
                            </span><span class="s2">while </span><span class="s1">( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || 
 
                                </span><span class="s0">// Fallback to seeking `elem` from the start</span><span class="s1"> 
                                (diff = nodeIndex = </span><span class="s5">0</span><span class="s1">) || start.pop()) ) { 
 
                                </span><span class="s0">// When found, cache indexes on `parent` and break</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( node.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; ++diff &amp;&amp; node === elem ) { 
                                    outerCache[ type ] = [ dirruns</span><span class="s3">, </span><span class="s1">nodeIndex</span><span class="s3">, </span><span class="s1">diff ]</span><span class="s3">;</span><span class="s1"> 
                                    </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } 
 
                        </span><span class="s0">// Use previously-cached element index if available</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[</span><span class="s5">0</span><span class="s1">] === dirruns ) { 
                            diff = cache[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)</span><span class="s1"> 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            </span><span class="s0">// Use the same loop as above to seek `elem` from the start</span><span class="s1"> 
                            </span><span class="s2">while </span><span class="s1">( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || 
                                (diff = nodeIndex = </span><span class="s5">0</span><span class="s1">) || start.pop()) ) { 
 
                                </span><span class="s2">if </span><span class="s1">( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === </span><span class="s5">1 </span><span class="s1">) &amp;&amp; ++diff ) { 
                                    </span><span class="s0">// Cache the index of each encountered element</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( useCache ) { 
                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns</span><span class="s3">, </span><span class="s1">diff ]</span><span class="s3">;</span><span class="s1"> 
                                    } 
 
                                    </span><span class="s2">if </span><span class="s1">( node === elem ) { 
                                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                                    } 
                                } 
                            } 
                        } 
 
                        </span><span class="s0">// Incorporate the offset, then check against cycle size</span><span class="s1"> 
                        diff -= last</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">diff === first || ( diff % first === </span><span class="s5">0 </span><span class="s1">&amp;&amp; diff / first &gt;= </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    } 
                }</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( pseudo</span><span class="s3">, </span><span class="s1">argument ) { 
            </span><span class="s0">// pseudo-class names are case-insensitive</span><span class="s1"> 
            </span><span class="s0">// http://www.w3.org/TR/selectors/#pseudo-classes</span><span class="s1"> 
            </span><span class="s0">// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters</span><span class="s1"> 
            </span><span class="s0">// Remember that setFilters inherits from pseudos</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">args</span><span class="s3">,</span><span class="s1"> 
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] || 
                    Sizzle.error( </span><span class="s4">&quot;unsupported pseudo: &quot; </span><span class="s1">+ pseudo )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// The user may use createPseudo to indicate that</span><span class="s1"> 
            </span><span class="s0">// arguments are needed to create the filter function</span><span class="s1"> 
            </span><span class="s0">// just as Sizzle does</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( fn[ expando ] ) { 
                </span><span class="s2">return </span><span class="s1">fn( argument )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// But maintain support for old signatures</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( fn.length &gt; </span><span class="s5">1 </span><span class="s1">) { 
                args = [ pseudo</span><span class="s3">, </span><span class="s1">pseudo</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">argument ]</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ? 
                    markFunction(</span><span class="s2">function</span><span class="s1">( seed</span><span class="s3">, </span><span class="s1">matches ) { 
                        </span><span class="s2">var </span><span class="s1">idx</span><span class="s3">,</span><span class="s1"> 
                            matched = fn( seed</span><span class="s3">, </span><span class="s1">argument )</span><span class="s3">,</span><span class="s1"> 
                            i = matched.length</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
                            idx = indexOf( seed</span><span class="s3">, </span><span class="s1">matched[i] )</span><span class="s3">;</span><span class="s1"> 
                            seed[ idx ] = !( matches[ idx ] = matched[i] )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    }) : 
                    </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">fn( elem</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
                    }</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">fn</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    pseudos: { 
        </span><span class="s0">// Potentially complex pseudos</span><span class="s1"> 
        </span><span class="s4">&quot;not&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s0">// Trim the selector passed to compile</span><span class="s1"> 
            </span><span class="s0">// to avoid treating leading and trailing</span><span class="s1"> 
            </span><span class="s0">// spaces as combinators</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">input = []</span><span class="s3">,</span><span class="s1"> 
                results = []</span><span class="s3">,</span><span class="s1"> 
                matcher = compile( selector.replace( rtrim</span><span class="s3">, </span><span class="s4">&quot;$1&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">matcher[ expando ] ? 
                markFunction(</span><span class="s2">function</span><span class="s1">( seed</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
                    </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
                        unmatched = matcher( seed</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">xml</span><span class="s3">, </span><span class="s1">[] )</span><span class="s3">,</span><span class="s1"> 
                        i = seed.length</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Match elements unmatched by `matcher`</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                        </span><span class="s2">if </span><span class="s1">( (elem = unmatched[i]) ) { 
                            seed[i] = !(matches[i] = elem)</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                }) : 
                </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
                    input[</span><span class="s5">0</span><span class="s1">] = elem</span><span class="s3">;</span><span class="s1"> 
                    matcher( input</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">xml</span><span class="s3">, </span><span class="s1">results )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s0">// Don't keep the element (issue #299)</span><span class="s1"> 
                    input[</span><span class="s5">0</span><span class="s1">] = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">!results.pop()</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;has&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">Sizzle( selector</span><span class="s3">, </span><span class="s1">elem ).length &gt; </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;contains&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( text ) { 
            text = text.replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// &quot;Whether an element is represented by a :lang() selector</span><span class="s1"> 
        </span><span class="s0">// is based solely on the element's language value</span><span class="s1"> 
        </span><span class="s0">// being equal to the identifier C,</span><span class="s1"> 
        </span><span class="s0">// or beginning with the identifier C immediately followed by &quot;-&quot;.</span><span class="s1"> 
        </span><span class="s0">// The matching of C against the element's language value is performed case-insensitively.</span><span class="s1"> 
        </span><span class="s0">// The identifier C does not have to be a valid language name.&quot;</span><span class="s1"> 
        </span><span class="s0">// http://www.w3.org/TR/selectors/#lang-pseudo</span><span class="s1"> 
        </span><span class="s4">&quot;lang&quot;</span><span class="s1">: markFunction( </span><span class="s2">function</span><span class="s1">( lang ) { 
            </span><span class="s0">// lang value must be a valid identifier</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !ridentifier.test(lang || </span><span class="s4">&quot;&quot;</span><span class="s1">) ) { 
                Sizzle.error( </span><span class="s4">&quot;unsupported lang: &quot; </span><span class="s1">+ lang )</span><span class="s3">;</span><span class="s1"> 
            } 
            lang = lang.replace( runescape</span><span class="s3">, </span><span class="s1">funescape ).toLowerCase()</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">elemLang</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">do </span><span class="s1">{ 
                    </span><span class="s2">if </span><span class="s1">( (elemLang = documentIsHTML ? 
                        elem.lang : 
                        elem.getAttribute(</span><span class="s4">&quot;xml:lang&quot;</span><span class="s1">) || elem.getAttribute(</span><span class="s4">&quot;lang&quot;</span><span class="s1">)) ) { 
 
                        elemLang = elemLang.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">elemLang === lang || elemLang.indexOf( lang + </span><span class="s4">&quot;-&quot; </span><span class="s1">) === </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                    } 
                } </span><span class="s2">while </span><span class="s1">( (elem = elem.parentNode) &amp;&amp; elem.nodeType === </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Miscellaneous</span><span class="s1"> 
        </span><span class="s4">&quot;target&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">var </span><span class="s1">hash = window.location &amp;&amp; window.location.hash</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">hash &amp;&amp; hash.slice( </span><span class="s5">1 </span><span class="s1">) === elem.id</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;root&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem === docElem</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;focus&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex)</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Boolean properties</span><span class="s1"> 
        </span><span class="s4">&quot;enabled&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem.disabled === </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;disabled&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem.disabled === </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;checked&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s0">// In CSS3, :checked should return both checked and selected elements</span><span class="s1"> 
            </span><span class="s0">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">nodeName = elem.nodeName.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">(nodeName === </span><span class="s4">&quot;input&quot; </span><span class="s1">&amp;&amp; !!elem.checked) || (nodeName === </span><span class="s4">&quot;option&quot; </span><span class="s1">&amp;&amp; !!elem.selected)</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;selected&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s0">// Accessing this property makes selected-by-default</span><span class="s1"> 
            </span><span class="s0">// options in Safari work properly</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( elem.parentNode ) { 
                elem.parentNode.selectedIndex</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">elem.selected === </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Contents</span><span class="s1"> 
        </span><span class="s4">&quot;empty&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s0">// http://www.w3.org/TR/selectors/#empty-pseudo</span><span class="s1"> 
            </span><span class="s0">// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),</span><span class="s1"> 
            </span><span class="s0">//   but not by others (comment: 8; processing instruction: 7; etc.)</span><span class="s1"> 
            </span><span class="s0">// nodeType &lt; 6 works because attributes (2) do not appear as children</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( elem = elem.firstChild</span><span class="s3">; </span><span class="s1">elem</span><span class="s3">; </span><span class="s1">elem = elem.nextSibling ) { 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType &lt; </span><span class="s5">6 </span><span class="s1">) { 
                    </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;parent&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">!Expr.pseudos[</span><span class="s4">&quot;empty&quot;</span><span class="s1">]( elem )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Element/input types</span><span class="s1"> 
        </span><span class="s4">&quot;header&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">rheader.test( elem.nodeName )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;input&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">rinputs.test( elem.nodeName )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;button&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">name === </span><span class="s4">&quot;input&quot; </span><span class="s1">&amp;&amp; elem.type === </span><span class="s4">&quot;button&quot; </span><span class="s1">|| name === </span><span class="s4">&quot;button&quot;</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;text&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">var </span><span class="s1">attr</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">elem.nodeName.toLowerCase() === </span><span class="s4">&quot;input&quot; </span><span class="s1">&amp;&amp; 
                elem.type === </span><span class="s4">&quot;text&quot; </span><span class="s1">&amp;&amp; 
 
                </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
                </span><span class="s0">// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;</span><span class="s1"> 
                ( (attr = elem.getAttribute(</span><span class="s4">&quot;type&quot;</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">|| attr.toLowerCase() === </span><span class="s4">&quot;text&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Position-in-collection</span><span class="s1"> 
        </span><span class="s4">&quot;first&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;last&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length ) { 
            </span><span class="s2">return </span><span class="s1">[ length - </span><span class="s5">1 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;eq&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">argument ) { 
            </span><span class="s2">return </span><span class="s1">[ argument &lt; </span><span class="s5">0 </span><span class="s1">? argument + length : argument ]</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;even&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length ) { 
            </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i += </span><span class="s5">2 </span><span class="s1">) { 
                matchIndexes.push( i )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">matchIndexes</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;odd&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length ) { 
            </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i += </span><span class="s5">2 </span><span class="s1">) { 
                matchIndexes.push( i )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">matchIndexes</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;lt&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">argument ) { 
            </span><span class="s2">var </span><span class="s1">i = argument &lt; </span><span class="s5">0 </span><span class="s1">? argument + length : argument</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">--i &gt;= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">) { 
                matchIndexes.push( i )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">matchIndexes</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s4">&quot;gt&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">argument ) { 
            </span><span class="s2">var </span><span class="s1">i = argument &lt; </span><span class="s5">0 </span><span class="s1">? argument + length : argument</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">++i &lt; length</span><span class="s3">; </span><span class="s1">) { 
                matchIndexes.push( i )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">matchIndexes</span><span class="s3">;</span><span class="s1"> 
        }) 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
Expr.pseudos[</span><span class="s4">&quot;nth&quot;</span><span class="s1">] = Expr.pseudos[</span><span class="s4">&quot;eq&quot;</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Add button/input type pseudos</span><span class="s1"> 
</span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ radio: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">checkbox: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">file: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">password: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">image: </span><span class="s2">true </span><span class="s1">} ) { 
    Expr.pseudos[ i ] = createInputPseudo( i )</span><span class="s3">;</span><span class="s1"> 
} 
</span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ submit: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">reset: </span><span class="s2">true </span><span class="s1">} ) { 
    Expr.pseudos[ i ] = createButtonPseudo( i )</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Easy API for creating new setFilters</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">setFilters() {} 
setFilters.prototype = Expr.filters = Expr.pseudos</span><span class="s3">;</span><span class="s1"> 
Expr.setFilters = </span><span class="s2">new </span><span class="s1">setFilters()</span><span class="s3">;</span><span class="s1"> 
 
tokenize = Sizzle.tokenize = </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">parseOnly ) { 
    </span><span class="s2">var </span><span class="s1">matched</span><span class="s3">, </span><span class="s1">match</span><span class="s3">, </span><span class="s1">tokens</span><span class="s3">, </span><span class="s1">type</span><span class="s3">,</span><span class="s1"> 
        soFar</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">preFilters</span><span class="s3">,</span><span class="s1"> 
        cached = tokenCache[ selector + </span><span class="s4">&quot; &quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( cached ) { 
        </span><span class="s2">return </span><span class="s1">parseOnly ? </span><span class="s5">0 </span><span class="s1">: cached.slice( </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } 
 
    soFar = selector</span><span class="s3">;</span><span class="s1"> 
    groups = []</span><span class="s3">;</span><span class="s1"> 
    preFilters = Expr.preFilter</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">while </span><span class="s1">( soFar ) { 
 
        </span><span class="s0">// Comma and first run</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !matched || (match = rcomma.exec( soFar )) ) { 
            </span><span class="s2">if </span><span class="s1">( match ) { 
                </span><span class="s0">// Don't consume trailing commas as valid</span><span class="s1"> 
                soFar = soFar.slice( match[</span><span class="s5">0</span><span class="s1">].length ) || soFar</span><span class="s3">;</span><span class="s1"> 
            } 
            groups.push( (tokens = []) )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        matched = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Combinators</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( (match = rcombinators.exec( soFar )) ) { 
            matched = match.shift()</span><span class="s3">;</span><span class="s1"> 
            tokens.push({ 
                value: matched</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// Cast descendant combinators to space</span><span class="s1"> 
                type: match[</span><span class="s5">0</span><span class="s1">].replace( rtrim</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">) 
            })</span><span class="s3">;</span><span class="s1"> 
            soFar = soFar.slice( matched.length )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Filters</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">Expr.filter ) { 
            </span><span class="s2">if </span><span class="s1">( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] || 
                (match = preFilters[ type ]( match ))) ) { 
                matched = match.shift()</span><span class="s3">;</span><span class="s1"> 
                tokens.push({ 
                    value: matched</span><span class="s3">,</span><span class="s1"> 
                    type: type</span><span class="s3">,</span><span class="s1"> 
                    matches: match 
                })</span><span class="s3">;</span><span class="s1"> 
                soFar = soFar.slice( matched.length )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( !matched ) { 
            </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Return the length of the invalid excess</span><span class="s1"> 
    </span><span class="s0">// if we're just parsing</span><span class="s1"> 
    </span><span class="s0">// Otherwise, throw an error or return tokens</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">parseOnly ? 
        soFar.length : 
        soFar ? 
            Sizzle.error( selector ) : 
            </span><span class="s0">// Cache the tokens</span><span class="s1"> 
            tokenCache( selector</span><span class="s3">, </span><span class="s1">groups ).slice( </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">toSelector( tokens ) { 
    </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        len = tokens.length</span><span class="s3">,</span><span class="s1"> 
        selector = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
        selector += tokens[i].value</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">selector</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">addCombinator( matcher</span><span class="s3">, </span><span class="s1">combinator</span><span class="s3">, </span><span class="s1">base ) { 
    </span><span class="s2">var </span><span class="s1">dir = combinator.dir</span><span class="s3">,</span><span class="s1"> 
        checkNonElements = base &amp;&amp; dir === </span><span class="s4">&quot;parentNode&quot;</span><span class="s3">,</span><span class="s1"> 
        doneName = done++</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">combinator.first ? 
        </span><span class="s0">// Check against closest ancestor/preceding element</span><span class="s1"> 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
            </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">|| checkNonElements ) { 
                    </span><span class="s2">return </span><span class="s1">matcher( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } : 
 
        </span><span class="s0">// Check against all ancestor/preceding elements</span><span class="s1"> 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
            </span><span class="s2">var </span><span class="s1">oldCache</span><span class="s3">, </span><span class="s1">outerCache</span><span class="s3">,</span><span class="s1"> 
                newCache = [ dirruns</span><span class="s3">, </span><span class="s1">doneName ]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( xml ) { 
                </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                    </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">|| checkNonElements ) { 
                        </span><span class="s2">if </span><span class="s1">( matcher( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) ) { 
                            </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                    </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">|| checkNonElements ) { 
                        outerCache = elem[ expando ] || (elem[ expando ] = {})</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( (oldCache = outerCache[ dir ]) &amp;&amp; 
                            oldCache[ </span><span class="s5">0 </span><span class="s1">] === dirruns &amp;&amp; oldCache[ </span><span class="s5">1 </span><span class="s1">] === doneName ) { 
 
                            </span><span class="s0">// Assign to newCache so results back-propagate to previous elements</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">(newCache[ </span><span class="s5">2 </span><span class="s1">] = oldCache[ </span><span class="s5">2 </span><span class="s1">])</span><span class="s3">;</span><span class="s1"> 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            </span><span class="s0">// Reuse newcache so results back-propagate to previous elements</span><span class="s1"> 
                            outerCache[ dir ] = newCache</span><span class="s3">;</span><span class="s1"> 
 
                            </span><span class="s0">// A match means we're done; a fail means we have to keep checking</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( (newCache[ </span><span class="s5">2 </span><span class="s1">] = matcher( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml )) ) { 
                                </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
                } 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">elementMatcher( matchers ) { 
    </span><span class="s2">return </span><span class="s1">matchers.length &gt; </span><span class="s5">1 </span><span class="s1">? 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
            </span><span class="s2">var </span><span class="s1">i = matchers.length</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                </span><span class="s2">if </span><span class="s1">( !matchers[i]( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) ) { 
                    </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
        } : 
        matchers[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">multipleContexts( selector</span><span class="s3">, </span><span class="s1">contexts</span><span class="s3">, </span><span class="s1">results ) { 
    </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        len = contexts.length</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
        Sizzle( selector</span><span class="s3">, </span><span class="s1">contexts[i]</span><span class="s3">, </span><span class="s1">results )</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">condense( unmatched</span><span class="s3">, </span><span class="s1">map</span><span class="s3">, </span><span class="s1">filter</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
    </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
        newUnmatched = []</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        len = unmatched.length</span><span class="s3">,</span><span class="s1"> 
        mapped = map != </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
        </span><span class="s2">if </span><span class="s1">( (elem = unmatched[i]) ) { 
            </span><span class="s2">if </span><span class="s1">( !filter || filter( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) ) { 
                newUnmatched.push( elem )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( mapped ) { 
                    map.push( i )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">newUnmatched</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">setMatcher( preFilter</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">, </span><span class="s1">postFilter</span><span class="s3">, </span><span class="s1">postFinder</span><span class="s3">, </span><span class="s1">postSelector ) { 
    </span><span class="s2">if </span><span class="s1">( postFilter &amp;&amp; !postFilter[ expando ] ) { 
        postFilter = setMatcher( postFilter )</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">if </span><span class="s1">( postFinder &amp;&amp; !postFinder[ expando ] ) { 
        postFinder = setMatcher( postFinder</span><span class="s3">, </span><span class="s1">postSelector )</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( seed</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
        </span><span class="s2">var </span><span class="s1">temp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
            preMap = []</span><span class="s3">,</span><span class="s1"> 
            postMap = []</span><span class="s3">,</span><span class="s1"> 
            preexisting = results.length</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Get initial elements from seed or context</span><span class="s1"> 
            elems = seed || multipleContexts( selector || </span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s1">context.nodeType ? [ context ] : context</span><span class="s3">, </span><span class="s1">[] )</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Prefilter to get matcher input, preserving a map for seed-results synchronization</span><span class="s1"> 
            matcherIn = preFilter &amp;&amp; ( seed || !selector ) ? 
                condense( elems</span><span class="s3">, </span><span class="s1">preMap</span><span class="s3">, </span><span class="s1">preFilter</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) : 
                elems</span><span class="s3">,</span><span class="s1"> 
 
            matcherOut = matcher ? 
                </span><span class="s0">// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</span><span class="s1"> 
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ? 
 
                    </span><span class="s0">// ...intermediate processing is necessary</span><span class="s1"> 
                    [] : 
 
                    </span><span class="s0">// ...otherwise use results directly</span><span class="s1"> 
                    results : 
                matcherIn</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Find primary matches</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( matcher ) { 
            matcher( matcherIn</span><span class="s3">, </span><span class="s1">matcherOut</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Apply postFilter</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( postFilter ) { 
            temp = condense( matcherOut</span><span class="s3">, </span><span class="s1">postMap )</span><span class="s3">;</span><span class="s1"> 
            postFilter( temp</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Un-match failing elements by moving them back to matcherIn</span><span class="s1"> 
            i = temp.length</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                </span><span class="s2">if </span><span class="s1">( (elem = temp[i]) ) { 
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( seed ) { 
            </span><span class="s2">if </span><span class="s1">( postFinder || preFilter ) { 
                </span><span class="s2">if </span><span class="s1">( postFinder ) { 
                    </span><span class="s0">// Get the final matcherOut by condensing this intermediate into postFinder contexts</span><span class="s1"> 
                    temp = []</span><span class="s3">;</span><span class="s1"> 
                    i = matcherOut.length</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                        </span><span class="s2">if </span><span class="s1">( (elem = matcherOut[i]) ) { 
                            </span><span class="s0">// Restore matcherIn since elem is not yet a final match</span><span class="s1"> 
                            temp.push( (matcherIn[i] = elem) )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                    postFinder( </span><span class="s2">null</span><span class="s3">, </span><span class="s1">(matcherOut = [])</span><span class="s3">, </span><span class="s1">temp</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// Move matched elements from seed to results to keep them synchronized</span><span class="s1"> 
                i = matcherOut.length</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                    </span><span class="s2">if </span><span class="s1">( (elem = matcherOut[i]) &amp;&amp; 
                        (temp = postFinder ? indexOf( seed</span><span class="s3">, </span><span class="s1">elem ) : preMap[i]) &gt; -</span><span class="s5">1 </span><span class="s1">) { 
 
                        seed[temp] = !(results[temp] = elem)</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
        </span><span class="s0">// Add elements to results, through postFinder if defined</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            matcherOut = condense( 
                matcherOut === results ? 
                    matcherOut.splice( preexisting</span><span class="s3">, </span><span class="s1">matcherOut.length ) : 
                    matcherOut 
            )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( postFinder ) { 
                postFinder( </span><span class="s2">null</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">matcherOut</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                push.apply( results</span><span class="s3">, </span><span class="s1">matcherOut )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">matcherFromTokens( tokens ) { 
    </span><span class="s2">var </span><span class="s1">checkContext</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">, </span><span class="s1">j</span><span class="s3">,</span><span class="s1"> 
        len = tokens.length</span><span class="s3">,</span><span class="s1"> 
        leadingRelative = Expr.relative[ tokens[</span><span class="s5">0</span><span class="s1">].type ]</span><span class="s3">,</span><span class="s1"> 
        implicitRelative = leadingRelative || Expr.relative[</span><span class="s4">&quot; &quot;</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        i = leadingRelative ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// The foundational matcher ensures that elements are reachable from top-level context(s)</span><span class="s1"> 
        matchContext = addCombinator( </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem === checkContext</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">, </span><span class="s1">implicitRelative</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        matchAnyContext = addCombinator( </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">indexOf( checkContext</span><span class="s3">, </span><span class="s1">elem ) &gt; -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">, </span><span class="s1">implicitRelative</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        matchers = [ </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) { 
            </span><span class="s2">var </span><span class="s1">ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || ( 
                (checkContext = context).nodeType ? 
                    matchContext( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) : 
                    matchAnyContext( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Avoid hanging onto element (issue #299)</span><span class="s1"> 
            checkContext = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
        } ]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
        </span><span class="s2">if </span><span class="s1">( (matcher = Expr.relative[ tokens[i].type ]) ) { 
            matchers = [ addCombinator(elementMatcher( matchers )</span><span class="s3">, </span><span class="s1">matcher) ]</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            matcher = Expr.filter[ tokens[i].type ].apply( </span><span class="s2">null</span><span class="s3">, </span><span class="s1">tokens[i].matches )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Return special upon seeing a positional matcher</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( matcher[ expando ] ) { 
                </span><span class="s0">// Find the next relative operator (if any) for proper handling</span><span class="s1"> 
                j = ++i</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">j &lt; len</span><span class="s3">; </span><span class="s1">j++ ) { 
                    </span><span class="s2">if </span><span class="s1">( Expr.relative[ tokens[j].type ] ) { 
                        </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
                </span><span class="s2">return </span><span class="s1">setMatcher( 
                    i &gt; </span><span class="s5">1 </span><span class="s1">&amp;&amp; elementMatcher( matchers )</span><span class="s3">,</span><span class="s1"> 
                    i &gt; </span><span class="s5">1 </span><span class="s1">&amp;&amp; toSelector( 
                        </span><span class="s0">// If the preceding token was a descendant combinator, insert an implicit any-element `*`</span><span class="s1"> 
                        tokens.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">i - </span><span class="s5">1 </span><span class="s1">).concat({ value: tokens[ i - </span><span class="s5">2 </span><span class="s1">].type === </span><span class="s4">&quot; &quot; </span><span class="s1">? </span><span class="s4">&quot;*&quot; </span><span class="s1">: </span><span class="s4">&quot;&quot; </span><span class="s1">}) 
                    ).replace( rtrim</span><span class="s3">, </span><span class="s4">&quot;$1&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                    matcher</span><span class="s3">,</span><span class="s1"> 
                    i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i</span><span class="s3">, </span><span class="s1">j ) )</span><span class="s3">,</span><span class="s1"> 
                    j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) )</span><span class="s3">,</span><span class="s1"> 
                    j &lt; len &amp;&amp; toSelector( tokens ) 
                )</span><span class="s3">;</span><span class="s1"> 
            } 
            matchers.push( matcher )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">elementMatcher( matchers )</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">matcherFromGroupMatchers( elementMatchers</span><span class="s3">, </span><span class="s1">setMatchers ) { 
    </span><span class="s2">var </span><span class="s1">bySet = setMatchers.length &gt; </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        byElement = elementMatchers.length &gt; </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        superMatcher = </span><span class="s2">function</span><span class="s1">( seed</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">outermost ) { 
            </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">,</span><span class="s1"> 
                matchedCount = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                i = </span><span class="s4">&quot;0&quot;</span><span class="s3">,</span><span class="s1"> 
                unmatched = seed &amp;&amp; []</span><span class="s3">,</span><span class="s1"> 
                setMatched = []</span><span class="s3">,</span><span class="s1"> 
                contextBackup = outermostContext</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// We must always have either seed elements or outermost context</span><span class="s1"> 
                elems = seed || byElement &amp;&amp; Expr.find[</span><span class="s4">&quot;TAG&quot;</span><span class="s1">]( </span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s1">outermost )</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// Use integer dirruns iff this is the outermost matcher</span><span class="s1"> 
                dirrunsUnique = (dirruns += contextBackup == </span><span class="s2">null </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: Math.random() || </span><span class="s5">0.1</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                len = elems.length</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( outermost ) { 
                outermostContext = context !== document &amp;&amp; context</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Add elements passing elementMatchers directly to results</span><span class="s1"> 
            </span><span class="s0">// Keep `i` a string if there are no elements so `matchedCount` will be &quot;00&quot; below</span><span class="s1"> 
            </span><span class="s0">// Support: IE&lt;9, Safari</span><span class="s1"> 
            </span><span class="s0">// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i !== len &amp;&amp; (elem = elems[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
                </span><span class="s2">if </span><span class="s1">( byElement &amp;&amp; elem ) { 
                    j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( (matcher = elementMatchers[j++]) ) { 
                        </span><span class="s2">if </span><span class="s1">( matcher( elem</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml ) ) { 
                            results.push( elem )</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                    </span><span class="s2">if </span><span class="s1">( outermost ) { 
                        dirruns = dirrunsUnique</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
                </span><span class="s0">// Track unmatched elements for set filters</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( bySet ) { 
                    </span><span class="s0">// They will have gone through all possible matchers</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( (elem = !matcher &amp;&amp; elem) ) { 
                        matchedCount--</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Lengthen the array for every element, matched or not</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( seed ) { 
                        unmatched.push( elem )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
            </span><span class="s0">// Apply set filters to unmatched elements</span><span class="s1"> 
            matchedCount += i</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( bySet &amp;&amp; i !== matchedCount ) { 
                j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">while </span><span class="s1">( (matcher = setMatchers[j++]) ) { 
                    matcher( unmatched</span><span class="s3">, </span><span class="s1">setMatched</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">xml )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">if </span><span class="s1">( seed ) { 
                    </span><span class="s0">// Reintegrate element matches to eliminate the need for sorting</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( matchedCount &gt; </span><span class="s5">0 </span><span class="s1">) { 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
                            </span><span class="s2">if </span><span class="s1">( !(unmatched[i] || setMatched[i]) ) { 
                                setMatched[i] = pop.call( results )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
 
                    </span><span class="s0">// Discard index placeholder values to get only actual matches</span><span class="s1"> 
                    setMatched = condense( setMatched )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// Add matches to results</span><span class="s1"> 
                push.apply( results</span><span class="s3">, </span><span class="s1">setMatched )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Seedless set matches succeeding multiple successful matchers stipulate sorting</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; 
                    ( matchedCount + setMatchers.length ) &gt; </span><span class="s5">1 </span><span class="s1">) { 
 
                    Sizzle.uniqueSort( results )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// Override manipulation of globals by nested matchers</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( outermost ) { 
                dirruns = dirrunsUnique</span><span class="s3">;</span><span class="s1"> 
                outermostContext = contextBackup</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">unmatched</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">bySet ? 
        markFunction( superMatcher ) : 
        superMatcher</span><span class="s3">;</span><span class="s1"> 
} 
 
compile = Sizzle.compile = </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">match </span><span class="s0">/* Internal Use Only */ </span><span class="s1">) { 
    </span><span class="s2">var </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
        setMatchers = []</span><span class="s3">,</span><span class="s1"> 
        elementMatchers = []</span><span class="s3">,</span><span class="s1"> 
        cached = compilerCache[ selector + </span><span class="s4">&quot; &quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( !cached ) { 
        </span><span class="s0">// Generate a function of recursive functions that can be used to check each element</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !match ) { 
            match = tokenize( selector )</span><span class="s3">;</span><span class="s1"> 
        } 
        i = match.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( i-- ) { 
            cached = matcherFromTokens( match[i] )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( cached[ expando ] ) { 
                setMatchers.push( cached )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                elementMatchers.push( cached )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Cache the compiled function</span><span class="s1"> 
        cached = compilerCache( selector</span><span class="s3">, </span><span class="s1">matcherFromGroupMatchers( elementMatchers</span><span class="s3">, </span><span class="s1">setMatchers ) )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Save selector and tokenization</span><span class="s1"> 
        cached.selector = selector</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">cached</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * A low-level selection function that works with Sizzle's compiled 
 *  selector functions 
 * </span><span class="s7">@param </span><span class="s6">{String|Function} selector A selector or a pre-compiled 
 *  selector function built with Sizzle.compile 
 * </span><span class="s7">@param </span><span class="s6">{Element} context 
 * </span><span class="s7">@param </span><span class="s6">{Array} [results] 
 * </span><span class="s7">@param </span><span class="s6">{Array} [seed] A set of elements to match against 
 */</span><span class="s1"> 
select = Sizzle.select = </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">seed ) { 
    </span><span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">tokens</span><span class="s3">, </span><span class="s1">token</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">find</span><span class="s3">,</span><span class="s1"> 
        compiled = </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;function&quot; </span><span class="s1">&amp;&amp; selector</span><span class="s3">,</span><span class="s1"> 
        match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) )</span><span class="s3">;</span><span class="s1"> 
 
    results = results || []</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Try to minimize operations if there is no seed and only one group</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( match.length === </span><span class="s5">1 </span><span class="s1">) { 
 
        </span><span class="s0">// Take a shortcut and set the context if the root selector is an ID</span><span class="s1"> 
        tokens = match[</span><span class="s5">0</span><span class="s1">] = match[</span><span class="s5">0</span><span class="s1">].slice( </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( tokens.length &gt; </span><span class="s5">2 </span><span class="s1">&amp;&amp; (token = tokens[</span><span class="s5">0</span><span class="s1">]).type === </span><span class="s4">&quot;ID&quot; </span><span class="s1">&amp;&amp; 
                support.getById &amp;&amp; context.nodeType === </span><span class="s5">9 </span><span class="s1">&amp;&amp; documentIsHTML &amp;&amp; 
                Expr.relative[ tokens[</span><span class="s5">1</span><span class="s1">].type ] ) { 
 
            context = ( Expr.find[</span><span class="s4">&quot;ID&quot;</span><span class="s1">]( token.matches[</span><span class="s5">0</span><span class="s1">].replace(runescape</span><span class="s3">, </span><span class="s1">funescape)</span><span class="s3">, </span><span class="s1">context ) || [] )[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !context ) { 
                </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Precompiled matchers will still verify ancestry, so step up a level</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( compiled ) { 
                context = context.parentNode</span><span class="s3">;</span><span class="s1"> 
            } 
 
            selector = selector.slice( tokens.shift().value.length )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Fetch a seed set for right-to-left matching</span><span class="s1"> 
        i = matchExpr[</span><span class="s4">&quot;needsContext&quot;</span><span class="s1">].test( selector ) ? </span><span class="s5">0 </span><span class="s1">: tokens.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( i-- ) { 
            token = tokens[i]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Abort if we hit a combinator</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( Expr.relative[ (type = token.type) ] ) { 
                </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">if </span><span class="s1">( (find = Expr.find[ type ]) ) { 
                </span><span class="s0">// Search, expanding context for leading sibling combinators</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( (seed = find( 
                    token.matches[</span><span class="s5">0</span><span class="s1">].replace( runescape</span><span class="s3">, </span><span class="s1">funescape )</span><span class="s3">,</span><span class="s1"> 
                    rsibling.test( tokens[</span><span class="s5">0</span><span class="s1">].type ) &amp;&amp; testContext( context.parentNode ) || context 
                )) ) { 
 
                    </span><span class="s0">// If seed is empty or no tokens remain, we can return early</span><span class="s1"> 
                    tokens.splice( i</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    selector = seed.length &amp;&amp; toSelector( tokens )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !selector ) { 
                        push.apply( results</span><span class="s3">, </span><span class="s1">seed )</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    } 
 
    </span><span class="s0">// Compile and execute a filtering function if one is not provided</span><span class="s1"> 
    </span><span class="s0">// Provide `match` to avoid retokenization if we modified the selector above</span><span class="s1"> 
    ( compiled || compile( selector</span><span class="s3">, </span><span class="s1">match ) )( 
        seed</span><span class="s3">,</span><span class="s1"> 
        context</span><span class="s3">,</span><span class="s1"> 
        !documentIsHTML</span><span class="s3">,</span><span class="s1"> 
        results</span><span class="s3">,</span><span class="s1"> 
        rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context 
    )</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">results</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// One-time assignments</span><span class="s1"> 
 
</span><span class="s0">// Sort stability</span><span class="s1"> 
support.sortStable = expando.split(</span><span class="s4">&quot;&quot;</span><span class="s1">).sort( sortOrder ).join(</span><span class="s4">&quot;&quot;</span><span class="s1">) === expando</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Support: Chrome 14-35+</span><span class="s1"> 
</span><span class="s0">// Always assume duplicates if they aren't passed to the comparison function</span><span class="s1"> 
support.detectDuplicates = !!hasDuplicate</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Initialize against the default document</span><span class="s1"> 
setDocument()</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)</span><span class="s1"> 
</span><span class="s0">// Detached nodes confoundingly follow *each other*</span><span class="s1"> 
support.sortDetached = assert(</span><span class="s2">function</span><span class="s1">( div1 ) { 
    </span><span class="s0">// Should return 1, but returns 4 (following)</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">div1.compareDocumentPosition( document.createElement(</span><span class="s4">&quot;div&quot;</span><span class="s1">) ) &amp; </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
</span><span class="s0">// Prevent attribute/property &quot;interpolation&quot;</span><span class="s1"> 
</span><span class="s0">// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !assert(</span><span class="s2">function</span><span class="s1">( div ) { 
    div.innerHTML = </span><span class="s4">&quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">div.firstChild.getAttribute(</span><span class="s4">&quot;href&quot;</span><span class="s1">) === </span><span class="s4">&quot;#&quot; </span><span class="s3">;</span><span class="s1"> 
}) ) { 
    addHandle( </span><span class="s4">&quot;type|href|height|width&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
        </span><span class="s2">if </span><span class="s1">( !isXML ) { 
            </span><span class="s2">return </span><span class="s1">elem.getAttribute( name</span><span class="s3">, </span><span class="s1">name.toLowerCase() === </span><span class="s4">&quot;type&quot; </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">2 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
</span><span class="s0">// Use defaultValue in place of getAttribute(&quot;value&quot;)</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.attributes || !assert(</span><span class="s2">function</span><span class="s1">( div ) { 
    div.innerHTML = </span><span class="s4">&quot;&lt;input/&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
    div.firstChild.setAttribute( </span><span class="s4">&quot;value&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">div.firstChild.getAttribute( </span><span class="s4">&quot;value&quot; </span><span class="s1">) === </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
}) ) { 
    addHandle( </span><span class="s4">&quot;value&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
        </span><span class="s2">if </span><span class="s1">( !isXML &amp;&amp; elem.nodeName.toLowerCase() === </span><span class="s4">&quot;input&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">elem.defaultValue</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
</span><span class="s0">// Use getAttributeNode to fetch booleans when getAttribute lies</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !assert(</span><span class="s2">function</span><span class="s1">( div ) { 
    </span><span class="s2">return </span><span class="s1">div.getAttribute(</span><span class="s4">&quot;disabled&quot;</span><span class="s1">) == </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
}) ) { 
    addHandle( booleans</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
        </span><span class="s2">var </span><span class="s1">val</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !isXML ) { 
            </span><span class="s2">return </span><span class="s1">elem[ name ] === </span><span class="s2">true </span><span class="s1">? name.toLowerCase() : 
                    (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ? 
                    val.value : 
                </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">return </span><span class="s1">Sizzle</span><span class="s3">;</span><span class="s1"> 
 
})( window )</span><span class="s3">;</span><span class="s1"> 
 
 
 
jQuery.find = Sizzle</span><span class="s3">;</span><span class="s1"> 
jQuery.expr = Sizzle.selectors</span><span class="s3">;</span><span class="s1"> 
jQuery.expr[</span><span class="s4">&quot;:&quot;</span><span class="s1">] = jQuery.expr.pseudos</span><span class="s3">;</span><span class="s1"> 
jQuery.unique = Sizzle.uniqueSort</span><span class="s3">;</span><span class="s1"> 
jQuery.text = Sizzle.getText</span><span class="s3">;</span><span class="s1"> 
jQuery.isXMLDoc = Sizzle.isXML</span><span class="s3">;</span><span class="s1"> 
jQuery.contains = Sizzle.contains</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s2">var </span><span class="s1">rneedsContext = jQuery.expr.match.needsContext</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">rsingleTag = (</span><span class="s4">/^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s2">var </span><span class="s1">risSimple = </span><span class="s4">/^.[^:#\[\.,]*$/</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Implement the identical functionality for filter and not</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">winnow( elements</span><span class="s3">, </span><span class="s1">qualifier</span><span class="s3">, </span><span class="s1">not ) { 
    </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( qualifier ) ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.grep( elements</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">i ) { 
            </span><span class="s0">/* jshint -W018 */</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">!!qualifier.call( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">elem ) !== not</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
    } 
 
    </span><span class="s2">if </span><span class="s1">( qualifier.nodeType ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.grep( elements</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">( elem === qualifier ) !== not</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
    } 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">qualifier === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
        </span><span class="s2">if </span><span class="s1">( risSimple.test( qualifier ) ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.filter( qualifier</span><span class="s3">, </span><span class="s1">elements</span><span class="s3">, </span><span class="s1">not )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        qualifier = jQuery.filter( qualifier</span><span class="s3">, </span><span class="s1">elements )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">jQuery.grep( elements</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">( jQuery.inArray( elem</span><span class="s3">, </span><span class="s1">qualifier ) &gt;= </span><span class="s5">0 </span><span class="s1">) !== not</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.filter = </span><span class="s2">function</span><span class="s1">( expr</span><span class="s3">, </span><span class="s1">elems</span><span class="s3">, </span><span class="s1">not ) { 
    </span><span class="s2">var </span><span class="s1">elem = elems[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( not ) { 
        expr = </span><span class="s4">&quot;:not(&quot; </span><span class="s1">+ expr + </span><span class="s4">&quot;)&quot;</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">elems.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp; elem.nodeType === </span><span class="s5">1 </span><span class="s1">? 
        jQuery.find.matchesSelector( elem</span><span class="s3">, </span><span class="s1">expr ) ? [ elem ] : [] : 
        jQuery.find.matches( expr</span><span class="s3">, </span><span class="s1">jQuery.grep( elems</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem.nodeType === </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
        }))</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    find: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">var </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
            ret = []</span><span class="s3">,</span><span class="s1"> 
            self = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
            len = self.length</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( jQuery( selector ).filter(</span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                    </span><span class="s2">if </span><span class="s1">( jQuery.contains( self[ i ]</span><span class="s3">, </span><span class="s2">this </span><span class="s1">) ) { 
                        </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            }) )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
            jQuery.find( selector</span><span class="s3">, </span><span class="s1">self[ i ]</span><span class="s3">, </span><span class="s1">ret )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Needed because $( selector, context ) becomes $( context ).find( selector )</span><span class="s1"> 
        ret = </span><span class="s2">this</span><span class="s1">.pushStack( len &gt; </span><span class="s5">1 </span><span class="s1">? jQuery.unique( ret ) : ret )</span><span class="s3">;</span><span class="s1"> 
        ret.selector = </span><span class="s2">this</span><span class="s1">.selector ? </span><span class="s2">this</span><span class="s1">.selector + </span><span class="s4">&quot; &quot; </span><span class="s1">+ selector : selector</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    filter: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">return this</span><span class="s1">.pushStack( winnow(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">selector || []</span><span class="s3">, </span><span class="s2">false</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    not: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">return this</span><span class="s1">.pushStack( winnow(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">selector || []</span><span class="s3">, </span><span class="s2">true</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    is: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">return </span><span class="s1">!!winnow( 
            </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// If this is a positional/relative selector, check membership in the returned set</span><span class="s1"> 
            </span><span class="s0">// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won't return true for a doc with two &quot;p&quot;.</span><span class="s1"> 
            </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; rneedsContext.test( selector ) ? 
                jQuery( selector ) : 
                selector || []</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s2">false</span><span class="s1"> 
        ).length</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Initialize a jQuery object</span><span class="s1"> 
 
 
</span><span class="s0">// A central reference to the root jQuery(document)</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">rootjQuery</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Use the correct document accordingly with window argument (sandbox)</span><span class="s1"> 
    document = window.document</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// A simple way to check for HTML strings</span><span class="s1"> 
    </span><span class="s0">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span><span class="s1"> 
    </span><span class="s0">// Strict HTML recognition (#11290: must start with &lt;)</span><span class="s1"> 
    rquickExpr = </span><span class="s4">/^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/</span><span class="s3">,</span><span class="s1"> 
 
    init = jQuery.fn.init = </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s2">var </span><span class="s1">match</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !selector ) { 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Handle HTML strings</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">( selector.charAt(</span><span class="s5">0</span><span class="s1">) === </span><span class="s4">&quot;&lt;&quot; </span><span class="s1">&amp;&amp; selector.charAt( selector.length - </span><span class="s5">1 </span><span class="s1">) === </span><span class="s4">&quot;&gt;&quot; </span><span class="s1">&amp;&amp; selector.length &gt;= </span><span class="s5">3 </span><span class="s1">) { 
                </span><span class="s0">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span><span class="s1"> 
                match = [ </span><span class="s2">null</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s2">null </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                match = rquickExpr.exec( selector )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Match html or make sure no context is specified for #id</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( match &amp;&amp; (match[</span><span class="s5">1</span><span class="s1">] || !context) ) { 
 
                </span><span class="s0">// HANDLE: $(html) -&gt; $(array)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( match[</span><span class="s5">1</span><span class="s1">] ) { 
                    context = context </span><span class="s2">instanceof </span><span class="s1">jQuery ? context[</span><span class="s5">0</span><span class="s1">] : context</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// scripts is true for back-compat</span><span class="s1"> 
                    </span><span class="s0">// Intentionally let the error be thrown if parseHTML is not present</span><span class="s1"> 
                    jQuery.merge( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">jQuery.parseHTML( 
                        match[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                        context &amp;&amp; context.nodeType ? context.ownerDocument || context : document</span><span class="s3">,</span><span class="s1"> 
                        </span><span class="s2">true</span><span class="s1"> 
                    ) )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// HANDLE: $(html, props)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( rsingleTag.test( match[</span><span class="s5">1</span><span class="s1">] ) &amp;&amp; jQuery.isPlainObject( context ) ) { 
                        </span><span class="s2">for </span><span class="s1">( match </span><span class="s2">in </span><span class="s1">context ) { 
                            </span><span class="s0">// Properties of context are called as methods if possible</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( </span><span class="s2">this</span><span class="s1">[ match ] ) ) { 
                                </span><span class="s2">this</span><span class="s1">[ match ]( context[ match ] )</span><span class="s3">;</span><span class="s1"> 
 
                            </span><span class="s0">// ...and otherwise set as attributes</span><span class="s1"> 
                            } </span><span class="s2">else </span><span class="s1">{ 
                                </span><span class="s2">this</span><span class="s1">.attr( match</span><span class="s3">, </span><span class="s1">context[ match ] )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// HANDLE: $(#id)</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    elem = document.getElementById( match[</span><span class="s5">2</span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Check parentNode to catch when Blackberry 4.6 returns</span><span class="s1"> 
                    </span><span class="s0">// nodes that are no longer in the document #6963</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( elem &amp;&amp; elem.parentNode ) { 
                        </span><span class="s0">// Handle the case where IE and Opera return items</span><span class="s1"> 
                        </span><span class="s0">// by name instead of ID</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.id !== match[</span><span class="s5">2</span><span class="s1">] ) { 
                            </span><span class="s2">return </span><span class="s1">rootjQuery.find( selector )</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        </span><span class="s0">// Otherwise, we inject the element directly into the jQuery object</span><span class="s1"> 
                        </span><span class="s2">this</span><span class="s1">.length = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] = elem</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s2">this</span><span class="s1">.context = document</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">this</span><span class="s1">.selector = selector</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                } 
 
            </span><span class="s0">// HANDLE: $(expr, $(...))</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( !context || context.jquery ) { 
                </span><span class="s2">return </span><span class="s1">( context || rootjQuery ).find( selector )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// HANDLE: $(expr, context)</span><span class="s1"> 
            </span><span class="s0">// (which is just equivalent to: $(context).find(expr)</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">return this</span><span class="s1">.constructor( context ).find( selector )</span><span class="s3">;</span><span class="s1"> 
            } 
 
        </span><span class="s0">// HANDLE: $(DOMElement)</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( selector.nodeType ) { 
            </span><span class="s2">this</span><span class="s1">.context = </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] = selector</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.length = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// HANDLE: $(function)</span><span class="s1"> 
        </span><span class="s0">// Shortcut for document ready</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( jQuery.isFunction( selector ) ) { 
            </span><span class="s2">return typeof </span><span class="s1">rootjQuery.ready !== </span><span class="s4">&quot;undefined&quot; </span><span class="s1">? 
                rootjQuery.ready( selector ) : 
                </span><span class="s0">// Execute immediately if ready is not present</span><span class="s1"> 
                selector( jQuery )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( selector.selector !== undefined ) { 
            </span><span class="s2">this</span><span class="s1">.selector = selector.selector</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.context = selector.context</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">jQuery.makeArray( selector</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Give the init function the jQuery prototype for later instantiation</span><span class="s1"> 
init.prototype = jQuery.fn</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Initialize central reference</span><span class="s1"> 
rootjQuery = jQuery( document )</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">rparentsprev = </span><span class="s4">/^(?:parents|prev(?:Until|All))/</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// methods guaranteed to produce a unique set when starting from a unique set</span><span class="s1"> 
    guaranteedUnique = { 
        children: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        contents: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        next: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        prev: </span><span class="s2">true</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    dir: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">dir</span><span class="s3">, </span><span class="s1">until ) { 
        </span><span class="s2">var </span><span class="s1">matched = []</span><span class="s3">,</span><span class="s1"> 
            cur = elem[ dir ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">while </span><span class="s1">( cur &amp;&amp; cur.nodeType !== </span><span class="s5">9 </span><span class="s1">&amp;&amp; (until === undefined || cur.nodeType !== </span><span class="s5">1 </span><span class="s1">|| !jQuery( cur ).is( until )) ) { 
            </span><span class="s2">if </span><span class="s1">( cur.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                matched.push( cur )</span><span class="s3">;</span><span class="s1"> 
            } 
            cur = cur[dir]</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return </span><span class="s1">matched</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    sibling: </span><span class="s2">function</span><span class="s1">( n</span><span class="s3">, </span><span class="s1">elem ) { 
        </span><span class="s2">var </span><span class="s1">r = []</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">n</span><span class="s3">; </span><span class="s1">n = n.nextSibling ) { 
            </span><span class="s2">if </span><span class="s1">( n.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; n !== elem ) { 
                r.push( n )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">r</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    has: </span><span class="s2">function</span><span class="s1">( target ) { 
        </span><span class="s2">var </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
            targets = jQuery( target</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            len = targets.length</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return this</span><span class="s1">.filter(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.contains( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">targets[i] ) ) { 
                    </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    closest: </span><span class="s2">function</span><span class="s1">( selectors</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s2">var </span><span class="s1">cur</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            matched = []</span><span class="s3">,</span><span class="s1"> 
            pos = rneedsContext.test( selectors ) || </span><span class="s2">typeof </span><span class="s1">selectors !== </span><span class="s4">&quot;string&quot; </span><span class="s1">? 
                jQuery( selectors</span><span class="s3">, </span><span class="s1">context || </span><span class="s2">this</span><span class="s1">.context ) : 
                </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s2">for </span><span class="s1">( cur = </span><span class="s2">this</span><span class="s1">[i]</span><span class="s3">; </span><span class="s1">cur &amp;&amp; cur !== context</span><span class="s3">; </span><span class="s1">cur = cur.parentNode ) { 
                </span><span class="s0">// Always skip document fragments</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( cur.nodeType &lt; </span><span class="s5">11 </span><span class="s1">&amp;&amp; (pos ? 
                    pos.index(cur) &gt; -</span><span class="s5">1 </span><span class="s1">: 
 
                    </span><span class="s0">// Don't pass non-elements to Sizzle</span><span class="s1"> 
                    cur.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; 
                        jQuery.find.matchesSelector(cur</span><span class="s3">, </span><span class="s1">selectors)) ) { 
 
                    matched.push( cur )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.pushStack( matched.length &gt; </span><span class="s5">1 </span><span class="s1">? jQuery.unique( matched ) : matched )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Determine the position of an element within</span><span class="s1"> 
    </span><span class="s0">// the matched set of elements</span><span class="s1"> 
    index: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
        </span><span class="s0">// No argument, return index in parent</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem ) { 
            </span><span class="s2">return </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] &amp;&amp; </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">].parentNode ) ? </span><span class="s2">this</span><span class="s1">.first().prevAll().length : -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// index in selector</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">jQuery.inArray( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">jQuery( elem ) )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Locate the position of the desired element</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">jQuery.inArray( 
            </span><span class="s0">// If it receives a jQuery object, the first element is used</span><span class="s1"> 
            elem.jquery ? elem[</span><span class="s5">0</span><span class="s1">] : elem</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    add: </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">context ) { 
        </span><span class="s2">return this</span><span class="s1">.pushStack( 
            jQuery.unique( 
                jQuery.merge( </span><span class="s2">this</span><span class="s1">.get()</span><span class="s3">, </span><span class="s1">jQuery( selector</span><span class="s3">, </span><span class="s1">context ) ) 
            ) 
        )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    addBack: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">return this</span><span class="s1">.add( selector == </span><span class="s2">null </span><span class="s1">? 
            </span><span class="s2">this</span><span class="s1">.prevObject : </span><span class="s2">this</span><span class="s1">.prevObject.filter(selector) 
        )</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">sibling( cur</span><span class="s3">, </span><span class="s1">dir ) { 
    </span><span class="s2">do </span><span class="s1">{ 
        cur = cur[ dir ]</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">while </span><span class="s1">( cur &amp;&amp; cur.nodeType !== </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">cur</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.each({ 
    parent: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">var </span><span class="s1">parent = elem.parentNode</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">parent &amp;&amp; parent.nodeType !== </span><span class="s5">11 </span><span class="s1">? parent : </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    parents: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;parentNode&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    parentsUntil: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">until ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;parentNode&quot;</span><span class="s3">, </span><span class="s1">until )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    next: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">sibling( elem</span><span class="s3">, </span><span class="s4">&quot;nextSibling&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    prev: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">sibling( elem</span><span class="s3">, </span><span class="s4">&quot;previousSibling&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    nextAll: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;nextSibling&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    prevAll: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;previousSibling&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    nextUntil: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">until ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;nextSibling&quot;</span><span class="s3">, </span><span class="s1">until )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    prevUntil: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">until ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.dir( elem</span><span class="s3">, </span><span class="s4">&quot;previousSibling&quot;</span><span class="s3">, </span><span class="s1">until )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    siblings: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.sibling( ( elem.parentNode || {} ).firstChild</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    children: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.sibling( elem.firstChild )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    contents: </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;iframe&quot; </span><span class="s1">) ? 
            elem.contentDocument || elem.contentWindow.document : 
            jQuery.merge( []</span><span class="s3">, </span><span class="s1">elem.childNodes )</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">fn ) { 
    jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( until</span><span class="s3">, </span><span class="s1">selector ) { 
        </span><span class="s2">var </span><span class="s1">ret = jQuery.map( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">until )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( name.slice( -</span><span class="s5">5 </span><span class="s1">) !== </span><span class="s4">&quot;Until&quot; </span><span class="s1">) { 
            selector = until</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( selector &amp;&amp; </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            ret = jQuery.filter( selector</span><span class="s3">, </span><span class="s1">ret )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.length &gt; </span><span class="s5">1 </span><span class="s1">) { 
            </span><span class="s0">// Remove duplicates</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !guaranteedUnique[ name ] ) { 
                ret = jQuery.unique( ret )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Reverse order for parents* and prev-derivatives</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rparentsprev.test( name ) ) { 
                ret = ret.reverse()</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.pushStack( ret )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">rnotwhite = (</span><span class="s4">/\S+/g</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s0">// String to Object options format cache</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">optionsCache = {}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Convert String-formatted options into Object-formatted ones and store in cache</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createOptions( options ) { 
    </span><span class="s2">var </span><span class="s1">object = optionsCache[ options ] = {}</span><span class="s3">;</span><span class="s1"> 
    jQuery.each( options.match( rnotwhite ) || []</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">flag ) { 
        object[ flag ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">object</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">/* 
 * Create a callback list using the following parameters: 
 * 
 *  options: an optional list of space-separated options that will change how 
 *          the callback list behaves or a more traditional option object 
 * 
 * By default a callback list will act like an event callback list and can be 
 * &quot;fired&quot; multiple times. 
 * 
 * Possible options: 
 * 
 *  once:           will ensure the callback list can only be fired once (like a Deferred) 
 * 
 *  memory:         will keep track of previous values and will call any callback added 
 *                  after the list has been fired right away with the latest &quot;memorized&quot; 
 *                  values (like a Deferred) 
 * 
 *  unique:         will ensure a callback can only be added once (no duplicate in the list) 
 * 
 *  stopOnFalse:    interrupt callings when a callback returns false 
 * 
 */</span><span class="s1"> 
jQuery.Callbacks = </span><span class="s2">function</span><span class="s1">( options ) { 
 
    </span><span class="s0">// Convert options from String-formatted to Object-formatted if needed</span><span class="s1"> 
    </span><span class="s0">// (we check in cache first)</span><span class="s1"> 
    options = </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s4">&quot;string&quot; </span><span class="s1">? 
        ( optionsCache[ options ] || createOptions( options ) ) : 
        jQuery.extend( {}</span><span class="s3">, </span><span class="s1">options )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">var </span><span class="s0">// Flag to know if list is currently firing</span><span class="s1"> 
        firing</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Last fire value (for non-forgettable lists)</span><span class="s1"> 
        memory</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Flag to know if list was already fired</span><span class="s1"> 
        fired</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// End of the loop when firing</span><span class="s1"> 
        firingLength</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Index of currently firing callback (modified by remove if needed)</span><span class="s1"> 
        firingIndex</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// First callback to fire (used internally by add and fireWith)</span><span class="s1"> 
        firingStart</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Actual callback list</span><span class="s1"> 
        list = []</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Stack of fire calls for repeatable lists</span><span class="s1"> 
        stack = !options.once &amp;&amp; []</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Fire callbacks</span><span class="s1"> 
        fire = </span><span class="s2">function</span><span class="s1">( data ) { 
            memory = options.memory &amp;&amp; data</span><span class="s3">;</span><span class="s1"> 
            fired = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
            firingIndex = firingStart || </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            firingStart = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            firingLength = list.length</span><span class="s3">;</span><span class="s1"> 
            firing = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">list &amp;&amp; firingIndex &lt; firingLength</span><span class="s3">; </span><span class="s1">firingIndex++ ) { 
                </span><span class="s2">if </span><span class="s1">( list[ firingIndex ].apply( data[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">, </span><span class="s1">data[ </span><span class="s5">1 </span><span class="s1">] ) === </span><span class="s2">false </span><span class="s1">&amp;&amp; options.stopOnFalse ) { 
                    memory = </span><span class="s2">false</span><span class="s3">; </span><span class="s0">// To prevent further calls using add</span><span class="s1"> 
                    </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            firing = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( list ) { 
                </span><span class="s2">if </span><span class="s1">( stack ) { 
                    </span><span class="s2">if </span><span class="s1">( stack.length ) { 
                        fire( stack.shift() )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } </span><span class="s2">else if </span><span class="s1">( memory ) { 
                    list = []</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    self.disable()</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Actual Callbacks object</span><span class="s1"> 
        self = { 
            </span><span class="s0">// Add a callback or a collection of callbacks to the list</span><span class="s1"> 
            add: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( list ) { 
                    </span><span class="s0">// First, we save the current length</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">start = list.length</span><span class="s3">;</span><span class="s1"> 
                    (</span><span class="s2">function </span><span class="s1">add( args ) { 
                        jQuery.each( args</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">arg ) { 
                            </span><span class="s2">var </span><span class="s1">type = jQuery.type( arg )</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;function&quot; </span><span class="s1">) { 
                                </span><span class="s2">if </span><span class="s1">( !options.unique || !self.has( arg ) ) { 
                                    list.push( arg )</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } </span><span class="s2">else if </span><span class="s1">( arg &amp;&amp; arg.length &amp;&amp; type !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
                                </span><span class="s0">// Inspect recursively</span><span class="s1"> 
                                add( arg )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        })</span><span class="s3">;</span><span class="s1"> 
                    })( arguments )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s0">// Do we need to add the callbacks to the</span><span class="s1"> 
                    </span><span class="s0">// current firing batch?</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( firing ) { 
                        firingLength = list.length</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s0">// With memory, if we're not firing then</span><span class="s1"> 
                    </span><span class="s0">// we should call right away</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( memory ) { 
                        firingStart = start</span><span class="s3">;</span><span class="s1"> 
                        fire( memory )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Remove a callback from the list</span><span class="s1"> 
            remove: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( list ) { 
                    jQuery.each( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">arg ) { 
                        </span><span class="s2">var </span><span class="s1">index</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( ( index = jQuery.inArray( arg</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">index ) ) &gt; -</span><span class="s5">1 </span><span class="s1">) { 
                            list.splice( index</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s0">// Handle firing indexes</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( firing ) { 
                                </span><span class="s2">if </span><span class="s1">( index &lt;= firingLength ) { 
                                    firingLength--</span><span class="s3">;</span><span class="s1"> 
                                } 
                                </span><span class="s2">if </span><span class="s1">( index &lt;= firingIndex ) { 
                                    firingIndex--</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } 
                        } 
                    })</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Check if a given callback is in the list.</span><span class="s1"> 
            </span><span class="s0">// If no argument is given, return whether or not list has callbacks attached.</span><span class="s1"> 
            has: </span><span class="s2">function</span><span class="s1">( fn ) { 
                </span><span class="s2">return </span><span class="s1">fn ? jQuery.inArray( fn</span><span class="s3">, </span><span class="s1">list ) &gt; -</span><span class="s5">1 </span><span class="s1">: !!( list &amp;&amp; list.length )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Remove all callbacks from the list</span><span class="s1"> 
            empty: </span><span class="s2">function</span><span class="s1">() { 
                list = []</span><span class="s3">;</span><span class="s1"> 
                firingLength = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Have the list do nothing anymore</span><span class="s1"> 
            disable: </span><span class="s2">function</span><span class="s1">() { 
                list = stack = memory = undefined</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Is it disabled?</span><span class="s1"> 
            disabled: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">return </span><span class="s1">!list</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Lock the list in its current state</span><span class="s1"> 
            lock: </span><span class="s2">function</span><span class="s1">() { 
                stack = undefined</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !memory ) { 
                    self.disable()</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Is it locked?</span><span class="s1"> 
            locked: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">return </span><span class="s1">!stack</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Call all callbacks with the given context and arguments</span><span class="s1"> 
            fireWith: </span><span class="s2">function</span><span class="s1">( context</span><span class="s3">, </span><span class="s1">args ) { 
                </span><span class="s2">if </span><span class="s1">( list &amp;&amp; ( !fired || stack ) ) { 
                    args = args || []</span><span class="s3">;</span><span class="s1"> 
                    args = [ context</span><span class="s3">, </span><span class="s1">args.slice ? args.slice() : args ]</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( firing ) { 
                        stack.push( args )</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        fire( args )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Call all the callbacks with the given arguments</span><span class="s1"> 
            fire: </span><span class="s2">function</span><span class="s1">() { 
                self.fireWith( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// To know if the callbacks have already been called at least once</span><span class="s1"> 
            fired: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">return </span><span class="s1">!!fired</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">self</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
jQuery.extend({ 
 
    Deferred: </span><span class="s2">function</span><span class="s1">( func ) { 
        </span><span class="s2">var </span><span class="s1">tuples = [ 
                </span><span class="s0">// action, add listener, listener list, final state</span><span class="s1"> 
                [ </span><span class="s4">&quot;resolve&quot;</span><span class="s3">, </span><span class="s4">&quot;done&quot;</span><span class="s3">, </span><span class="s1">jQuery.Callbacks(</span><span class="s4">&quot;once memory&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;resolved&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                [ </span><span class="s4">&quot;reject&quot;</span><span class="s3">, </span><span class="s4">&quot;fail&quot;</span><span class="s3">, </span><span class="s1">jQuery.Callbacks(</span><span class="s4">&quot;once memory&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s4">&quot;rejected&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                [ </span><span class="s4">&quot;notify&quot;</span><span class="s3">, </span><span class="s4">&quot;progress&quot;</span><span class="s3">, </span><span class="s1">jQuery.Callbacks(</span><span class="s4">&quot;memory&quot;</span><span class="s1">) ] 
            ]</span><span class="s3">,</span><span class="s1"> 
            state = </span><span class="s4">&quot;pending&quot;</span><span class="s3">,</span><span class="s1"> 
            promise = { 
                state: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">state</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
                always: </span><span class="s2">function</span><span class="s1">() { 
                    deferred.done( arguments ).fail( arguments )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
                then: </span><span class="s2">function</span><span class="s1">( </span><span class="s0">/* fnDone, fnFail, fnProgress */ </span><span class="s1">) { 
                    </span><span class="s2">var </span><span class="s1">fns = arguments</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">jQuery.Deferred(</span><span class="s2">function</span><span class="s1">( newDefer ) { 
                        jQuery.each( tuples</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">tuple ) { 
                            </span><span class="s2">var </span><span class="s1">fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ]</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s0">// deferred[ done | fail | progress ] for forwarding actions to newDefer</span><span class="s1"> 
                            deferred[ tuple[</span><span class="s5">1</span><span class="s1">] ](</span><span class="s2">function</span><span class="s1">() { 
                                </span><span class="s2">var </span><span class="s1">returned = fn &amp;&amp; fn.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) { 
                                    returned.promise() 
                                        .done( newDefer.resolve ) 
                                        .fail( newDefer.reject ) 
                                        .progress( newDefer.notify )</span><span class="s3">;</span><span class="s1"> 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    newDefer[ tuple[ </span><span class="s5">0 </span><span class="s1">] + </span><span class="s4">&quot;With&quot; </span><span class="s1">]( </span><span class="s2">this </span><span class="s1">=== promise ? newDefer.promise() : </span><span class="s2">this</span><span class="s3">, </span><span class="s1">fn ? [ returned ] : arguments )</span><span class="s3">;</span><span class="s1"> 
                                } 
                            })</span><span class="s3">;</span><span class="s1"> 
                        })</span><span class="s3">;</span><span class="s1"> 
                        fns = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                    }).promise()</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// Get a promise for this deferred</span><span class="s1"> 
                </span><span class="s0">// If obj is provided, the promise aspect is added to the object</span><span class="s1"> 
                promise: </span><span class="s2">function</span><span class="s1">( obj ) { 
                    </span><span class="s2">return </span><span class="s1">obj != </span><span class="s2">null </span><span class="s1">? jQuery.extend( obj</span><span class="s3">, </span><span class="s1">promise ) : promise</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">,</span><span class="s1"> 
            deferred = {}</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Keep pipe for back-compat</span><span class="s1"> 
        promise.pipe = promise.then</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Add list-specific methods</span><span class="s1"> 
        jQuery.each( tuples</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">tuple ) { 
            </span><span class="s2">var </span><span class="s1">list = tuple[ </span><span class="s5">2 </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                stateString = tuple[ </span><span class="s5">3 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// promise[ done | fail | progress ] = list.add</span><span class="s1"> 
            promise[ tuple[</span><span class="s5">1</span><span class="s1">] ] = list.add</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Handle state</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( stateString ) { 
                list.add(</span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s0">// state = [ resolved | rejected ]</span><span class="s1"> 
                    state = stateString</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// [ reject_list | resolve_list ].disable; progress_list.lock</span><span class="s1"> 
                }</span><span class="s3">, </span><span class="s1">tuples[ i ^ </span><span class="s5">1 </span><span class="s1">][ </span><span class="s5">2 </span><span class="s1">].disable</span><span class="s3">, </span><span class="s1">tuples[ </span><span class="s5">2 </span><span class="s1">][ </span><span class="s5">2 </span><span class="s1">].lock )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// deferred[ resolve | reject | notify ]</span><span class="s1"> 
            deferred[ tuple[</span><span class="s5">0</span><span class="s1">] ] = </span><span class="s2">function</span><span class="s1">() { 
                deferred[ tuple[</span><span class="s5">0</span><span class="s1">] + </span><span class="s4">&quot;With&quot; </span><span class="s1">]( </span><span class="s2">this </span><span class="s1">=== deferred ? promise : </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
            deferred[ tuple[</span><span class="s5">0</span><span class="s1">] + </span><span class="s4">&quot;With&quot; </span><span class="s1">] = list.fireWith</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Make the deferred a promise</span><span class="s1"> 
        promise.promise( deferred )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Call given func if any</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( func ) { 
            func.call( deferred</span><span class="s3">, </span><span class="s1">deferred )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// All done!</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">deferred</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Deferred helper</span><span class="s1"> 
    when: </span><span class="s2">function</span><span class="s1">( subordinate </span><span class="s0">/* , ..., subordinateN */ </span><span class="s1">) { 
        </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            resolveValues = slice.call( arguments )</span><span class="s3">,</span><span class="s1"> 
            length = resolveValues.length</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// the count of uncompleted subordinates</span><span class="s1"> 
            remaining = length !== </span><span class="s5">1 </span><span class="s1">|| ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// the master Deferred. If resolveValues consist of only a single Deferred, just use that.</span><span class="s1"> 
            deferred = remaining === </span><span class="s5">1 </span><span class="s1">? subordinate : jQuery.Deferred()</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Update function for both resolve and progress values</span><span class="s1"> 
            updateFunc = </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">contexts</span><span class="s3">, </span><span class="s1">values ) { 
                </span><span class="s2">return function</span><span class="s1">( value ) { 
                    contexts[ i ] = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
                    values[ i ] = arguments.length &gt; </span><span class="s5">1 </span><span class="s1">? slice.call( arguments ) : value</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( values === progressValues ) { 
                        deferred.notifyWith( contexts</span><span class="s3">, </span><span class="s1">values )</span><span class="s3">;</span><span class="s1"> 
 
                    } </span><span class="s2">else if </span><span class="s1">( !(--remaining) ) { 
                        deferred.resolveWith( contexts</span><span class="s3">, </span><span class="s1">values )</span><span class="s3">;</span><span class="s1"> 
                    } 
                }</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
 
            progressValues</span><span class="s3">, </span><span class="s1">progressContexts</span><span class="s3">, </span><span class="s1">resolveContexts</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// add listeners to Deferred subordinates; treat others as resolved</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( length &gt; </span><span class="s5">1 </span><span class="s1">) { 
            progressValues = </span><span class="s2">new </span><span class="s1">Array( length )</span><span class="s3">;</span><span class="s1"> 
            progressContexts = </span><span class="s2">new </span><span class="s1">Array( length )</span><span class="s3">;</span><span class="s1"> 
            resolveContexts = </span><span class="s2">new </span><span class="s1">Array( length )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
                </span><span class="s2">if </span><span class="s1">( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) { 
                    resolveValues[ i ].promise() 
                        .done( updateFunc( i</span><span class="s3">, </span><span class="s1">resolveContexts</span><span class="s3">, </span><span class="s1">resolveValues ) ) 
                        .fail( deferred.reject ) 
                        .progress( updateFunc( i</span><span class="s3">, </span><span class="s1">progressContexts</span><span class="s3">, </span><span class="s1">progressValues ) )</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    --remaining</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s0">// if we're not waiting on anything, resolve the master</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !remaining ) { 
            deferred.resolveWith( resolveContexts</span><span class="s3">, </span><span class="s1">resolveValues )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">deferred.promise()</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// The deferred used on DOM ready</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">readyList</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.ready = </span><span class="s2">function</span><span class="s1">( fn ) { 
    </span><span class="s0">// Add the callback</span><span class="s1"> 
    jQuery.ready.promise().done( fn )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    </span><span class="s0">// Is the DOM ready to be used? Set to true once it occurs.</span><span class="s1"> 
    isReady: </span><span class="s2">false</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// A counter to track how many items to wait for before</span><span class="s1"> 
    </span><span class="s0">// the ready event fires. See #6781</span><span class="s1"> 
    readyWait: </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Hold (or release) the ready event</span><span class="s1"> 
    holdReady: </span><span class="s2">function</span><span class="s1">( hold ) { 
        </span><span class="s2">if </span><span class="s1">( hold ) { 
            jQuery.readyWait++</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            jQuery.ready( </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Handle when the DOM is ready</span><span class="s1"> 
    ready: </span><span class="s2">function</span><span class="s1">( wait ) { 
 
        </span><span class="s0">// Abort if there are pending holds or we're already ready</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( wait === </span><span class="s2">true </span><span class="s1">? --jQuery.readyWait : jQuery.isReady ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !document.body ) { 
            </span><span class="s2">return </span><span class="s1">setTimeout( jQuery.ready )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Remember that the DOM is ready</span><span class="s1"> 
        jQuery.isReady = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If a normal DOM Ready event fired, decrement, and wait if need be</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( wait !== </span><span class="s2">true </span><span class="s1">&amp;&amp; --jQuery.readyWait &gt; </span><span class="s5">0 </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// If there are functions bound, to execute</span><span class="s1"> 
        readyList.resolveWith( document</span><span class="s3">, </span><span class="s1">[ jQuery ] )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Trigger any bound ready events</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.fn.triggerHandler ) { 
            jQuery( document ).triggerHandler( </span><span class="s4">&quot;ready&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            jQuery( document ).off( </span><span class="s4">&quot;ready&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Clean-up method for dom ready events 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">detach() { 
    </span><span class="s2">if </span><span class="s1">( document.addEventListener ) { 
        document.removeEventListener( </span><span class="s4">&quot;DOMContentLoaded&quot;</span><span class="s3">, </span><span class="s1">completed</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        window.removeEventListener( </span><span class="s4">&quot;load&quot;</span><span class="s3">, </span><span class="s1">completed</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    } </span><span class="s2">else </span><span class="s1">{ 
        document.detachEvent( </span><span class="s4">&quot;onreadystatechange&quot;</span><span class="s3">, </span><span class="s1">completed )</span><span class="s3">;</span><span class="s1"> 
        window.detachEvent( </span><span class="s4">&quot;onload&quot;</span><span class="s3">, </span><span class="s1">completed )</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s6">/** 
 * The ready event handler and self cleanup method 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">completed() { 
    </span><span class="s0">// readyState === &quot;complete&quot; is good enough for us to call the dom ready in oldIE</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( document.addEventListener || event.type === </span><span class="s4">&quot;load&quot; </span><span class="s1">|| document.readyState === </span><span class="s4">&quot;complete&quot; </span><span class="s1">) { 
        detach()</span><span class="s3">;</span><span class="s1"> 
        jQuery.ready()</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
jQuery.ready.promise = </span><span class="s2">function</span><span class="s1">( obj ) { 
    </span><span class="s2">if </span><span class="s1">( !readyList ) { 
 
        readyList = jQuery.Deferred()</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Catch cases where $(document).ready() is called after the browser event has already occurred.</span><span class="s1"> 
        </span><span class="s0">// we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one</span><span class="s1"> 
        </span><span class="s0">// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( document.readyState === </span><span class="s4">&quot;complete&quot; </span><span class="s1">) { 
            </span><span class="s0">// Handle it asynchronously to allow scripts the opportunity to delay ready</span><span class="s1"> 
            setTimeout( jQuery.ready )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Standards-based browsers support DOMContentLoaded</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( document.addEventListener ) { 
            </span><span class="s0">// Use the handy event callback</span><span class="s1"> 
            document.addEventListener( </span><span class="s4">&quot;DOMContentLoaded&quot;</span><span class="s3">, </span><span class="s1">completed</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// A fallback to window.onload, that will always work</span><span class="s1"> 
            window.addEventListener( </span><span class="s4">&quot;load&quot;</span><span class="s3">, </span><span class="s1">completed</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If IE event model is used</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// Ensure firing before onload, maybe late but safe also for iframes</span><span class="s1"> 
            document.attachEvent( </span><span class="s4">&quot;onreadystatechange&quot;</span><span class="s3">, </span><span class="s1">completed )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// A fallback to window.onload, that will always work</span><span class="s1"> 
            window.attachEvent( </span><span class="s4">&quot;onload&quot;</span><span class="s3">, </span><span class="s1">completed )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// If IE and not a frame</span><span class="s1"> 
            </span><span class="s0">// continually check to see if the document is ready</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">top = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">try </span><span class="s1">{ 
                top = window.frameElement == </span><span class="s2">null </span><span class="s1">&amp;&amp; document.documentElement</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">catch</span><span class="s1">(e) {} 
 
            </span><span class="s2">if </span><span class="s1">( top &amp;&amp; top.doScroll ) { 
                (</span><span class="s2">function </span><span class="s1">doScrollCheck() { 
                    </span><span class="s2">if </span><span class="s1">( !jQuery.isReady ) { 
 
                        </span><span class="s2">try </span><span class="s1">{ 
                            </span><span class="s0">// Use the trick by Diego Perini</span><span class="s1"> 
                            </span><span class="s0">// http://javascript.nwbox.com/IEContentLoaded/</span><span class="s1"> 
                            top.doScroll(</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } </span><span class="s2">catch</span><span class="s1">(e) { 
                            </span><span class="s2">return </span><span class="s1">setTimeout( doScrollCheck</span><span class="s3">, </span><span class="s5">50 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        </span><span class="s0">// detach all dom ready events</span><span class="s1"> 
                        detach()</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// and execute any waiting functions</span><span class="s1"> 
                        jQuery.ready()</span><span class="s3">;</span><span class="s1"> 
                    } 
                })()</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
    </span><span class="s2">return </span><span class="s1">readyList.promise( obj )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">strundefined = </span><span class="s2">typeof </span><span class="s1">undefined</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
</span><span class="s0">// Iteration over object's inherited properties before its own</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">i</span><span class="s3">;</span><span class="s1"> 
</span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">jQuery( support ) ) { 
    </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
} 
support.ownLast = i !== </span><span class="s4">&quot;0&quot;</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Note: most support tests are defined in their respective modules.</span><span class="s1"> 
</span><span class="s0">// false until the test is run</span><span class="s1"> 
support.inlineBlockNeedsLayout = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Execute ASAP in case we need to set body.style.zoom</span><span class="s1"> 
jQuery(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s0">// Minified: var a,b,c,d</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">val</span><span class="s3">, </span><span class="s1">div</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">container</span><span class="s3">;</span><span class="s1"> 
 
    body = document.getElementsByTagName( </span><span class="s4">&quot;body&quot; </span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !body || !body.style ) { 
        </span><span class="s0">// Return for frameset docs that don't have a body</span><span class="s1"> 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Setup</span><span class="s1"> 
    div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    container = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    container.style.cssText = </span><span class="s4">&quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;</span><span class="s3">;</span><span class="s1"> 
    body.appendChild( container ).appendChild( div )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">div.style.zoom !== strundefined ) { 
        </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
        </span><span class="s0">// Check if natively block-level elements act like inline-block</span><span class="s1"> 
        </span><span class="s0">// elements when setting their display to 'inline' and giving</span><span class="s1"> 
        </span><span class="s0">// them layout</span><span class="s1"> 
        div.style.cssText = </span><span class="s4">&quot;display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1&quot;</span><span class="s3">;</span><span class="s1"> 
 
        support.inlineBlockNeedsLayout = val = div.offsetWidth === </span><span class="s5">3</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( val ) { 
            </span><span class="s0">// Prevent IE 6 from affecting layout for positioned elements #11048</span><span class="s1"> 
            </span><span class="s0">// Prevent IE from shrinking the body in IE 7 mode #12869</span><span class="s1"> 
            </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
            body.style.zoom = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    body.removeChild( container )</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">var </span><span class="s1">div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Execute the test only if not already executed in another module.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">(support.deleteExpando == </span><span class="s2">null</span><span class="s1">) { 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        support.deleteExpando = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">delete </span><span class="s1">div.test</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">catch</span><span class="s1">( e ) { 
            support.deleteExpando = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Null elements to avoid leaks in IE.</span><span class="s1"> 
    div = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
})()</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s6">/** 
 * Determines whether an object can have data 
 */</span><span class="s1"> 
jQuery.acceptData = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s2">var </span><span class="s1">noData = jQuery.noData[ (elem.nodeName + </span><span class="s4">&quot; &quot;</span><span class="s1">).toLowerCase() ]</span><span class="s3">,</span><span class="s1"> 
        nodeType = +elem.nodeType || </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Do not set data on non-element DOM nodes because it will not be cleared (#8335).</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">nodeType !== </span><span class="s5">1 </span><span class="s1">&amp;&amp; nodeType !== </span><span class="s5">9 </span><span class="s1">? 
        </span><span class="s2">false </span><span class="s1">: 
 
        </span><span class="s0">// Nodes accept data unless otherwise specified; rejection can be conditional</span><span class="s1"> 
        !noData || noData !== </span><span class="s2">true </span><span class="s1">&amp;&amp; elem.getAttribute(</span><span class="s4">&quot;classid&quot;</span><span class="s1">) === noData</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">rbrace = </span><span class="s4">/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/</span><span class="s3">,</span><span class="s1"> 
    rmultiDash = </span><span class="s4">/([A-Z])/g</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">dataAttr( elem</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">data ) { 
    </span><span class="s0">// If nothing was found internally, try to fetch any</span><span class="s1"> 
    </span><span class="s0">// data from the HTML5 data-* attribute</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( data === undefined &amp;&amp; elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
 
        </span><span class="s2">var </span><span class="s1">name = </span><span class="s4">&quot;data-&quot; </span><span class="s1">+ key.replace( rmultiDash</span><span class="s3">, </span><span class="s4">&quot;-$1&quot; </span><span class="s1">).toLowerCase()</span><span class="s3">;</span><span class="s1"> 
 
        data = elem.getAttribute( name )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">data === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">try </span><span class="s1">{ 
                data = data === </span><span class="s4">&quot;true&quot; </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: 
                    data === </span><span class="s4">&quot;false&quot; </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: 
                    data === </span><span class="s4">&quot;null&quot; </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: 
                    </span><span class="s0">// Only convert to a number if it doesn't change the string</span><span class="s1"> 
                    +data + </span><span class="s4">&quot;&quot; </span><span class="s1">=== data ? +data : 
                    rbrace.test( data ) ? jQuery.parseJSON( data ) : 
                    data</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">catch</span><span class="s1">( e ) {} 
 
            </span><span class="s0">// Make sure we set the data so it isn't changed later</span><span class="s1"> 
            jQuery.data( elem</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            data = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">data</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// checks a cache object for emptiness</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">isEmptyDataObject( obj ) { 
    </span><span class="s2">var </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">obj ) { 
 
        </span><span class="s0">// if the public data object is empty, the private is still empty</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( name === </span><span class="s4">&quot;data&quot; </span><span class="s1">&amp;&amp; jQuery.isEmptyObject( obj[name] ) ) { 
            </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( name !== </span><span class="s4">&quot;toJSON&quot; </span><span class="s1">) { 
            </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">internalData( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">pvt </span><span class="s0">/* Internal Use Only */ </span><span class="s1">) { 
    </span><span class="s2">if </span><span class="s1">( !jQuery.acceptData( elem ) ) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">thisCache</span><span class="s3">,</span><span class="s1"> 
        internalKey = jQuery.expando</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// We have to handle DOM nodes and JS objects differently because IE6-7</span><span class="s1"> 
        </span><span class="s0">// can't GC object references properly across the DOM-JS boundary</span><span class="s1"> 
        isNode = elem.nodeType</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Only DOM nodes need the global jQuery cache; JS object data is</span><span class="s1"> 
        </span><span class="s0">// attached directly to the object so GC can occur automatically</span><span class="s1"> 
        cache = isNode ? jQuery.cache : elem</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Only defining an ID for JS objects if its cache already exists allows</span><span class="s1"> 
        </span><span class="s0">// the code to shortcut on the same path as a DOM node with no cache</span><span class="s1"> 
        id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Avoid doing any more work than we need to when trying to get data on an</span><span class="s1"> 
    </span><span class="s0">// object that has no data at all</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( (!id || !cache[id] || (!pvt &amp;&amp; !cache[id].data)) &amp;&amp; data === undefined &amp;&amp; </span><span class="s2">typeof </span><span class="s1">name === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( !id ) { 
        </span><span class="s0">// Only DOM nodes need a new unique ID for each element since their data</span><span class="s1"> 
        </span><span class="s0">// ends up in the global cache</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( isNode ) { 
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            id = internalKey</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">if </span><span class="s1">( !cache[ id ] ) { 
        </span><span class="s0">// Avoid exposing jQuery metadata on plain JS objects when the object</span><span class="s1"> 
        </span><span class="s0">// is serialized using JSON.stringify</span><span class="s1"> 
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop }</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// An object can be passed to jQuery.data instead of a key/value pair; this gets</span><span class="s1"> 
    </span><span class="s0">// shallow copied over onto the existing cache</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">name === </span><span class="s4">&quot;object&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">name === </span><span class="s4">&quot;function&quot; </span><span class="s1">) { 
        </span><span class="s2">if </span><span class="s1">( pvt ) { 
            cache[ id ] = jQuery.extend( cache[ id ]</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            cache[ id ].data = jQuery.extend( cache[ id ].data</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    thisCache = cache[ id ]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// jQuery data() is stored in a separate object inside the object's internal data</span><span class="s1"> 
    </span><span class="s0">// cache in order to avoid key collisions between internal data and user-defined</span><span class="s1"> 
    </span><span class="s0">// data.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !pvt ) { 
        </span><span class="s2">if </span><span class="s1">( !thisCache.data ) { 
            thisCache.data = {}</span><span class="s3">;</span><span class="s1"> 
        } 
 
        thisCache = thisCache.data</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( data !== undefined ) { 
        thisCache[ jQuery.camelCase( name ) ] = data</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Check for both converted-to-camel and non-converted data property names</span><span class="s1"> 
    </span><span class="s0">// If a data property was specified</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">name === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
 
        </span><span class="s0">// First Try to find as-is property data</span><span class="s1"> 
        ret = thisCache[ name ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Test for null|undefined property data</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( ret == </span><span class="s2">null </span><span class="s1">) { 
 
            </span><span class="s0">// Try to find the camelCased property</span><span class="s1"> 
            ret = thisCache[ jQuery.camelCase( name ) ]</span><span class="s3">;</span><span class="s1"> 
        } 
    } </span><span class="s2">else </span><span class="s1">{ 
        ret = thisCache</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">internalRemoveData( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">pvt ) { 
    </span><span class="s2">if </span><span class="s1">( !jQuery.acceptData( elem ) ) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">thisCache</span><span class="s3">, </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
        isNode = elem.nodeType</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// See jQuery.data for more information</span><span class="s1"> 
        cache = isNode ? jQuery.cache : elem</span><span class="s3">,</span><span class="s1"> 
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// If there is already no cache entry for this object, there is no</span><span class="s1"> 
    </span><span class="s0">// purpose in continuing</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !cache[ id ] ) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( name ) { 
 
        thisCache = pvt ? cache[ id ] : cache[ id ].data</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( thisCache ) { 
 
            </span><span class="s0">// Support array or space separated string names for data keys</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !jQuery.isArray( name ) ) { 
 
                </span><span class="s0">// try the string as a key before any manipulation</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">thisCache ) { 
                    name = [ name ]</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
 
                    </span><span class="s0">// split the camel cased version by spaces unless a key with the spaces exists</span><span class="s1"> 
                    name = jQuery.camelCase( name )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">thisCache ) { 
                        name = [ name ]</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        name = name.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s0">// If &quot;name&quot; is an array of keys...</span><span class="s1"> 
                </span><span class="s0">// When data is initially created, via (&quot;key&quot;, &quot;val&quot;) signature,</span><span class="s1"> 
                </span><span class="s0">// keys will be converted to camelCase.</span><span class="s1"> 
                </span><span class="s0">// Since there is no way to tell _how_ a key was added, remove</span><span class="s1"> 
                </span><span class="s0">// both plain key and camelCase key. #12786</span><span class="s1"> 
                </span><span class="s0">// This will only penalize the array argument path.</span><span class="s1"> 
                name = name.concat( jQuery.map( name</span><span class="s3">, </span><span class="s1">jQuery.camelCase ) )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            i = name.length</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                </span><span class="s2">delete </span><span class="s1">thisCache[ name[i] ]</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// If there is no data left in the cache, we want to continue</span><span class="s1"> 
            </span><span class="s0">// and let the cache object itself get destroyed</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) { 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s0">// See jQuery.data for more information</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !pvt ) { 
        </span><span class="s2">delete </span><span class="s1">cache[ id ].data</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Don't destroy the parent cache unless the internal data object</span><span class="s1"> 
        </span><span class="s0">// had been the only thing left in it</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !isEmptyDataObject( cache[ id ] ) ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Destroy the cache</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( isNode ) { 
        jQuery.cleanData( [ elem ]</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)</span><span class="s1"> 
    </span><span class="s0">/* jshint eqeqeq: false */</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( support.deleteExpando || cache != cache.window ) { 
        </span><span class="s0">/* jshint eqeqeq: true */</span><span class="s1"> 
        </span><span class="s2">delete </span><span class="s1">cache[ id ]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// When all else fails, null</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        cache[ id ] = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
jQuery.extend({ 
    cache: {}</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// The following elements (space-suffixed to avoid Object.prototype collisions)</span><span class="s1"> 
    </span><span class="s0">// throw uncatchable exceptions if you attempt to set expando properties</span><span class="s1"> 
    noData: { 
        </span><span class="s4">&quot;applet &quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;embed &quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// ...but Flash objects (which have this classid) *can* handle expandos</span><span class="s1"> 
        </span><span class="s4">&quot;object &quot;</span><span class="s1">: </span><span class="s4">&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    hasData: </span><span class="s2">function</span><span class="s1">( elem ) { 
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!!elem &amp;&amp; !isEmptyDataObject( elem )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    data: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">return </span><span class="s1">internalData( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeData: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name ) { 
        </span><span class="s2">return </span><span class="s1">internalRemoveData( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// For internal use only.</span><span class="s1"> 
    _data: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">return </span><span class="s1">internalData( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    _removeData: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name ) { 
        </span><span class="s2">return </span><span class="s1">internalRemoveData( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    data: </span><span class="s2">function</span><span class="s1">( key</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data</span><span class="s3">,</span><span class="s1"> 
            elem = </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
            attrs = elem &amp;&amp; elem.attributes</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Special expections of .data basically thwart jQuery.access,</span><span class="s1"> 
        </span><span class="s0">// so implement the relevant behavior ourselves</span><span class="s1"> 
 
        </span><span class="s0">// Gets all values</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( key === undefined ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.length ) { 
                data = jQuery.data( elem )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; !jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;parsedAttrs&quot; </span><span class="s1">) ) { 
                    i = attrs.length</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
 
                        </span><span class="s0">// Support: IE11+</span><span class="s1"> 
                        </span><span class="s0">// The attrs elements can be null (#14894)</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( attrs[ i ] ) { 
                            name = attrs[ i ].name</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( name.indexOf( </span><span class="s4">&quot;data-&quot; </span><span class="s1">) === </span><span class="s5">0 </span><span class="s1">) { 
                                name = jQuery.camelCase( name.slice(</span><span class="s5">5</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                                dataAttr( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data[ name ] )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
                    jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;parsedAttrs&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">data</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Sets multiple values</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
                jQuery.data( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">key )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">arguments.length &gt; </span><span class="s5">1 </span><span class="s1">? 
 
            </span><span class="s0">// Sets one value</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
                jQuery.data( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">;</span><span class="s1"> 
            }) : 
 
            </span><span class="s0">// Gets one value</span><span class="s1"> 
            </span><span class="s0">// Try to fetch any internally stored data first</span><span class="s1"> 
            elem ? dataAttr( elem</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">jQuery.data( elem</span><span class="s3">, </span><span class="s1">key ) ) : undefined</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeData: </span><span class="s2">function</span><span class="s1">( key ) { 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            jQuery.removeData( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">key )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
jQuery.extend({ 
    queue: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">var </span><span class="s1">queue</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( elem ) { 
            type = ( type || </span><span class="s4">&quot;fx&quot; </span><span class="s1">) + </span><span class="s4">&quot;queue&quot;</span><span class="s3">;</span><span class="s1"> 
            queue = jQuery._data( elem</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Speed up dequeue by getting out quickly if this is just a lookup</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( data ) { 
                </span><span class="s2">if </span><span class="s1">( !queue || jQuery.isArray(data) ) { 
                    queue = jQuery._data( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">jQuery.makeArray(data) )</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    queue.push( data )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            </span><span class="s2">return </span><span class="s1">queue || []</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    dequeue: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type ) { 
        type = type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">var </span><span class="s1">queue = jQuery.queue( elem</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">,</span><span class="s1"> 
            startLength = queue.length</span><span class="s3">,</span><span class="s1"> 
            fn = queue.shift()</span><span class="s3">,</span><span class="s1"> 
            hooks = jQuery._queueHooks( elem</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">,</span><span class="s1"> 
            next = </span><span class="s2">function</span><span class="s1">() { 
                jQuery.dequeue( elem</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If the fx queue is dequeued, always remove the progress sentinel</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s4">&quot;inprogress&quot; </span><span class="s1">) { 
            fn = queue.shift()</span><span class="s3">;</span><span class="s1"> 
            startLength--</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( fn ) { 
 
            </span><span class="s0">// Add a progress sentinel to prevent the fx queue from being</span><span class="s1"> 
            </span><span class="s0">// automatically dequeued</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;fx&quot; </span><span class="s1">) { 
                queue.unshift( </span><span class="s4">&quot;inprogress&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// clear up the last queue stop function</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">hooks.stop</span><span class="s3">;</span><span class="s1"> 
            fn.call( elem</span><span class="s3">, </span><span class="s1">next</span><span class="s3">, </span><span class="s1">hooks )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( !startLength &amp;&amp; hooks ) { 
            hooks.empty.fire()</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// not intended for public consumption - generates a queueHooks object, or returns the current one</span><span class="s1"> 
    _queueHooks: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type ) { 
        </span><span class="s2">var </span><span class="s1">key = type + </span><span class="s4">&quot;queueHooks&quot;</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">jQuery._data( elem</span><span class="s3">, </span><span class="s1">key ) || jQuery._data( elem</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">{ 
            empty: jQuery.Callbacks(</span><span class="s4">&quot;once memory&quot;</span><span class="s1">).add(</span><span class="s2">function</span><span class="s1">() { 
                jQuery._removeData( elem</span><span class="s3">, </span><span class="s1">type + </span><span class="s4">&quot;queue&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                jQuery._removeData( elem</span><span class="s3">, </span><span class="s1">key )</span><span class="s3">;</span><span class="s1"> 
            }) 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    queue: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">var </span><span class="s1">setter = </span><span class="s5">2</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            data = type</span><span class="s3">;</span><span class="s1"> 
            type = </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
            setter--</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( arguments.length &lt; setter ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.queue( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">data === undefined ? 
            </span><span class="s2">this </span><span class="s1">: 
            </span><span class="s2">this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">queue = jQuery.queue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// ensure a hooks for this queue</span><span class="s1"> 
                jQuery._queueHooks( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;fx&quot; </span><span class="s1">&amp;&amp; queue[</span><span class="s5">0</span><span class="s1">] !== </span><span class="s4">&quot;inprogress&quot; </span><span class="s1">) { 
                    jQuery.dequeue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
                } 
            })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    dequeue: </span><span class="s2">function</span><span class="s1">( type ) { 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            jQuery.dequeue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    clearQueue: </span><span class="s2">function</span><span class="s1">( type ) { 
        </span><span class="s2">return this</span><span class="s1">.queue( type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">, </span><span class="s1">[] )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// Get a promise resolved when queues of a certain type</span><span class="s1"> 
    </span><span class="s0">// are emptied (fx is the type by default)</span><span class="s1"> 
    promise: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">obj ) { 
        </span><span class="s2">var </span><span class="s1">tmp</span><span class="s3">,</span><span class="s1"> 
            count = </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
            defer = jQuery.Deferred()</span><span class="s3">,</span><span class="s1"> 
            elements = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            resolve = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( !( --count ) ) { 
                    defer.resolveWith( elements</span><span class="s3">, </span><span class="s1">[ elements ] )</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            obj = type</span><span class="s3">;</span><span class="s1"> 
            type = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
        type = type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">while </span><span class="s1">( i-- ) { 
            tmp = jQuery._data( elements[ i ]</span><span class="s3">, </span><span class="s1">type + </span><span class="s4">&quot;queueHooks&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( tmp &amp;&amp; tmp.empty ) { 
                count++</span><span class="s3">;</span><span class="s1"> 
                tmp.empty.add( resolve )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
        resolve()</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">defer.promise( obj )</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">pnum = (</span><span class="s4">/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/</span><span class="s1">).source</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">cssExpand = [ </span><span class="s4">&quot;Top&quot;</span><span class="s3">, </span><span class="s4">&quot;Right&quot;</span><span class="s3">, </span><span class="s4">&quot;Bottom&quot;</span><span class="s3">, </span><span class="s4">&quot;Left&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">isHidden = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">el ) { 
        </span><span class="s0">// isHidden might be called from jQuery#filter function;</span><span class="s1"> 
        </span><span class="s0">// in that case, element will be second argument</span><span class="s1"> 
        elem = el || elem</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">) === </span><span class="s4">&quot;none&quot; </span><span class="s1">|| !jQuery.contains( elem.ownerDocument</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s0">// Multifunctional method to get and set values of a collection</span><span class="s1"> 
</span><span class="s0">// The value/s can optionally be executed if it's a function</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">access = jQuery.access = </span><span class="s2">function</span><span class="s1">( elems</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">chainable</span><span class="s3">, </span><span class="s1">emptyGet</span><span class="s3">, </span><span class="s1">raw ) { 
    </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        length = elems.length</span><span class="s3">,</span><span class="s1"> 
        bulk = key == </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Sets many values</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( jQuery.type( key ) === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
        chainable = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">key ) { 
            jQuery.access( elems</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">key[i]</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">emptyGet</span><span class="s3">, </span><span class="s1">raw )</span><span class="s3">;</span><span class="s1"> 
        } 
 
    </span><span class="s0">// Sets one value</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( value !== undefined ) { 
        chainable = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !jQuery.isFunction( value ) ) { 
            raw = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( bulk ) { 
            </span><span class="s0">// Bulk operations run against the entire set</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( raw ) { 
                fn.call( elems</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">;</span><span class="s1"> 
                fn = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// ...except when executing function values</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                bulk = fn</span><span class="s3">;</span><span class="s1"> 
                fn = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value ) { 
                    </span><span class="s2">return </span><span class="s1">bulk.call( jQuery( elem )</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( fn ) { 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; length</span><span class="s3">; </span><span class="s1">i++ ) { 
                fn( elems[i]</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">raw ? value : value.call( elems[i]</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">fn( elems[i]</span><span class="s3">, </span><span class="s1">key ) ) )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">chainable ? 
        elems : 
 
        </span><span class="s0">// Gets</span><span class="s1"> 
        bulk ? 
            fn.call( elems ) : 
            length ? fn( elems[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">key ) : emptyGet</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">rcheckableType = (</span><span class="s4">/^(?:checkbox|radio)$/i</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s0">// Minified: var a,b,c</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">input = document.createElement( </span><span class="s4">&quot;input&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        fragment = document.createDocumentFragment()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Setup</span><span class="s1"> 
    div.innerHTML = </span><span class="s4">&quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// IE strips leading whitespace when .innerHTML is used</span><span class="s1"> 
    support.leadingWhitespace = div.firstChild.nodeType === </span><span class="s5">3</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure that tbody elements aren't automatically inserted</span><span class="s1"> 
    </span><span class="s0">// IE will insert them into empty tables</span><span class="s1"> 
    support.tbody = !div.getElementsByTagName( </span><span class="s4">&quot;tbody&quot; </span><span class="s1">).length</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure that link elements get serialized correctly by innerHTML</span><span class="s1"> 
    </span><span class="s0">// This requires a wrapper element in IE</span><span class="s1"> 
    support.htmlSerialize = !!div.getElementsByTagName( </span><span class="s4">&quot;link&quot; </span><span class="s1">).length</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Makes sure cloning an html5 element does not cause problems</span><span class="s1"> 
    </span><span class="s0">// Where outerHTML is undefined, this still works</span><span class="s1"> 
    support.html5Clone = 
        document.createElement( </span><span class="s4">&quot;nav&quot; </span><span class="s1">).cloneNode( </span><span class="s2">true </span><span class="s1">).outerHTML !== </span><span class="s4">&quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Check if a disconnected checkbox will retain its checked</span><span class="s1"> 
    </span><span class="s0">// value of true after appended to the DOM (IE6/7)</span><span class="s1"> 
    input.type = </span><span class="s4">&quot;checkbox&quot;</span><span class="s3">;</span><span class="s1"> 
    input.checked = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    fragment.appendChild( input )</span><span class="s3">;</span><span class="s1"> 
    support.appendChecked = input.checked</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure textarea (and checkbox) defaultValue is properly cloned</span><span class="s1"> 
    </span><span class="s0">// Support: IE6-IE11+</span><span class="s1"> 
    div.innerHTML = </span><span class="s4">&quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
    support.noCloneChecked = !!div.cloneNode( </span><span class="s2">true </span><span class="s1">).lastChild.defaultValue</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// #11217 - WebKit loses check when the name is after the checked attribute</span><span class="s1"> 
    fragment.appendChild( div )</span><span class="s3">;</span><span class="s1"> 
    div.innerHTML = </span><span class="s4">&quot;&lt;input type='radio' checked='checked' name='t'/&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3</span><span class="s1"> 
    </span><span class="s0">// old WebKit doesn't clone checked state correctly in fragments</span><span class="s1"> 
    support.checkClone = div.cloneNode( </span><span class="s2">true </span><span class="s1">).cloneNode( </span><span class="s2">true </span><span class="s1">).lastChild.checked</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
    </span><span class="s0">// Opera does not clone events (and typeof div.attachEvent === undefined).</span><span class="s1"> 
    </span><span class="s0">// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()</span><span class="s1"> 
    support.noCloneEvent = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( div.attachEvent ) { 
        div.attachEvent( </span><span class="s4">&quot;onclick&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
            support.noCloneEvent = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
        div.cloneNode( </span><span class="s2">true </span><span class="s1">).click()</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Execute the test only if not already executed in another module.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">(support.deleteExpando == </span><span class="s2">null</span><span class="s1">) { 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        support.deleteExpando = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">delete </span><span class="s1">div.test</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">catch</span><span class="s1">( e ) { 
            support.deleteExpando = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
})()</span><span class="s3">;</span><span class="s1"> 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">eventName</span><span class="s3">,</span><span class="s1"> 
        div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;9 (lack submit/change bubble), Firefox 23+ (lack focusin event)</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ submit: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">change: </span><span class="s2">true</span><span class="s3">, </span><span class="s1">focusin: </span><span class="s2">true </span><span class="s1">}) { 
        eventName = </span><span class="s4">&quot;on&quot; </span><span class="s1">+ i</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !(support[ i + </span><span class="s4">&quot;Bubbles&quot; </span><span class="s1">] = eventName </span><span class="s2">in </span><span class="s1">window) ) { 
            </span><span class="s0">// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)</span><span class="s1"> 
            div.setAttribute( eventName</span><span class="s3">, </span><span class="s4">&quot;t&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            support[ i + </span><span class="s4">&quot;Bubbles&quot; </span><span class="s1">] = div.attributes[ eventName ].expando === </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Null elements to avoid leaks in IE.</span><span class="s1"> 
    div = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
})()</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">rformElems = </span><span class="s4">/^(?:input|select|textarea)$/i</span><span class="s3">,</span><span class="s1"> 
    rkeyEvent = </span><span class="s4">/^key/</span><span class="s3">,</span><span class="s1"> 
    rmouseEvent = </span><span class="s4">/^(?:mouse|pointer|contextmenu)|click/</span><span class="s3">,</span><span class="s1"> 
    rfocusMorph = </span><span class="s4">/^(?:focusinfocus|focusoutblur)$/</span><span class="s3">,</span><span class="s1"> 
    rtypenamespace = </span><span class="s4">/^([^.]*)(?:\.(.+)|)$/</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">returnTrue() { 
    </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">returnFalse() { 
    </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">safeActiveElement() { 
    </span><span class="s2">try </span><span class="s1">{ 
        </span><span class="s2">return </span><span class="s1">document.activeElement</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">catch </span><span class="s1">( err ) { } 
} 
 
</span><span class="s0">/* 
 * Helper functions for managing events -- not part of the public interface. 
 * Props to Dean Edwards' addEvent library for many of the ideas. 
 */</span><span class="s1"> 
jQuery.event = { 
 
    global: {}</span><span class="s3">,</span><span class="s1"> 
 
    add: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">selector ) { 
        </span><span class="s2">var </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">events</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">handleObjIn</span><span class="s3">,</span><span class="s1"> 
            special</span><span class="s3">, </span><span class="s1">eventHandle</span><span class="s3">, </span><span class="s1">handleObj</span><span class="s3">,</span><span class="s1"> 
            handlers</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">namespaces</span><span class="s3">, </span><span class="s1">origType</span><span class="s3">,</span><span class="s1"> 
            elemData = jQuery._data( elem )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Don't attach events to noData or text/comment nodes (but allow plain objects)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elemData ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Caller can pass in an object of custom data in lieu of the handler</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( handler.handler ) { 
            handleObjIn = handler</span><span class="s3">;</span><span class="s1"> 
            handler = handleObjIn.handler</span><span class="s3">;</span><span class="s1"> 
            selector = handleObjIn.selector</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Make sure that the handler has a unique ID, used to find/remove it later</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !handler.guid ) { 
            handler.guid = jQuery.guid++</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Init the element's event structure and main handler, if this is the first</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !(events = elemData.events) ) { 
            events = elemData.events = {}</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( !(eventHandle = elemData.handle) ) { 
            eventHandle = elemData.handle = </span><span class="s2">function</span><span class="s1">( e ) { 
                </span><span class="s0">// Discard the second event of a jQuery.event.trigger() and</span><span class="s1"> 
                </span><span class="s0">// when an event is called after a page has unloaded</span><span class="s1"> 
                </span><span class="s2">return typeof </span><span class="s1">jQuery !== strundefined &amp;&amp; (!e || jQuery.event.triggered !== e.type) ? 
                    jQuery.event.dispatch.apply( eventHandle.elem</span><span class="s3">, </span><span class="s1">arguments ) : 
                    undefined</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events</span><span class="s1"> 
            eventHandle.elem = elem</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Handle multiple events separated by a space</span><span class="s1"> 
        types = ( types || </span><span class="s4">&quot;&quot; </span><span class="s1">).match( rnotwhite ) || [ </span><span class="s4">&quot;&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        t = types.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( t-- ) { 
            tmp = rtypenamespace.exec( types[t] ) || []</span><span class="s3">;</span><span class="s1"> 
            type = origType = tmp[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            namespaces = ( tmp[</span><span class="s5">2</span><span class="s1">] || </span><span class="s4">&quot;&quot; </span><span class="s1">).split( </span><span class="s4">&quot;.&quot; </span><span class="s1">).sort()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// There *must* be a type, no attaching namespace-only handlers</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !type ) { 
                </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// If event changes its type, use the special event handlers for the changed type</span><span class="s1"> 
            special = jQuery.event.special[ type ] || {}</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// If selector defined, determine special event api type, otherwise given type</span><span class="s1"> 
            type = ( selector ? special.delegateType : special.bindType ) || type</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Update special based on newly reset type</span><span class="s1"> 
            special = jQuery.event.special[ type ] || {}</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// handleObj is passed to all event handlers</span><span class="s1"> 
            handleObj = jQuery.extend({ 
                type: type</span><span class="s3">,</span><span class="s1"> 
                origType: origType</span><span class="s3">,</span><span class="s1"> 
                data: data</span><span class="s3">,</span><span class="s1"> 
                handler: handler</span><span class="s3">,</span><span class="s1"> 
                guid: handler.guid</span><span class="s3">,</span><span class="s1"> 
                selector: selector</span><span class="s3">,</span><span class="s1"> 
                needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector )</span><span class="s3">,</span><span class="s1"> 
                namespace: namespaces.join(</span><span class="s4">&quot;.&quot;</span><span class="s1">) 
            }</span><span class="s3">, </span><span class="s1">handleObjIn )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Init the event handler queue if we're the first</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !(handlers = events[ type ]) ) { 
                handlers = events[ type ] = []</span><span class="s3">;</span><span class="s1"> 
                handlers.delegateCount = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Only use addEventListener/attachEvent if the special events handler returns false</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !special.setup || special.setup.call( elem</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">namespaces</span><span class="s3">, </span><span class="s1">eventHandle ) === </span><span class="s2">false </span><span class="s1">) { 
                    </span><span class="s0">// Bind the global event handler to the element</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( elem.addEventListener ) { 
                        elem.addEventListener( type</span><span class="s3">, </span><span class="s1">eventHandle</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                    } </span><span class="s2">else if </span><span class="s1">( elem.attachEvent ) { 
                        elem.attachEvent( </span><span class="s4">&quot;on&quot; </span><span class="s1">+ type</span><span class="s3">, </span><span class="s1">eventHandle )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
            </span><span class="s2">if </span><span class="s1">( special.add ) { 
                special.add.call( elem</span><span class="s3">, </span><span class="s1">handleObj )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( !handleObj.handler.guid ) { 
                    handleObj.handler.guid = handler.guid</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// Add to the element's handler list, delegates in front</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( selector ) { 
                handlers.splice( handlers.delegateCount++</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">handleObj )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                handlers.push( handleObj )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Keep track of which events have ever been used, for event optimization</span><span class="s1"> 
            jQuery.event.global[ type ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Nullify elem to prevent memory leaks in IE</span><span class="s1"> 
        elem = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Detach an event or set of events from an element</span><span class="s1"> 
    remove: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">mappedTypes ) { 
        </span><span class="s2">var </span><span class="s1">j</span><span class="s3">, </span><span class="s1">handleObj</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">,</span><span class="s1"> 
            origCount</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">events</span><span class="s3">,</span><span class="s1"> 
            special</span><span class="s3">, </span><span class="s1">handlers</span><span class="s3">, </span><span class="s1">type</span><span class="s3">,</span><span class="s1"> 
            namespaces</span><span class="s3">, </span><span class="s1">origType</span><span class="s3">,</span><span class="s1"> 
            elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !elemData || !(events = elemData.events) ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Once for each type.namespace in types; type may be omitted</span><span class="s1"> 
        types = ( types || </span><span class="s4">&quot;&quot; </span><span class="s1">).match( rnotwhite ) || [ </span><span class="s4">&quot;&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        t = types.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( t-- ) { 
            tmp = rtypenamespace.exec( types[t] ) || []</span><span class="s3">;</span><span class="s1"> 
            type = origType = tmp[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            namespaces = ( tmp[</span><span class="s5">2</span><span class="s1">] || </span><span class="s4">&quot;&quot; </span><span class="s1">).split( </span><span class="s4">&quot;.&quot; </span><span class="s1">).sort()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Unbind all events (on this namespace, if provided) for the element</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !type ) { 
                </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">events ) { 
                    jQuery.event.remove( elem</span><span class="s3">, </span><span class="s1">type + types[ t ]</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
            } 
 
            special = jQuery.event.special[ type ] || {}</span><span class="s3">;</span><span class="s1"> 
            type = ( selector ? special.delegateType : special.bindType ) || type</span><span class="s3">;</span><span class="s1"> 
            handlers = events[ type ] || []</span><span class="s3">;</span><span class="s1"> 
            tmp = tmp[</span><span class="s5">2</span><span class="s1">] &amp;&amp; </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;(^|</span><span class="s3">\\</span><span class="s4">.)&quot; </span><span class="s1">+ namespaces.join(</span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">.(?:.*</span><span class="s3">\\</span><span class="s4">.|)&quot;</span><span class="s1">) + </span><span class="s4">&quot;(</span><span class="s3">\\</span><span class="s4">.|$)&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Remove matching events</span><span class="s1"> 
            origCount = j = handlers.length</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( j-- ) { 
                handleObj = handlers[ j ]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( ( mappedTypes || origType === handleObj.origType ) &amp;&amp; 
                    ( !handler || handler.guid === handleObj.guid ) &amp;&amp; 
                    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp; 
                    ( !selector || selector === handleObj.selector || selector === </span><span class="s4">&quot;**&quot; </span><span class="s1">&amp;&amp; handleObj.selector ) ) { 
                    handlers.splice( j</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( handleObj.selector ) { 
                        handlers.delegateCount--</span><span class="s3">;</span><span class="s1"> 
                    } 
                    </span><span class="s2">if </span><span class="s1">( special.remove ) { 
                        special.remove.call( elem</span><span class="s3">, </span><span class="s1">handleObj )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
            </span><span class="s0">// Remove generic event handler if we removed something and no more handlers exist</span><span class="s1"> 
            </span><span class="s0">// (avoids potential for endless recursion during removal of special event handlers)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( origCount &amp;&amp; !handlers.length ) { 
                </span><span class="s2">if </span><span class="s1">( !special.teardown || special.teardown.call( elem</span><span class="s3">, </span><span class="s1">namespaces</span><span class="s3">, </span><span class="s1">elemData.handle ) === </span><span class="s2">false </span><span class="s1">) { 
                    jQuery.removeEvent( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">elemData.handle )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">delete </span><span class="s1">events[ type ]</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Remove the expando if it's no longer used</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.isEmptyObject( events ) ) { 
            </span><span class="s2">delete </span><span class="s1">elemData.handle</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// removeData also checks for emptiness and clears the expando if empty</span><span class="s1"> 
            </span><span class="s0">// so use it instead of delete</span><span class="s1"> 
            jQuery._removeData( elem</span><span class="s3">, </span><span class="s4">&quot;events&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    trigger: </span><span class="s2">function</span><span class="s1">( event</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">onlyHandlers ) { 
        </span><span class="s2">var </span><span class="s1">handle</span><span class="s3">, </span><span class="s1">ontype</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">,</span><span class="s1"> 
            bubbleType</span><span class="s3">, </span><span class="s1">special</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
            eventPath = [ elem || document ]</span><span class="s3">,</span><span class="s1"> 
            type = hasOwn.call( event</span><span class="s3">, </span><span class="s4">&quot;type&quot; </span><span class="s1">) ? event.type : event</span><span class="s3">,</span><span class="s1"> 
            namespaces = hasOwn.call( event</span><span class="s3">, </span><span class="s4">&quot;namespace&quot; </span><span class="s1">) ? event.namespace.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">) : []</span><span class="s3">;</span><span class="s1"> 
 
        cur = tmp = elem = elem || document</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Don't do events on text and comment nodes</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">3 </span><span class="s1">|| elem.nodeType === </span><span class="s5">8 </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// focus/blur morphs to focusin/out; ensure we're not firing them right now</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( rfocusMorph.test( type + jQuery.event.triggered ) ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( type.indexOf(</span><span class="s4">&quot;.&quot;</span><span class="s1">) &gt;= </span><span class="s5">0 </span><span class="s1">) { 
            </span><span class="s0">// Namespaced trigger; create a regexp to match event type in handle()</span><span class="s1"> 
            namespaces = type.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            type = namespaces.shift()</span><span class="s3">;</span><span class="s1"> 
            namespaces.sort()</span><span class="s3">;</span><span class="s1"> 
        } 
        ontype = type.indexOf(</span><span class="s4">&quot;:&quot;</span><span class="s1">) &lt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; </span><span class="s4">&quot;on&quot; </span><span class="s1">+ type</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Caller can pass in a jQuery.Event object, Object, or just an event type string</span><span class="s1"> 
        event = event[ jQuery.expando ] ? 
            event : 
            </span><span class="s2">new </span><span class="s1">jQuery.Event( type</span><span class="s3">, </span><span class="s2">typeof </span><span class="s1">event === </span><span class="s4">&quot;object&quot; </span><span class="s1">&amp;&amp; event )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)</span><span class="s1"> 
        event.isTrigger = onlyHandlers ? </span><span class="s5">2 </span><span class="s1">: </span><span class="s5">3</span><span class="s3">;</span><span class="s1"> 
        event.namespace = namespaces.join(</span><span class="s4">&quot;.&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        event.namespace_re = event.namespace ? 
            </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;(^|</span><span class="s3">\\</span><span class="s4">.)&quot; </span><span class="s1">+ namespaces.join(</span><span class="s4">&quot;</span><span class="s3">\\</span><span class="s4">.(?:.*</span><span class="s3">\\</span><span class="s4">.|)&quot;</span><span class="s1">) + </span><span class="s4">&quot;(</span><span class="s3">\\</span><span class="s4">.|$)&quot; </span><span class="s1">) : 
            </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Clean up the event in case it is being reused</span><span class="s1"> 
        event.result = undefined</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !event.target ) { 
            event.target = elem</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Clone any incoming data and prepend the event, creating the handler arg list</span><span class="s1"> 
        data = data == </span><span class="s2">null </span><span class="s1">? 
            [ event ] : 
            jQuery.makeArray( data</span><span class="s3">, </span><span class="s1">[ event ] )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Allow special events to draw outside the lines</span><span class="s1"> 
        special = jQuery.event.special[ type ] || {}</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem</span><span class="s3">, </span><span class="s1">data ) === </span><span class="s2">false </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Determine event propagation path in advance, per W3C events spec (#9951)</span><span class="s1"> 
        </span><span class="s0">// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) { 
 
            bubbleType = special.delegateType || type</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !rfocusMorph.test( bubbleType + type ) ) { 
                cur = cur.parentNode</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">cur</span><span class="s3">; </span><span class="s1">cur = cur.parentNode ) { 
                eventPath.push( cur )</span><span class="s3">;</span><span class="s1"> 
                tmp = cur</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( tmp === (elem.ownerDocument || document) ) { 
                eventPath.push( tmp.defaultView || tmp.parentWindow || window )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Fire handlers on the event path</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) { 
 
            event.type = i &gt; </span><span class="s5">1 </span><span class="s1">? 
                bubbleType : 
                special.bindType || type</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// jQuery handler</span><span class="s1"> 
            handle = ( jQuery._data( cur</span><span class="s3">, </span><span class="s4">&quot;events&quot; </span><span class="s1">) || {} )[ event.type ] &amp;&amp; jQuery._data( cur</span><span class="s3">, </span><span class="s4">&quot;handle&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( handle ) { 
                handle.apply( cur</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Native handler</span><span class="s1"> 
            handle = ontype &amp;&amp; cur[ ontype ]</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) { 
                event.result = handle.apply( cur</span><span class="s3">, </span><span class="s1">data )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( event.result === </span><span class="s2">false </span><span class="s1">) { 
                    event.preventDefault()</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
        event.type = type</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If nobody prevented the default action, do it now</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) { 
 
            </span><span class="s2">if </span><span class="s1">( (!special._default || special._default.apply( eventPath.pop()</span><span class="s3">, </span><span class="s1">data ) === </span><span class="s2">false</span><span class="s1">) &amp;&amp; 
                jQuery.acceptData( elem ) ) { 
 
                </span><span class="s0">// Call a native DOM method on the target with the same name name as the event.</span><span class="s1"> 
                </span><span class="s0">// Can't use an .isFunction() check here because IE6/7 fails that test.</span><span class="s1"> 
                </span><span class="s0">// Don't do default actions on window, that's where global variables be (#6170)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( ontype &amp;&amp; elem[ type ] &amp;&amp; !jQuery.isWindow( elem ) ) { 
 
                    </span><span class="s0">// Don't re-trigger an onFOO event when we call its FOO() method</span><span class="s1"> 
                    tmp = elem[ ontype ]</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( tmp ) { 
                        elem[ ontype ] = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Prevent re-triggering of the same event, since we already bubbled it above</span><span class="s1"> 
                    jQuery.event.triggered = type</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">try </span><span class="s1">{ 
                        elem[ type ]()</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">catch </span><span class="s1">( e ) { 
                        </span><span class="s0">// IE&lt;9 dies on focus/blur to hidden element (#1486,#12518)</span><span class="s1"> 
                        </span><span class="s0">// only reproducible on winXP IE8 native, not IE9 in IE8 mode</span><span class="s1"> 
                    } 
                    jQuery.event.triggered = undefined</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( tmp ) { 
                        elem[ ontype ] = tmp</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">event.result</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    dispatch: </span><span class="s2">function</span><span class="s1">( event ) { 
 
        </span><span class="s0">// Make a writable jQuery.Event from the native event object</span><span class="s1"> 
        event = jQuery.event.fix( event )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">handleObj</span><span class="s3">, </span><span class="s1">matched</span><span class="s3">, </span><span class="s1">j</span><span class="s3">,</span><span class="s1"> 
            handlerQueue = []</span><span class="s3">,</span><span class="s1"> 
            args = slice.call( arguments )</span><span class="s3">,</span><span class="s1"> 
            handlers = ( jQuery._data( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;events&quot; </span><span class="s1">) || {} )[ event.type ] || []</span><span class="s3">,</span><span class="s1"> 
            special = jQuery.event.special[ event.type ] || {}</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Use the fix-ed jQuery.Event rather than the (read-only) native event</span><span class="s1"> 
        args[</span><span class="s5">0</span><span class="s1">] = event</span><span class="s3">;</span><span class="s1"> 
        event.delegateTarget = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Call the preDispatch hook for the mapped type, and let it bail if desired</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( special.preDispatch &amp;&amp; special.preDispatch.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">event ) === </span><span class="s2">false </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Determine handlers</span><span class="s1"> 
        handlerQueue = jQuery.event.handlers.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s1">handlers )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Run delegates first; they may want to stop propagation beneath us</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) { 
            event.currentTarget = matched.elem</span><span class="s3">;</span><span class="s1"> 
 
            j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) { 
 
                </span><span class="s0">// Triggered event must either 1) have no namespace, or</span><span class="s1"> 
                </span><span class="s0">// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) { 
 
                    event.handleObj = handleObj</span><span class="s3">;</span><span class="s1"> 
                    event.data = handleObj.data</span><span class="s3">;</span><span class="s1"> 
 
                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler ) 
                            .apply( matched.elem</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( ret !== undefined ) { 
                        </span><span class="s2">if </span><span class="s1">( (event.result = ret) === </span><span class="s2">false </span><span class="s1">) { 
                            event.preventDefault()</span><span class="s3">;</span><span class="s1"> 
                            event.stopPropagation()</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                } 
            } 
        } 
 
        </span><span class="s0">// Call the postDispatch hook for the mapped type</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( special.postDispatch ) { 
            special.postDispatch.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">event )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">event.result</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    handlers: </span><span class="s2">function</span><span class="s1">( event</span><span class="s3">, </span><span class="s1">handlers ) { 
        </span><span class="s2">var </span><span class="s1">sel</span><span class="s3">, </span><span class="s1">handleObj</span><span class="s3">, </span><span class="s1">matches</span><span class="s3">, </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
            handlerQueue = []</span><span class="s3">,</span><span class="s1"> 
            delegateCount = handlers.delegateCount</span><span class="s3">,</span><span class="s1"> 
            cur = event.target</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Find delegate handlers</span><span class="s1"> 
        </span><span class="s0">// Black-hole SVG &lt;use&gt; instance trees (#13180)</span><span class="s1"> 
        </span><span class="s0">// Avoid non-left-click bubbling in Firefox (#3861)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== </span><span class="s4">&quot;click&quot;</span><span class="s1">) ) { 
 
            </span><span class="s0">/* jshint eqeqeq: false */</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">cur != </span><span class="s2">this</span><span class="s3">; </span><span class="s1">cur = cur.parentNode || </span><span class="s2">this </span><span class="s1">) { 
                </span><span class="s0">/* jshint eqeqeq: true */</span><span class="s1"> 
 
                </span><span class="s0">// Don't check non-elements (#13208)</span><span class="s1"> 
                </span><span class="s0">// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( cur.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; (cur.disabled !== </span><span class="s2">true </span><span class="s1">|| event.type !== </span><span class="s4">&quot;click&quot;</span><span class="s1">) ) { 
                    matches = []</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; delegateCount</span><span class="s3">; </span><span class="s1">i++ ) { 
                        handleObj = handlers[ i ]</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// Don't conflict with Object.prototype properties (#13203)</span><span class="s1"> 
                        sel = handleObj.selector + </span><span class="s4">&quot; &quot;</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s2">if </span><span class="s1">( matches[ sel ] === undefined ) { 
                            matches[ sel ] = handleObj.needsContext ? 
                                jQuery( sel</span><span class="s3">, </span><span class="s2">this </span><span class="s1">).index( cur ) &gt;= </span><span class="s5">0 </span><span class="s1">: 
                                jQuery.find( sel</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">[ cur ] ).length</span><span class="s3">;</span><span class="s1"> 
                        } 
                        </span><span class="s2">if </span><span class="s1">( matches[ sel ] ) { 
                            matches.push( handleObj )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                    </span><span class="s2">if </span><span class="s1">( matches.length ) { 
                        handlerQueue.push({ elem: cur</span><span class="s3">, </span><span class="s1">handlers: matches })</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        </span><span class="s0">// Add the remaining (directly-bound) handlers</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( delegateCount &lt; handlers.length ) { 
            handlerQueue.push({ elem: </span><span class="s2">this</span><span class="s3">, </span><span class="s1">handlers: handlers.slice( delegateCount ) })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">handlerQueue</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    fix: </span><span class="s2">function</span><span class="s1">( event ) { 
        </span><span class="s2">if </span><span class="s1">( event[ jQuery.expando ] ) { 
            </span><span class="s2">return </span><span class="s1">event</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Create a writable copy of the event object and normalize some properties</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">,</span><span class="s1"> 
            type = event.type</span><span class="s3">,</span><span class="s1"> 
            originalEvent = event</span><span class="s3">,</span><span class="s1"> 
            fixHook = </span><span class="s2">this</span><span class="s1">.fixHooks[ type ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !fixHook ) { 
            </span><span class="s2">this</span><span class="s1">.fixHooks[ type ] = fixHook = 
                rmouseEvent.test( type ) ? </span><span class="s2">this</span><span class="s1">.mouseHooks : 
                rkeyEvent.test( type ) ? </span><span class="s2">this</span><span class="s1">.keyHooks : 
                {}</span><span class="s3">;</span><span class="s1"> 
        } 
        copy = fixHook.props ? </span><span class="s2">this</span><span class="s1">.props.concat( fixHook.props ) : </span><span class="s2">this</span><span class="s1">.props</span><span class="s3">;</span><span class="s1"> 
 
        event = </span><span class="s2">new </span><span class="s1">jQuery.Event( originalEvent )</span><span class="s3">;</span><span class="s1"> 
 
        i = copy.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( i-- ) { 
            prop = copy[ i ]</span><span class="s3">;</span><span class="s1"> 
            event[ prop ] = originalEvent[ prop ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// Fix target property (#1925)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !event.target ) { 
            event.target = originalEvent.srcElement || document</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: Chrome 23+, Safari?</span><span class="s1"> 
        </span><span class="s0">// Target should not be a text node (#504, #13143)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( event.target.nodeType === </span><span class="s5">3 </span><span class="s1">) { 
            event.target = event.target.parentNode</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)</span><span class="s1"> 
        event.metaKey = !!event.metaKey</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">fixHook.filter ? fixHook.filter( event</span><span class="s3">, </span><span class="s1">originalEvent ) : event</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Includes some event props shared by KeyEvent and MouseEvent</span><span class="s1"> 
    props: </span><span class="s4">&quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;</span><span class="s1">.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    fixHooks: {}</span><span class="s3">,</span><span class="s1"> 
 
    keyHooks: { 
        props: </span><span class="s4">&quot;char charCode key keyCode&quot;</span><span class="s1">.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        filter: </span><span class="s2">function</span><span class="s1">( event</span><span class="s3">, </span><span class="s1">original ) { 
 
            </span><span class="s0">// Add which for key events</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( event.which == </span><span class="s2">null </span><span class="s1">) { 
                event.which = original.charCode != </span><span class="s2">null </span><span class="s1">? original.charCode : original.keyCode</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">event</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    mouseHooks: { 
        props: </span><span class="s4">&quot;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement&quot;</span><span class="s1">.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        filter: </span><span class="s2">function</span><span class="s1">( event</span><span class="s3">, </span><span class="s1">original ) { 
            </span><span class="s2">var </span><span class="s1">body</span><span class="s3">, </span><span class="s1">eventDoc</span><span class="s3">, </span><span class="s1">doc</span><span class="s3">,</span><span class="s1"> 
                button = original.button</span><span class="s3">,</span><span class="s1"> 
                fromElement = original.fromElement</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Calculate pageX/Y if missing and clientX/Y available</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( event.pageX == </span><span class="s2">null </span><span class="s1">&amp;&amp; original.clientX != </span><span class="s2">null </span><span class="s1">) { 
                eventDoc = event.target.ownerDocument || document</span><span class="s3">;</span><span class="s1"> 
                doc = eventDoc.documentElement</span><span class="s3">;</span><span class="s1"> 
                body = eventDoc.body</span><span class="s3">;</span><span class="s1"> 
 
                event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || </span><span class="s5">0 </span><span class="s1">) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || </span><span class="s5">0 </span><span class="s1">) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Add relatedTarget, if necessary</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !event.relatedTarget &amp;&amp; fromElement ) { 
                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Add which for click: 1 === left; 2 === middle; 3 === right</span><span class="s1"> 
            </span><span class="s0">// Note: button is not normalized, so don't use it</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !event.which &amp;&amp; button !== undefined ) { 
                event.which = ( button &amp; </span><span class="s5">1 </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: ( button &amp; </span><span class="s5">2 </span><span class="s1">? </span><span class="s5">3 </span><span class="s1">: ( button &amp; </span><span class="s5">4 </span><span class="s1">? </span><span class="s5">2 </span><span class="s1">: </span><span class="s5">0 </span><span class="s1">) ) )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">event</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    special: { 
        load: { 
            </span><span class="s0">// Prevent triggered image.load events from bubbling to window.load</span><span class="s1"> 
            noBubble: </span><span class="s2">true</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
        focus: { 
            </span><span class="s0">// Fire native event if possible so blur/focus sequence is correct</span><span class="s1"> 
            trigger: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this </span><span class="s1">!== safeActiveElement() &amp;&amp; </span><span class="s2">this</span><span class="s1">.focus ) { 
                    </span><span class="s2">try </span><span class="s1">{ 
                        </span><span class="s2">this</span><span class="s1">.focus()</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">catch </span><span class="s1">( e ) { 
                        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
                        </span><span class="s0">// If we error on focus to hidden element (#1486, #12518),</span><span class="s1"> 
                        </span><span class="s0">// let .trigger() run the handlers</span><span class="s1"> 
                    } 
                } 
            }</span><span class="s3">,</span><span class="s1"> 
            delegateType: </span><span class="s4">&quot;focusin&quot;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
        blur: { 
            trigger: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this </span><span class="s1">=== safeActiveElement() &amp;&amp; </span><span class="s2">this</span><span class="s1">.blur ) { 
                    </span><span class="s2">this</span><span class="s1">.blur()</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">,</span><span class="s1"> 
            delegateType: </span><span class="s4">&quot;focusout&quot;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
        click: { 
            </span><span class="s0">// For checkbox, fire native event so checked state will be right</span><span class="s1"> 
            trigger: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;input&quot; </span><span class="s1">) &amp;&amp; </span><span class="s2">this</span><span class="s1">.type === </span><span class="s4">&quot;checkbox&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.click ) { 
                    </span><span class="s2">this</span><span class="s1">.click()</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// For cross-browser consistency, don't fire native .click() on links</span><span class="s1"> 
            _default: </span><span class="s2">function</span><span class="s1">( event ) { 
                </span><span class="s2">return </span><span class="s1">jQuery.nodeName( event.target</span><span class="s3">, </span><span class="s4">&quot;a&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
 
        beforeunload: { 
            postDispatch: </span><span class="s2">function</span><span class="s1">( event ) { 
 
                </span><span class="s0">// Support: Firefox 20+</span><span class="s1"> 
                </span><span class="s0">// Firefox doesn't alert if the returnValue field is not set.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( event.result !== undefined &amp;&amp; event.originalEvent ) { 
                    event.originalEvent.returnValue = event.result</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    simulate: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s1">bubble ) { 
        </span><span class="s0">// Piggyback on a donor event to simulate a different one.</span><span class="s1"> 
        </span><span class="s0">// Fake originalEvent to avoid donor's stopPropagation, but if the</span><span class="s1"> 
        </span><span class="s0">// simulated event prevents default then we do the same on the donor.</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">e = jQuery.extend( 
            </span><span class="s2">new </span><span class="s1">jQuery.Event()</span><span class="s3">,</span><span class="s1"> 
            event</span><span class="s3">,</span><span class="s1"> 
            { 
                type: type</span><span class="s3">,</span><span class="s1"> 
                isSimulated: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
                originalEvent: {} 
            } 
        )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( bubble ) { 
            jQuery.event.trigger( e</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            jQuery.event.dispatch.call( elem</span><span class="s3">, </span><span class="s1">e )</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( e.isDefaultPrevented() ) { 
            event.preventDefault()</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.removeEvent = document.removeEventListener ? 
    </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">handle ) { 
        </span><span class="s2">if </span><span class="s1">( elem.removeEventListener ) { 
            elem.removeEventListener( type</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">, </span><span class="s2">false </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } : 
    </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">handle ) { 
        </span><span class="s2">var </span><span class="s1">name = </span><span class="s4">&quot;on&quot; </span><span class="s1">+ type</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( elem.detachEvent ) { 
 
            </span><span class="s0">// #8545, #7054, preventing memory leaks for custom events in IE6-8</span><span class="s1"> 
            </span><span class="s0">// detachEvent needed property on element, by name of that event, to properly expose it to GC</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem[ name ] === strundefined ) { 
                elem[ name ] = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
            } 
 
            elem.detachEvent( name</span><span class="s3">, </span><span class="s1">handle )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
jQuery.Event = </span><span class="s2">function</span><span class="s1">( src</span><span class="s3">, </span><span class="s1">props ) { 
    </span><span class="s0">// Allow instantiation without the 'new' keyword</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !(</span><span class="s2">this instanceof </span><span class="s1">jQuery.Event) ) { 
        </span><span class="s2">return new </span><span class="s1">jQuery.Event( src</span><span class="s3">, </span><span class="s1">props )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Event object</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( src &amp;&amp; src.type ) { 
        </span><span class="s2">this</span><span class="s1">.originalEvent = src</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.type = src.type</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Events bubbling up the document may have been marked as prevented</span><span class="s1"> 
        </span><span class="s0">// by a handler lower down the tree; reflect the correct value.</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.isDefaultPrevented = src.defaultPrevented || 
                src.defaultPrevented === undefined &amp;&amp; 
                </span><span class="s0">// Support: IE &lt; 9, Android &lt; 4.0</span><span class="s1"> 
                src.returnValue === </span><span class="s2">false </span><span class="s1">? 
            returnTrue : 
            returnFalse</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Event type</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        </span><span class="s2">this</span><span class="s1">.type = src</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Put explicitly provided properties onto the event object</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( props ) { 
        jQuery.extend( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">props )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Create a timestamp if incoming event doesn't have one</span><span class="s1"> 
    </span><span class="s2">this</span><span class="s1">.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Mark it as fixed</span><span class="s1"> 
    </span><span class="s2">this</span><span class="s1">[ jQuery.expando ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding</span><span class="s1"> 
</span><span class="s0">// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</span><span class="s1"> 
jQuery.Event.prototype = { 
    isDefaultPrevented: returnFalse</span><span class="s3">,</span><span class="s1"> 
    isPropagationStopped: returnFalse</span><span class="s3">,</span><span class="s1"> 
    isImmediatePropagationStopped: returnFalse</span><span class="s3">,</span><span class="s1"> 
 
    preventDefault: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">this</span><span class="s1">.isDefaultPrevented = returnTrue</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !e ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// If preventDefault exists, run it on the original event</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( e.preventDefault ) { 
            e.preventDefault()</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Support: IE</span><span class="s1"> 
        </span><span class="s0">// Otherwise set the returnValue property of the original event to false</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            e.returnValue = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
    stopPropagation: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">this</span><span class="s1">.isPropagationStopped = returnTrue</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !e ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s0">// If stopPropagation exists, run it on the original event</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( e.stopPropagation ) { 
            e.stopPropagation()</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE</span><span class="s1"> 
        </span><span class="s0">// Set the cancelBubble property of the original event to true</span><span class="s1"> 
        e.cancelBubble = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    stopImmediatePropagation: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">this</span><span class="s1">.isImmediatePropagationStopped = returnTrue</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( e &amp;&amp; e.stopImmediatePropagation ) { 
            e.stopImmediatePropagation()</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">this</span><span class="s1">.stopPropagation()</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Create mouseenter/leave events using mouseover/out and event-time checks</span><span class="s1"> 
jQuery.each({ 
    mouseenter: </span><span class="s4">&quot;mouseover&quot;</span><span class="s3">,</span><span class="s1"> 
    mouseleave: </span><span class="s4">&quot;mouseout&quot;</span><span class="s3">,</span><span class="s1"> 
    pointerenter: </span><span class="s4">&quot;pointerover&quot;</span><span class="s3">,</span><span class="s1"> 
    pointerleave: </span><span class="s4">&quot;pointerout&quot;</span><span class="s1"> 
}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( orig</span><span class="s3">, </span><span class="s1">fix ) { 
    jQuery.event.special[ orig ] = { 
        delegateType: fix</span><span class="s3">,</span><span class="s1"> 
        bindType: fix</span><span class="s3">,</span><span class="s1"> 
 
        handle: </span><span class="s2">function</span><span class="s1">( event ) { 
            </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">,</span><span class="s1"> 
                target = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
                related = event.relatedTarget</span><span class="s3">,</span><span class="s1"> 
                handleObj = event.handleObj</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// For mousenter/leave call the handler if related is outside the target.</span><span class="s1"> 
            </span><span class="s0">// NB: No relatedTarget if the mouse left/entered the browser window</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !related || (related !== target &amp;&amp; !jQuery.contains( target</span><span class="s3">, </span><span class="s1">related )) ) { 
                event.type = handleObj.origType</span><span class="s3">;</span><span class="s1"> 
                ret = handleObj.handler.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
                event.type = fix</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// IE submit delegation</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.submitBubbles ) { 
 
    jQuery.event.special.submit = { 
        setup: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// Only need this for delegated form submit events</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;form&quot; </span><span class="s1">) ) { 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Lazy-add a submit handler when a descendant form may potentially be submitted</span><span class="s1"> 
            jQuery.event.add( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;click._submit keypress._submit&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( e ) { 
                </span><span class="s0">// Node name check avoids a VML-related crash in IE (#9807)</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">elem = e.target</span><span class="s3">,</span><span class="s1"> 
                    form = jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;input&quot; </span><span class="s1">) || jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;button&quot; </span><span class="s1">) ? elem.form : undefined</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( form &amp;&amp; !jQuery._data( form</span><span class="s3">, </span><span class="s4">&quot;submitBubbles&quot; </span><span class="s1">) ) { 
                    jQuery.event.add( form</span><span class="s3">, </span><span class="s4">&quot;submit._submit&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( event ) { 
                        event._submit_bubble = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
                    })</span><span class="s3">;</span><span class="s1"> 
                    jQuery._data( form</span><span class="s3">, </span><span class="s4">&quot;submitBubbles&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            })</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// return undefined since we don't need an event listener</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        postDispatch: </span><span class="s2">function</span><span class="s1">( event ) { 
            </span><span class="s0">// If form was submitted by the user, bubble the event up the tree</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( event._submit_bubble ) { 
                </span><span class="s2">delete </span><span class="s1">event._submit_bubble</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode &amp;&amp; !event.isTrigger ) { 
                    jQuery.event.simulate( </span><span class="s4">&quot;submit&quot;</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.parentNode</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
 
        teardown: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// Only need this for delegated form submit events</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;form&quot; </span><span class="s1">) ) { 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Remove delegated handlers; cleanData eventually reaps submit handlers attached above</span><span class="s1"> 
            jQuery.event.remove( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;._submit&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// IE change delegation and checkbox/radio fix</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.changeBubbles ) { 
 
    jQuery.event.special.change = { 
 
        setup: </span><span class="s2">function</span><span class="s1">() { 
 
            </span><span class="s2">if </span><span class="s1">( rformElems.test( </span><span class="s2">this</span><span class="s1">.nodeName ) ) { 
                </span><span class="s0">// IE doesn't fire change on a check/radio until blur; trigger it on click</span><span class="s1"> 
                </span><span class="s0">// after a propertychange. Eat the blur-change in special.change.handle.</span><span class="s1"> 
                </span><span class="s0">// This still fires onchange a second time for check/radio after blur.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.type === </span><span class="s4">&quot;checkbox&quot; </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.type === </span><span class="s4">&quot;radio&quot; </span><span class="s1">) { 
                    jQuery.event.add( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;propertychange._change&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( event ) { 
                        </span><span class="s2">if </span><span class="s1">( event.originalEvent.propertyName === </span><span class="s4">&quot;checked&quot; </span><span class="s1">) { 
                            </span><span class="s2">this</span><span class="s1">._just_changed = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
                        } 
                    })</span><span class="s3">;</span><span class="s1"> 
                    jQuery.event.add( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;click._change&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( event ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">._just_changed &amp;&amp; !event.isTrigger ) { 
                            </span><span class="s2">this</span><span class="s1">._just_changed = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                        } 
                        </span><span class="s0">// Allow triggered, simulated change events (#11500)</span><span class="s1"> 
                        jQuery.event.simulate( </span><span class="s4">&quot;change&quot;</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    })</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s0">// Delegated event; lazy-add a change handler on descendant inputs</span><span class="s1"> 
            jQuery.event.add( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;beforeactivate._change&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( e ) { 
                </span><span class="s2">var </span><span class="s1">elem = e.target</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( rformElems.test( elem.nodeName ) &amp;&amp; !jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;changeBubbles&quot; </span><span class="s1">) ) { 
                    jQuery.event.add( elem</span><span class="s3">, </span><span class="s4">&quot;change._change&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( event ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode &amp;&amp; !event.isSimulated &amp;&amp; !event.isTrigger ) { 
                            jQuery.event.simulate( </span><span class="s4">&quot;change&quot;</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.parentNode</span><span class="s3">, </span><span class="s1">event</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } 
                    })</span><span class="s3">;</span><span class="s1"> 
                    jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;changeBubbles&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            })</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        handle: </span><span class="s2">function</span><span class="s1">( event ) { 
            </span><span class="s2">var </span><span class="s1">elem = event.target</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Swallow native change events from checkbox/radio, we already triggered them above</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this </span><span class="s1">!== elem || event.isSimulated || event.isTrigger || (elem.type !== </span><span class="s4">&quot;radio&quot; </span><span class="s1">&amp;&amp; elem.type !== </span><span class="s4">&quot;checkbox&quot;</span><span class="s1">) ) { 
                </span><span class="s2">return </span><span class="s1">event.handleObj.handler.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
 
        teardown: </span><span class="s2">function</span><span class="s1">() { 
            jQuery.event.remove( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;._change&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">!rformElems.test( </span><span class="s2">this</span><span class="s1">.nodeName )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Create &quot;bubbling&quot; focus and blur events</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.focusinBubbles ) { 
    jQuery.each({ focus: </span><span class="s4">&quot;focusin&quot;</span><span class="s3">, </span><span class="s1">blur: </span><span class="s4">&quot;focusout&quot; </span><span class="s1">}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( orig</span><span class="s3">, </span><span class="s1">fix ) { 
 
        </span><span class="s0">// Attach a single capturing handler on the document while someone wants focusin/focusout</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">handler = </span><span class="s2">function</span><span class="s1">( event ) { 
                jQuery.event.simulate( fix</span><span class="s3">, </span><span class="s1">event.target</span><span class="s3">, </span><span class="s1">jQuery.event.fix( event )</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
 
        jQuery.event.special[ fix ] = { 
            setup: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">doc = </span><span class="s2">this</span><span class="s1">.ownerDocument || </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
                    attaches = jQuery._data( doc</span><span class="s3">, </span><span class="s1">fix )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( !attaches ) { 
                    doc.addEventListener( orig</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
                jQuery._data( doc</span><span class="s3">, </span><span class="s1">fix</span><span class="s3">, </span><span class="s1">( attaches || </span><span class="s5">0 </span><span class="s1">) + </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            teardown: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">doc = </span><span class="s2">this</span><span class="s1">.ownerDocument || </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
                    attaches = jQuery._data( doc</span><span class="s3">, </span><span class="s1">fix ) - </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( !attaches ) { 
                    doc.removeEventListener( orig</span><span class="s3">, </span><span class="s1">handler</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    jQuery._removeData( doc</span><span class="s3">, </span><span class="s1">fix )</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    jQuery._data( doc</span><span class="s3">, </span><span class="s1">fix</span><span class="s3">, </span><span class="s1">attaches )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.fn.extend({ 
 
    on: </span><span class="s2">function</span><span class="s1">( types</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s0">/*INTERNAL*/ </span><span class="s1">one ) { 
        </span><span class="s2">var </span><span class="s1">type</span><span class="s3">, </span><span class="s1">origFn</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Types can be a map of types/handlers</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">types === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
            </span><span class="s0">// ( types-Object, selector, data )</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s0">// ( types-Object, data )</span><span class="s1"> 
                data = data || selector</span><span class="s3">;</span><span class="s1"> 
                selector = undefined</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">types ) { 
                </span><span class="s2">this</span><span class="s1">.on( type</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">types[ type ]</span><span class="s3">, </span><span class="s1">one )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( data == </span><span class="s2">null </span><span class="s1">&amp;&amp; fn == </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s0">// ( types, fn )</span><span class="s1"> 
            fn = selector</span><span class="s3">;</span><span class="s1"> 
            data = selector = undefined</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( fn == </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s0">// ( types, selector, fn )</span><span class="s1"> 
                fn = data</span><span class="s3">;</span><span class="s1"> 
                data = undefined</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s0">// ( types, data, fn )</span><span class="s1"> 
                fn = data</span><span class="s3">;</span><span class="s1"> 
                data = selector</span><span class="s3">;</span><span class="s1"> 
                selector = undefined</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
        </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s2">false </span><span class="s1">) { 
            fn = returnFalse</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( !fn ) { 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( one === </span><span class="s5">1 </span><span class="s1">) { 
            origFn = fn</span><span class="s3">;</span><span class="s1"> 
            fn = </span><span class="s2">function</span><span class="s1">( event ) { 
                </span><span class="s0">// Can use an empty set, since event contains the info</span><span class="s1"> 
                jQuery().off( event )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">origFn.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Use same guid so caller can remove using origFn</span><span class="s1"> 
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ )</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
            jQuery.event.add( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">selector )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    one: </span><span class="s2">function</span><span class="s1">( types</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">return this</span><span class="s1">.on( types</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    off: </span><span class="s2">function</span><span class="s1">( types</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">var </span><span class="s1">handleObj</span><span class="s3">, </span><span class="s1">type</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) { 
            </span><span class="s0">// ( event )  dispatched jQuery.Event</span><span class="s1"> 
            handleObj = types.handleObj</span><span class="s3">;</span><span class="s1"> 
            jQuery( types.delegateTarget ).off( 
                handleObj.namespace ? handleObj.origType + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ handleObj.namespace : handleObj.origType</span><span class="s3">,</span><span class="s1"> 
                handleObj.selector</span><span class="s3">,</span><span class="s1"> 
                handleObj.handler 
            )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">types === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
            </span><span class="s0">// ( types-object [, selector] )</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">types ) { 
                </span><span class="s2">this</span><span class="s1">.off( type</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">types[ type ] )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( selector === </span><span class="s2">false </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s4">&quot;function&quot; </span><span class="s1">) { 
            </span><span class="s0">// ( types [, fn] )</span><span class="s1"> 
            fn = selector</span><span class="s3">;</span><span class="s1"> 
            selector = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s2">false </span><span class="s1">) { 
            fn = returnFalse</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            jQuery.event.remove( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">selector )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    trigger: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            jQuery.event.trigger( type</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    triggerHandler: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">data ) { 
        </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.event.trigger( type</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">function </span><span class="s1">createSafeFragment( document ) { 
    </span><span class="s2">var </span><span class="s1">list = nodeNames.split( </span><span class="s4">&quot;|&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        safeFrag = document.createDocumentFragment()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( safeFrag.createElement ) { 
        </span><span class="s2">while </span><span class="s1">( list.length ) { 
            safeFrag.createElement( 
                list.pop() 
            )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
    </span><span class="s2">return </span><span class="s1">safeFrag</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">var </span><span class="s1">nodeNames = </span><span class="s4">&quot;abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|&quot; </span><span class="s1">+ 
        </span><span class="s4">&quot;header|hgroup|mark|meter|nav|output|progress|section|summary|time|video&quot;</span><span class="s3">,</span><span class="s1"> 
    rinlinejQuery = </span><span class="s4">/ jQuery\d+=&quot;(?:null|\d+)&quot;/g</span><span class="s3">,</span><span class="s1"> 
    rnoshimcache = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s4">&quot;&lt;(?:&quot; </span><span class="s1">+ nodeNames + </span><span class="s4">&quot;)[</span><span class="s3">\\</span><span class="s4">s/&gt;]&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    rleadingWhitespace = </span><span class="s4">/^\s+/</span><span class="s3">,</span><span class="s1"> 
    rxhtmlTag = </span><span class="s4">/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi</span><span class="s3">,</span><span class="s1"> 
    rtagName = </span><span class="s4">/&lt;([\w:]+)/</span><span class="s3">,</span><span class="s1"> 
    rtbody = </span><span class="s4">/&lt;tbody/i</span><span class="s3">,</span><span class="s1"> 
    rhtml = </span><span class="s4">/&lt;|&amp;#?\w+;/</span><span class="s3">,</span><span class="s1"> 
    rnoInnerhtml = </span><span class="s4">/&lt;(?:script|style|link)/i</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// checked=&quot;checked&quot; or checked</span><span class="s1"> 
    rchecked = </span><span class="s4">/checked\s*(?:[^=]|=\s*.checked.)/i</span><span class="s3">,</span><span class="s1"> 
    rscriptType = </span><span class="s4">/^$|\/(?:java|ecma)script/i</span><span class="s3">,</span><span class="s1"> 
    rscriptTypeMasked = </span><span class="s4">/^true\/(.*)/</span><span class="s3">,</span><span class="s1"> 
    rcleanScript = </span><span class="s4">/^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// We have to close these tags to support XHTML (#13200)</span><span class="s1"> 
    wrapMap = { 
        option: [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;&lt;select multiple='multiple'&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/select&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        legend: [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;&lt;fieldset&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/fieldset&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        area: [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;&lt;map&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/map&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        param: [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;&lt;object&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/object&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        thead: [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;&lt;table&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/table&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        tr: [ </span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;&lt;table&gt;&lt;tbody&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/tbody&gt;&lt;/table&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        col: [ </span><span class="s5">2</span><span class="s3">, </span><span class="s4">&quot;&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
        td: [ </span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,</span><span class="s1"> 
        </span><span class="s0">// unless wrapped in a div with non-breaking characters in front of it.</span><span class="s1"> 
        _default: support.htmlSerialize ? [ </span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">] : [ </span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;X&lt;div&gt;&quot;</span><span class="s3">, </span><span class="s4">&quot;&lt;/div&gt;&quot;  </span><span class="s1">] 
    }</span><span class="s3">,</span><span class="s1"> 
    safeFragment = createSafeFragment( document )</span><span class="s3">,</span><span class="s1"> 
    fragmentDiv = safeFragment.appendChild( document.createElement(</span><span class="s4">&quot;div&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
wrapMap.optgroup = wrapMap.option</span><span class="s3">;</span><span class="s1"> 
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead</span><span class="s3">;</span><span class="s1"> 
wrapMap.th = wrapMap.td</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">getAll( context</span><span class="s3">, </span><span class="s1">tag ) { 
    </span><span class="s2">var </span><span class="s1">elems</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        found = </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || </span><span class="s4">&quot;*&quot; </span><span class="s1">) : 
            </span><span class="s2">typeof </span><span class="s1">context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || </span><span class="s4">&quot;*&quot; </span><span class="s1">) : 
            undefined</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( !found ) { 
        </span><span class="s2">for </span><span class="s1">( found = []</span><span class="s3">, </span><span class="s1">elems = context.childNodes || context</span><span class="s3">; </span><span class="s1">(elem = elems[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s2">if </span><span class="s1">( !tag || jQuery.nodeName( elem</span><span class="s3">, </span><span class="s1">tag ) ) { 
                found.push( elem )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                jQuery.merge( found</span><span class="s3">, </span><span class="s1">getAll( elem</span><span class="s3">, </span><span class="s1">tag ) )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">tag === undefined || tag &amp;&amp; jQuery.nodeName( context</span><span class="s3">, </span><span class="s1">tag ) ? 
        jQuery.merge( [ context ]</span><span class="s3">, </span><span class="s1">found ) : 
        found</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Used in buildFragment, fixes the defaultChecked property</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">fixDefaultChecked( elem ) { 
    </span><span class="s2">if </span><span class="s1">( rcheckableType.test( elem.type ) ) { 
        elem.defaultChecked = elem.checked</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
</span><span class="s0">// Manipulating tables requires a tbody</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">manipulationTarget( elem</span><span class="s3">, </span><span class="s1">content ) { 
    </span><span class="s2">return </span><span class="s1">jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;table&quot; </span><span class="s1">) &amp;&amp; 
        jQuery.nodeName( content.nodeType !== </span><span class="s5">11 </span><span class="s1">? content : content.firstChild</span><span class="s3">, </span><span class="s4">&quot;tr&quot; </span><span class="s1">) ? 
 
        elem.getElementsByTagName(</span><span class="s4">&quot;tbody&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] || 
            elem.appendChild( elem.ownerDocument.createElement(</span><span class="s4">&quot;tbody&quot;</span><span class="s1">) ) : 
        elem</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Replace/restore the type attribute of script elements for safe DOM manipulation</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">disableScript( elem ) { 
    elem.type = (jQuery.find.attr( elem</span><span class="s3">, </span><span class="s4">&quot;type&quot; </span><span class="s1">) !== </span><span class="s2">null</span><span class="s1">) + </span><span class="s4">&quot;/&quot; </span><span class="s1">+ elem.type</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">elem</span><span class="s3">;</span><span class="s1"> 
} 
</span><span class="s2">function </span><span class="s1">restoreScript( elem ) { 
    </span><span class="s2">var </span><span class="s1">match = rscriptTypeMasked.exec( elem.type )</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( match ) { 
        elem.type = match[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        elem.removeAttribute(</span><span class="s4">&quot;type&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">elem</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Mark scripts as having already been evaluated</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">setGlobalEval( elems</span><span class="s3">, </span><span class="s1">refElements ) { 
    </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">(elem = elems[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
        jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;globalEval&quot;</span><span class="s3">, </span><span class="s1">!refElements || jQuery._data( refElements[i]</span><span class="s3">, </span><span class="s4">&quot;globalEval&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s2">function </span><span class="s1">cloneCopyEvent( src</span><span class="s3">, </span><span class="s1">dest ) { 
 
    </span><span class="s2">if </span><span class="s1">( dest.nodeType !== </span><span class="s5">1 </span><span class="s1">|| !jQuery.hasData( src ) ) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">type</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">,</span><span class="s1"> 
        oldData = jQuery._data( src )</span><span class="s3">,</span><span class="s1"> 
        curData = jQuery._data( dest</span><span class="s3">, </span><span class="s1">oldData )</span><span class="s3">,</span><span class="s1"> 
        events = oldData.events</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( events ) { 
        </span><span class="s2">delete </span><span class="s1">curData.handle</span><span class="s3">;</span><span class="s1"> 
        curData.events = {}</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">events ) { 
            </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">l = events[ type ].length</span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
                jQuery.event.add( dest</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">events[ type ][ i ] )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s0">// make the cloned public data object a copy from the original</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( curData.data ) { 
        curData.data = jQuery.extend( {}</span><span class="s3">, </span><span class="s1">curData.data )</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s2">function </span><span class="s1">fixCloneNodeIssues( src</span><span class="s3">, </span><span class="s1">dest ) { 
    </span><span class="s2">var </span><span class="s1">nodeName</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">data</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// We do not need to do anything for non-Elements</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( dest.nodeType !== </span><span class="s5">1 </span><span class="s1">) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    nodeName = dest.nodeName.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// IE6-8 copies events bound via attachEvent when using cloneNode.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !support.noCloneEvent &amp;&amp; dest[ jQuery.expando ] ) { 
        data = jQuery._data( dest )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( e </span><span class="s2">in </span><span class="s1">data.events ) { 
            jQuery.removeEvent( dest</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">data.handle )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Event data gets referenced instead of copied if the expando gets copied too</span><span class="s1"> 
        dest.removeAttribute( jQuery.expando )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// IE blanks contents when cloning scripts, and tries to evaluate newly-set text</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( nodeName === </span><span class="s4">&quot;script&quot; </span><span class="s1">&amp;&amp; dest.text !== src.text ) { 
        disableScript( dest ).text = src.text</span><span class="s3">;</span><span class="s1"> 
        restoreScript( dest )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// IE6-10 improperly clones children of object elements using classid.</span><span class="s1"> 
    </span><span class="s0">// IE10 throws NoModificationAllowedError if parent is null, #12132.</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( nodeName === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
        </span><span class="s2">if </span><span class="s1">( dest.parentNode ) { 
            dest.outerHTML = src.outerHTML</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// This path appears unavoidable for IE9. When cloning an object</span><span class="s1"> 
        </span><span class="s0">// element in IE9, the outerHTML strategy above is not sufficient.</span><span class="s1"> 
        </span><span class="s0">// If the datepicker has innerHTML and the destination does not,</span><span class="s1"> 
        </span><span class="s0">// copy the datepicker.innerHTML into the dest.innerHTML. #10324</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( support.html5Clone &amp;&amp; ( src.innerHTML &amp;&amp; !jQuery.trim(dest.innerHTML) ) ) { 
            dest.innerHTML = src.innerHTML</span><span class="s3">;</span><span class="s1"> 
        } 
 
    } </span><span class="s2">else if </span><span class="s1">( nodeName === </span><span class="s4">&quot;input&quot; </span><span class="s1">&amp;&amp; rcheckableType.test( src.type ) ) { 
        </span><span class="s0">// IE6-8 fails to persist the checked state of a cloned checkbox</span><span class="s1"> 
        </span><span class="s0">// or radio button. Worse, IE6-7 fail to give the cloned element</span><span class="s1"> 
        </span><span class="s0">// a checked appearance if the defaultChecked value isn't also set</span><span class="s1"> 
 
        dest.defaultChecked = dest.checked = src.checked</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// IE6-7 get confused and end up setting the value of a cloned</span><span class="s1"> 
        </span><span class="s0">// checkbox/radio button to an empty string instead of &quot;on&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dest.value !== src.value ) { 
            dest.value = src.value</span><span class="s3">;</span><span class="s1"> 
        } 
 
    </span><span class="s0">// IE6-8 fails to return the selected option to the default selected</span><span class="s1"> 
    </span><span class="s0">// state when cloning options</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( nodeName === </span><span class="s4">&quot;option&quot; </span><span class="s1">) { 
        dest.defaultSelected = dest.selected = src.defaultSelected</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// IE6-8 fails to set the defaultValue to the correct value when</span><span class="s1"> 
    </span><span class="s0">// cloning other types of input fields</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( nodeName === </span><span class="s4">&quot;input&quot; </span><span class="s1">|| nodeName === </span><span class="s4">&quot;textarea&quot; </span><span class="s1">) { 
        dest.defaultValue = src.defaultValue</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
jQuery.extend({ 
    clone: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">dataAndEvents</span><span class="s3">, </span><span class="s1">deepDataAndEvents ) { 
        </span><span class="s2">var </span><span class="s1">destElements</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">clone</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">srcElements</span><span class="s3">,</span><span class="s1"> 
            inPage = jQuery.contains( elem.ownerDocument</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( </span><span class="s4">&quot;&lt;&quot; </span><span class="s1">+ elem.nodeName + </span><span class="s4">&quot;&gt;&quot; </span><span class="s1">) ) { 
            clone = elem.cloneNode( </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// IE&lt;=8 does not properly clone detached, unknown element nodes</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            fragmentDiv.innerHTML = elem.outerHTML</span><span class="s3">;</span><span class="s1"> 
            fragmentDiv.removeChild( clone = fragmentDiv.firstChild )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( (!support.noCloneEvent || !support.noCloneChecked) &amp;&amp; 
                (elem.nodeType === </span><span class="s5">1 </span><span class="s1">|| elem.nodeType === </span><span class="s5">11</span><span class="s1">) &amp;&amp; !jQuery.isXMLDoc(elem) ) { 
 
            </span><span class="s0">// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2</span><span class="s1"> 
            destElements = getAll( clone )</span><span class="s3">;</span><span class="s1"> 
            srcElements = getAll( elem )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Fix all IE cloning issues</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">(node = srcElements[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">++i ) { 
                </span><span class="s0">// Ensure that the destination node is not null; Fixes #9587</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( destElements[i] ) { 
                    fixCloneNodeIssues( node</span><span class="s3">, </span><span class="s1">destElements[i] )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s0">// Copy the events from the original to the clone</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dataAndEvents ) { 
            </span><span class="s2">if </span><span class="s1">( deepDataAndEvents ) { 
                srcElements = srcElements || getAll( elem )</span><span class="s3">;</span><span class="s1"> 
                destElements = destElements || getAll( clone )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">(node = srcElements[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
                    cloneCopyEvent( node</span><span class="s3">, </span><span class="s1">destElements[i] )</span><span class="s3">;</span><span class="s1"> 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                cloneCopyEvent( elem</span><span class="s3">, </span><span class="s1">clone )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Preserve script evaluation history</span><span class="s1"> 
        destElements = getAll( clone</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( destElements.length &gt; </span><span class="s5">0 </span><span class="s1">) { 
            setGlobalEval( destElements</span><span class="s3">, </span><span class="s1">!inPage &amp;&amp; getAll( elem</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        destElements = srcElements = node = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Return the cloned set</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">clone</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    buildFragment: </span><span class="s2">function</span><span class="s1">( elems</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">scripts</span><span class="s3">, </span><span class="s1">selection ) { 
        </span><span class="s2">var </span><span class="s1">j</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">contains</span><span class="s3">,</span><span class="s1"> 
            tmp</span><span class="s3">, </span><span class="s1">tag</span><span class="s3">, </span><span class="s1">tbody</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">,</span><span class="s1"> 
            l = elems.length</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Ensure a safe fragment</span><span class="s1"> 
            safe = createSafeFragment( context )</span><span class="s3">,</span><span class="s1"> 
 
            nodes = []</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
            elem = elems[ i ]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( elem || elem === </span><span class="s5">0 </span><span class="s1">) { 
 
                </span><span class="s0">// Add nodes directly</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( jQuery.type( elem ) === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
                    jQuery.merge( nodes</span><span class="s3">, </span><span class="s1">elem.nodeType ? [ elem ] : elem )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Convert non-html into a text node</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( !rhtml.test( elem ) ) { 
                    nodes.push( context.createTextNode( elem ) )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Convert html into DOM nodes</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    tmp = tmp || safe.appendChild( context.createElement(</span><span class="s4">&quot;div&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Deserialize a standard representation</span><span class="s1"> 
                    tag = (rtagName.exec( elem ) || [ </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">])[ </span><span class="s5">1 </span><span class="s1">].toLowerCase()</span><span class="s3">;</span><span class="s1"> 
                    wrap = wrapMap[ tag ] || wrapMap._default</span><span class="s3">;</span><span class="s1"> 
 
                    tmp.innerHTML = wrap[</span><span class="s5">1</span><span class="s1">] + elem.replace( rxhtmlTag</span><span class="s3">, </span><span class="s4">&quot;&lt;$1&gt;&lt;/$2&gt;&quot; </span><span class="s1">) + wrap[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Descend through wrappers to the right content</span><span class="s1"> 
                    j = wrap[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( j-- ) { 
                        tmp = tmp.lastChild</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Manually add leading whitespace removed by IE</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) { 
                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[</span><span class="s5">0</span><span class="s1">] ) )</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Remove IE's autoinserted &lt;tbody&gt; from table fragments</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !support.tbody ) { 
 
                        </span><span class="s0">// String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt;</span><span class="s1"> 
                        elem = tag === </span><span class="s4">&quot;table&quot; </span><span class="s1">&amp;&amp; !rtbody.test( elem ) ? 
                            tmp.firstChild : 
 
                            </span><span class="s0">// String was a bare &lt;thead&gt; or &lt;tfoot&gt;</span><span class="s1"> 
                            wrap[</span><span class="s5">1</span><span class="s1">] === </span><span class="s4">&quot;&lt;table&gt;&quot; </span><span class="s1">&amp;&amp; !rtbody.test( elem ) ? 
                                tmp : 
                                </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
                        j = elem &amp;&amp; elem.childNodes.length</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( j-- ) { 
                            </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( (tbody = elem.childNodes[j])</span><span class="s3">, </span><span class="s4">&quot;tbody&quot; </span><span class="s1">) &amp;&amp; !tbody.childNodes.length ) { 
                                elem.removeChild( tbody )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
 
                    jQuery.merge( nodes</span><span class="s3">, </span><span class="s1">tmp.childNodes )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Fix #12392 for WebKit and IE &gt; 9</span><span class="s1"> 
                    tmp.textContent = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Fix #12392 for oldIE</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( tmp.firstChild ) { 
                        tmp.removeChild( tmp.firstChild )</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Remember the top-level container for proper cleanup</span><span class="s1"> 
                    tmp = safe.lastChild</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s0">// Fix #11356: Clear elements from fragment</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( tmp ) { 
            safe.removeChild( tmp )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Reset defaultChecked for any radios and checkboxes</span><span class="s1"> 
        </span><span class="s0">// about to be appended to the DOM in IE 6/7 (#8060)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !support.appendChecked ) { 
            jQuery.grep( getAll( nodes</span><span class="s3">, </span><span class="s4">&quot;input&quot; </span><span class="s1">)</span><span class="s3">, </span><span class="s1">fixDefaultChecked )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( (elem = nodes[ i++ ]) ) { 
 
            </span><span class="s0">// #4087 - If origin and destination elements are the same, and this is</span><span class="s1"> 
            </span><span class="s0">// that element, do not do anything</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( selection &amp;&amp; jQuery.inArray( elem</span><span class="s3">, </span><span class="s1">selection ) !== -</span><span class="s5">1 </span><span class="s1">) { 
                </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
            } 
 
            contains = jQuery.contains( elem.ownerDocument</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Append to fragment</span><span class="s1"> 
            tmp = getAll( safe.appendChild( elem )</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Preserve script evaluation history</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( contains ) { 
                setGlobalEval( tmp )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Capture executables</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( scripts ) { 
                j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">while </span><span class="s1">( (elem = tmp[ j++ ]) ) { 
                    </span><span class="s2">if </span><span class="s1">( rscriptType.test( elem.type || </span><span class="s4">&quot;&quot; </span><span class="s1">) ) { 
                        scripts.push( elem )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        tmp = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">safe</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    cleanData: </span><span class="s2">function</span><span class="s1">( elems</span><span class="s3">, </span><span class="s0">/* internal */ </span><span class="s1">acceptData ) { 
        </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">id</span><span class="s3">, </span><span class="s1">data</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            internalKey = jQuery.expando</span><span class="s3">,</span><span class="s1"> 
            cache = jQuery.cache</span><span class="s3">,</span><span class="s1"> 
            deleteExpando = support.deleteExpando</span><span class="s3">,</span><span class="s1"> 
            special = jQuery.event.special</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">(elem = elems[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s2">if </span><span class="s1">( acceptData || jQuery.acceptData( elem ) ) { 
 
                id = elem[ internalKey ]</span><span class="s3">;</span><span class="s1"> 
                data = id &amp;&amp; cache[ id ]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( data ) { 
                    </span><span class="s2">if </span><span class="s1">( data.events ) { 
                        </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">data.events ) { 
                            </span><span class="s2">if </span><span class="s1">( special[ type ] ) { 
                                jQuery.event.remove( elem</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
 
                            </span><span class="s0">// This is a shortcut to avoid jQuery.event.remove's overhead</span><span class="s1"> 
                            } </span><span class="s2">else </span><span class="s1">{ 
                                jQuery.removeEvent( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">data.handle )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
 
                    </span><span class="s0">// Remove cache only if it was not already removed by jQuery.event.remove</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( cache[ id ] ) { 
 
                        </span><span class="s2">delete </span><span class="s1">cache[ id ]</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// IE does not allow us to delete expando properties from nodes,</span><span class="s1"> 
                        </span><span class="s0">// nor does it have a removeAttribute function on Document nodes;</span><span class="s1"> 
                        </span><span class="s0">// we must handle all of these cases</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( deleteExpando ) { 
                            </span><span class="s2">delete </span><span class="s1">elem[ internalKey ]</span><span class="s3">;</span><span class="s1"> 
 
                        } </span><span class="s2">else if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.removeAttribute !== strundefined ) { 
                            elem.removeAttribute( internalKey )</span><span class="s3">;</span><span class="s1"> 
 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            elem[ internalKey ] = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        deletedIds.push( id )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    text: </span><span class="s2">function</span><span class="s1">( value ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">return </span><span class="s1">value === undefined ? 
                jQuery.text( </span><span class="s2">this </span><span class="s1">) : 
                </span><span class="s2">this</span><span class="s1">.empty().append( ( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] &amp;&amp; </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">].ownerDocument || document ).createTextNode( value ) )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">arguments.length )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    append: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.domManip( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">11 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">9 </span><span class="s1">) { 
                </span><span class="s2">var </span><span class="s1">target = manipulationTarget( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
                target.appendChild( elem )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    prepend: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.domManip( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">11 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s5">9 </span><span class="s1">) { 
                </span><span class="s2">var </span><span class="s1">target = manipulationTarget( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">elem )</span><span class="s3">;</span><span class="s1"> 
                target.insertBefore( elem</span><span class="s3">, </span><span class="s1">target.firstChild )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    before: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.domManip( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode ) { 
                </span><span class="s2">this</span><span class="s1">.parentNode.insertBefore( elem</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    after: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.domManip( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode ) { 
                </span><span class="s2">this</span><span class="s1">.parentNode.insertBefore( elem</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.nextSibling )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    remove: </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">keepData </span><span class="s0">/* Internal Use Only */ </span><span class="s1">) { 
        </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
            elems = selector ? jQuery.filter( selector</span><span class="s3">, </span><span class="s2">this </span><span class="s1">) : </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">(elem = elems[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
 
            </span><span class="s2">if </span><span class="s1">( !keepData &amp;&amp; elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                jQuery.cleanData( getAll( elem ) )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( elem.parentNode ) { 
                </span><span class="s2">if </span><span class="s1">( keepData &amp;&amp; jQuery.contains( elem.ownerDocument</span><span class="s3">, </span><span class="s1">elem ) ) { 
                    setGlobalEval( getAll( elem</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                } 
                elem.parentNode.removeChild( elem )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    empty: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">elem</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">(elem = </span><span class="s2">this</span><span class="s1">[i]) != </span><span class="s2">null</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s0">// Remove element nodes and prevent memory leaks</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                jQuery.cleanData( getAll( elem</span><span class="s3">, </span><span class="s2">false </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Remove any remaining nodes</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( elem.firstChild ) { 
                elem.removeChild( elem.firstChild )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// If this is a select, ensure that it displays empty (#12336)</span><span class="s1"> 
            </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( elem.options &amp;&amp; jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;select&quot; </span><span class="s1">) ) { 
                elem.options.length = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    clone: </span><span class="s2">function</span><span class="s1">( dataAndEvents</span><span class="s3">, </span><span class="s1">deepDataAndEvents ) { 
        dataAndEvents = dataAndEvents == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: dataAndEvents</span><span class="s3">;</span><span class="s1"> 
        deepDataAndEvents = deepDataAndEvents == </span><span class="s2">null </span><span class="s1">? dataAndEvents : deepDataAndEvents</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return this</span><span class="s1">.map(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">jQuery.clone( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">dataAndEvents</span><span class="s3">, </span><span class="s1">deepDataAndEvents )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    html: </span><span class="s2">function</span><span class="s1">( value ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">] || {}</span><span class="s3">,</span><span class="s1"> 
                i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( value === undefined ) { 
                </span><span class="s2">return </span><span class="s1">elem.nodeType === </span><span class="s5">1 </span><span class="s1">? 
                    elem.innerHTML.replace( rinlinejQuery</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">) : 
                    undefined</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// See if we can take a shortcut and just use innerHTML</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp; 
                ( support.htmlSerialize || !rnoshimcache.test( value )  ) &amp;&amp; 
                ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp; 
                !wrapMap[ (rtagName.exec( value ) || [ </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">])[ </span><span class="s5">1 </span><span class="s1">].toLowerCase() ] ) { 
 
                value = value.replace( rxhtmlTag</span><span class="s3">, </span><span class="s4">&quot;&lt;$1&gt;&lt;/$2&gt;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">try </span><span class="s1">{ 
                    </span><span class="s2">for </span><span class="s1">(</span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
                        </span><span class="s0">// Remove element nodes and prevent memory leaks</span><span class="s1"> 
                        elem = </span><span class="s2">this</span><span class="s1">[i] || {}</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                            jQuery.cleanData( getAll( elem</span><span class="s3">, </span><span class="s2">false </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                            elem.innerHTML = value</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    elem = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// If using innerHTML throws an exception, use the fallback method</span><span class="s1"> 
                } </span><span class="s2">catch</span><span class="s1">(e) {} 
            } 
 
            </span><span class="s2">if </span><span class="s1">( elem ) { 
                </span><span class="s2">this</span><span class="s1">.empty().append( value )</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">arguments.length )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    replaceWith: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">arg = arguments[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Make the changes, replacing each context element with the new content</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.domManip( arguments</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem ) { 
            arg = </span><span class="s2">this</span><span class="s1">.parentNode</span><span class="s3">;</span><span class="s1"> 
 
            jQuery.cleanData( getAll( </span><span class="s2">this </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( arg ) { 
                arg.replaceChild( elem</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Force removal if there was no new content (e.g., from empty arguments)</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">arg &amp;&amp; (arg.length || arg.nodeType) ? </span><span class="s2">this </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.remove()</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    detach: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">return this</span><span class="s1">.remove( selector</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    domManip: </span><span class="s2">function</span><span class="s1">( args</span><span class="s3">, </span><span class="s1">callback ) { 
 
        </span><span class="s0">// Flatten any nested arrays</span><span class="s1"> 
        args = concat.apply( []</span><span class="s3">, </span><span class="s1">args )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">var </span><span class="s1">first</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">hasScripts</span><span class="s3">,</span><span class="s1"> 
            scripts</span><span class="s3">, </span><span class="s1">doc</span><span class="s3">, </span><span class="s1">fragment</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            set = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
            iNoClone = l - </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
            value = args[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
            isFunction = jQuery.isFunction( value )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// We can't cloneNode fragments that contain checked, in WebKit</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( isFunction || 
                ( l &gt; </span><span class="s5">1 </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; 
                    !support.checkClone &amp;&amp; rchecked.test( value ) ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( index ) { 
                </span><span class="s2">var </span><span class="s1">self = set.eq( index )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( isFunction ) { 
                    args[</span><span class="s5">0</span><span class="s1">] = value.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">self.html() )</span><span class="s3">;</span><span class="s1"> 
                } 
                self.domManip( args</span><span class="s3">, </span><span class="s1">callback )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( l ) { 
            fragment = jQuery.buildFragment( args</span><span class="s3">, </span><span class="s2">this</span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">].ownerDocument</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            first = fragment.firstChild</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( fragment.childNodes.length === </span><span class="s5">1 </span><span class="s1">) { 
                fragment = first</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( first ) { 
                scripts = jQuery.map( getAll( fragment</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">)</span><span class="s3">, </span><span class="s1">disableScript )</span><span class="s3">;</span><span class="s1"> 
                hasScripts = scripts.length</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Use the original fragment for the last item instead of the first because it can end up</span><span class="s1"> 
                </span><span class="s0">// being emptied incorrectly in certain situations (#8070).</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
                    node = fragment</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( i !== iNoClone ) { 
                        node = jQuery.clone( node</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// Keep references to cloned scripts for later restoration</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( hasScripts ) { 
                            jQuery.merge( scripts</span><span class="s3">, </span><span class="s1">getAll( node</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    callback.call( </span><span class="s2">this</span><span class="s1">[i]</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">i )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">if </span><span class="s1">( hasScripts ) { 
                    doc = scripts[ scripts.length - </span><span class="s5">1 </span><span class="s1">].ownerDocument</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Reenable scripts</span><span class="s1"> 
                    jQuery.map( scripts</span><span class="s3">, </span><span class="s1">restoreScript )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Evaluate executable scripts on first document insertion</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; hasScripts</span><span class="s3">; </span><span class="s1">i++ ) { 
                        node = scripts[ i ]</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( rscriptType.test( node.type || </span><span class="s4">&quot;&quot; </span><span class="s1">) &amp;&amp; 
                            !jQuery._data( node</span><span class="s3">, </span><span class="s4">&quot;globalEval&quot; </span><span class="s1">) &amp;&amp; jQuery.contains( doc</span><span class="s3">, </span><span class="s1">node ) ) { 
 
                            </span><span class="s2">if </span><span class="s1">( node.src ) { 
                                </span><span class="s0">// Optional AJAX dependency, but won't run scripts if not present</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( jQuery._evalUrl ) { 
                                    jQuery._evalUrl( node.src )</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } </span><span class="s2">else </span><span class="s1">{ 
                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || </span><span class="s4">&quot;&quot; </span><span class="s1">).replace( rcleanScript</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Fix #11809: Avoid leaking memory</span><span class="s1"> 
                fragment = first = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.each({ 
    appendTo: </span><span class="s4">&quot;append&quot;</span><span class="s3">,</span><span class="s1"> 
    prependTo: </span><span class="s4">&quot;prepend&quot;</span><span class="s3">,</span><span class="s1"> 
    insertBefore: </span><span class="s4">&quot;before&quot;</span><span class="s3">,</span><span class="s1"> 
    insertAfter: </span><span class="s4">&quot;after&quot;</span><span class="s3">,</span><span class="s1"> 
    replaceAll: </span><span class="s4">&quot;replaceWith&quot;</span><span class="s1"> 
}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">original ) { 
    jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">var </span><span class="s1">elems</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            ret = []</span><span class="s3">,</span><span class="s1"> 
            insert = jQuery( selector )</span><span class="s3">,</span><span class="s1"> 
            last = insert.length - </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt;= last</span><span class="s3">; </span><span class="s1">i++ ) { 
            elems = i === last ? </span><span class="s2">this </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.clone(</span><span class="s2">true</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            jQuery( insert[i] )[ original ]( elems )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()</span><span class="s1"> 
            push.apply( ret</span><span class="s3">, </span><span class="s1">elems.get() )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.pushStack( ret )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">iframe</span><span class="s3">,</span><span class="s1"> 
    elemdisplay = {}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Retrieve the actual display of a element 
 * </span><span class="s7">@param </span><span class="s6">{String} name nodeName of the element 
 * </span><span class="s7">@param </span><span class="s6">{Object} doc Document object 
 */</span><span class="s1"> 
</span><span class="s0">// Called only from within defaultDisplay</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">actualDisplay( name</span><span class="s3">, </span><span class="s1">doc ) { 
    </span><span class="s2">var </span><span class="s1">style</span><span class="s3">,</span><span class="s1"> 
        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body )</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// getDefaultComputedStyle might be reliably used only on attached element</span><span class="s1"> 
        display = window.getDefaultComputedStyle &amp;&amp; ( style = window.getDefaultComputedStyle( elem[ </span><span class="s5">0 </span><span class="s1">] ) ) ? 
 
            </span><span class="s0">// Use of this method is a temporary fix (more like optmization) until something better comes along,</span><span class="s1"> 
            </span><span class="s0">// since it was removed from specification and supported only in FF</span><span class="s1"> 
            style.display : jQuery.css( elem[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// We don't have any data stored on the element,</span><span class="s1"> 
    </span><span class="s0">// so use &quot;detach&quot; method as fast way to get rid of the element</span><span class="s1"> 
    elem.detach()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">display</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s6">/** 
 * Try to determine the default display value of an element 
 * </span><span class="s7">@param </span><span class="s6">{String} nodeName 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">defaultDisplay( nodeName ) { 
    </span><span class="s2">var </span><span class="s1">doc = document</span><span class="s3">,</span><span class="s1"> 
        display = elemdisplay[ nodeName ]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( !display ) { 
        display = actualDisplay( nodeName</span><span class="s3">, </span><span class="s1">doc )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If the simple way fails, read from inside an iframe</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( display === </span><span class="s4">&quot;none&quot; </span><span class="s1">|| !display ) { 
 
            </span><span class="s0">// Use the already-created iframe if possible</span><span class="s1"> 
            iframe = (iframe || jQuery( </span><span class="s4">&quot;&lt;iframe frameborder='0' width='0' height='0'/&gt;&quot; </span><span class="s1">)).appendTo( doc.documentElement )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse</span><span class="s1"> 
            doc = ( iframe[ </span><span class="s5">0 </span><span class="s1">].contentWindow || iframe[ </span><span class="s5">0 </span><span class="s1">].contentDocument ).document</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Support: IE</span><span class="s1"> 
            doc.write()</span><span class="s3">;</span><span class="s1"> 
            doc.close()</span><span class="s3">;</span><span class="s1"> 
 
            display = actualDisplay( nodeName</span><span class="s3">, </span><span class="s1">doc )</span><span class="s3">;</span><span class="s1"> 
            iframe.detach()</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Store the correct default display</span><span class="s1"> 
        elemdisplay[ nodeName ] = display</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">display</span><span class="s3">;</span><span class="s1"> 
} 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">var </span><span class="s1">shrinkWrapBlocksVal</span><span class="s3">;</span><span class="s1"> 
 
    support.shrinkWrapBlocks = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">if </span><span class="s1">( shrinkWrapBlocksVal != </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">shrinkWrapBlocksVal</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Will be changed later if needed.</span><span class="s1"> 
        shrinkWrapBlocksVal = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Minified: var b,c,d</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">div</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">container</span><span class="s3">;</span><span class="s1"> 
 
        body = document.getElementsByTagName( </span><span class="s4">&quot;body&quot; </span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !body || !body.style ) { 
            </span><span class="s0">// Test fired too early or in an unsupported environment, exit.</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Setup</span><span class="s1"> 
        div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        container = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        container.style.cssText = </span><span class="s4">&quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;</span><span class="s3">;</span><span class="s1"> 
        body.appendChild( container ).appendChild( div )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Support: IE6</span><span class="s1"> 
        </span><span class="s0">// Check if elements with layout shrink-wrap their children</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">div.style.zoom !== strundefined ) { 
            </span><span class="s0">// Reset CSS: box-sizing; display; margin; border</span><span class="s1"> 
            div.style.cssText = 
                </span><span class="s0">// Support: Firefox&lt;29, Android 2.3</span><span class="s1"> 
                </span><span class="s0">// Vendor-prefix box-sizing</span><span class="s1"> 
                </span><span class="s4">&quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; </span><span class="s1">+ 
                </span><span class="s4">&quot;box-sizing:content-box;display:block;margin:0;border:0;&quot; </span><span class="s1">+ 
                </span><span class="s4">&quot;padding:1px;width:1px;zoom:1&quot;</span><span class="s3">;</span><span class="s1"> 
            div.appendChild( document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">) ).style.width = </span><span class="s4">&quot;5px&quot;</span><span class="s3">;</span><span class="s1"> 
            shrinkWrapBlocksVal = div.offsetWidth !== </span><span class="s5">3</span><span class="s3">;</span><span class="s1"> 
        } 
 
        body.removeChild( container )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">shrinkWrapBlocksVal</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
})()</span><span class="s3">;</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">rmargin = (</span><span class="s4">/^margin/</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">rnumnonpx = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^(&quot; </span><span class="s1">+ pnum + </span><span class="s4">&quot;)(?!px)[a-z%]+$&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s2">var </span><span class="s1">getStyles</span><span class="s3">, </span><span class="s1">curCSS</span><span class="s3">,</span><span class="s1"> 
    rposition = </span><span class="s4">/^(top|right|bottom|left)$/</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">if </span><span class="s1">( window.getComputedStyle ) { 
    getStyles = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s0">// Support: IE&lt;=11+, Firefox&lt;=30+ (#15098, #14150)</span><span class="s1"> 
        </span><span class="s0">// IE throws on elements created in popups</span><span class="s1"> 
        </span><span class="s0">// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( elem.ownerDocument.defaultView.opener ) { 
            </span><span class="s2">return </span><span class="s1">elem.ownerDocument.defaultView.getComputedStyle( elem</span><span class="s3">, </span><span class="s2">null </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">window.getComputedStyle( elem</span><span class="s3">, </span><span class="s2">null </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
    curCSS = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">computed ) { 
        </span><span class="s2">var </span><span class="s1">width</span><span class="s3">, </span><span class="s1">minWidth</span><span class="s3">, </span><span class="s1">maxWidth</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">,</span><span class="s1"> 
            style = elem.style</span><span class="s3">;</span><span class="s1"> 
 
        computed = computed || getStyles( elem )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// getPropertyValue is only needed for .css('filter') in IE9, see #12537</span><span class="s1"> 
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( computed ) { 
 
            </span><span class="s2">if </span><span class="s1">( ret === </span><span class="s4">&quot;&quot; </span><span class="s1">&amp;&amp; !jQuery.contains( elem.ownerDocument</span><span class="s3">, </span><span class="s1">elem ) ) { 
                ret = jQuery.style( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// A tribute to the &quot;awesome hack by Dean Edwards&quot;</span><span class="s1"> 
            </span><span class="s0">// Chrome &lt; 17 and Safari 5.0 uses &quot;computed value&quot; instead of &quot;used value&quot; for margin-right</span><span class="s1"> 
            </span><span class="s0">// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels</span><span class="s1"> 
            </span><span class="s0">// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) { 
 
                </span><span class="s0">// Remember the original values</span><span class="s1"> 
                width = style.width</span><span class="s3">;</span><span class="s1"> 
                minWidth = style.minWidth</span><span class="s3">;</span><span class="s1"> 
                maxWidth = style.maxWidth</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Put in the new values to get a computed value out</span><span class="s1"> 
                style.minWidth = style.maxWidth = style.width = ret</span><span class="s3">;</span><span class="s1"> 
                ret = computed.width</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Revert the changed values</span><span class="s1"> 
                style.width = width</span><span class="s3">;</span><span class="s1"> 
                style.minWidth = minWidth</span><span class="s3">;</span><span class="s1"> 
                style.maxWidth = maxWidth</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Support: IE</span><span class="s1"> 
        </span><span class="s0">// IE returns zIndex value as an integer.</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">ret === undefined ? 
            ret : 
            ret + </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
} </span><span class="s2">else if </span><span class="s1">( document.documentElement.currentStyle ) { 
    getStyles = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">elem.currentStyle</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
 
    curCSS = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">computed ) { 
        </span><span class="s2">var </span><span class="s1">left</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">, </span><span class="s1">rsLeft</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">,</span><span class="s1"> 
            style = elem.style</span><span class="s3">;</span><span class="s1"> 
 
        computed = computed || getStyles( elem )</span><span class="s3">;</span><span class="s1"> 
        ret = computed ? computed[ name ] : undefined</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Avoid setting ret to empty string here</span><span class="s1"> 
        </span><span class="s0">// so we don't default to auto</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( ret == </span><span class="s2">null </span><span class="s1">&amp;&amp; style &amp;&amp; style[ name ] ) { 
            ret = style[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// From the awesome hack by Dean Edwards</span><span class="s1"> 
        </span><span class="s0">// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291</span><span class="s1"> 
 
        </span><span class="s0">// If we're not dealing with a regular pixel number</span><span class="s1"> 
        </span><span class="s0">// but a number that has a weird ending, we need to convert it to pixels</span><span class="s1"> 
        </span><span class="s0">// but not position css attributes, as those are proportional to the parent element instead</span><span class="s1"> 
        </span><span class="s0">// and we can't measure the parent instead because it might trigger a &quot;stacking dolls&quot; problem</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( rnumnonpx.test( ret ) &amp;&amp; !rposition.test( name ) ) { 
 
            </span><span class="s0">// Remember the original values</span><span class="s1"> 
            left = style.left</span><span class="s3">;</span><span class="s1"> 
            rs = elem.runtimeStyle</span><span class="s3">;</span><span class="s1"> 
            rsLeft = rs &amp;&amp; rs.left</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Put in the new values to get a computed value out</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rsLeft ) { 
                rs.left = elem.currentStyle.left</span><span class="s3">;</span><span class="s1"> 
            } 
            style.left = name === </span><span class="s4">&quot;fontSize&quot; </span><span class="s1">? </span><span class="s4">&quot;1em&quot; </span><span class="s1">: ret</span><span class="s3">;</span><span class="s1"> 
            ret = style.pixelLeft + </span><span class="s4">&quot;px&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Revert the changed values</span><span class="s1"> 
            style.left = left</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rsLeft ) { 
                rs.left = rsLeft</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Support: IE</span><span class="s1"> 
        </span><span class="s0">// IE returns zIndex value as an integer.</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">ret === undefined ? 
            ret : 
            ret + </span><span class="s4">&quot;&quot; </span><span class="s1">|| </span><span class="s4">&quot;auto&quot;</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
 
 
 
</span><span class="s2">function </span><span class="s1">addGetHookIf( conditionFn</span><span class="s3">, </span><span class="s1">hookFn ) { 
    </span><span class="s0">// Define the hook, we'll check on the first run if it's really needed.</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">{ 
        get: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">condition = conditionFn()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( condition == </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s0">// The test was not ready at this point; screw the hook this time</span><span class="s1"> 
                </span><span class="s0">// but check again when needed next time.</span><span class="s1"> 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( condition ) { 
                </span><span class="s0">// Hook not needed (or it's not possible to use it due to missing dependency),</span><span class="s1"> 
                </span><span class="s0">// remove it.</span><span class="s1"> 
                </span><span class="s0">// Since there are no other hooks for marginRight, remove the whole object.</span><span class="s1"> 
                </span><span class="s2">delete this</span><span class="s1">.get</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Hook needed; redefine it so that the support test is not executed again.</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.get = hookFn).apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s0">// Minified: var b,c,d,e,f,g, h,i</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">div</span><span class="s3">, </span><span class="s1">style</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">pixelPositionVal</span><span class="s3">, </span><span class="s1">boxSizingReliableVal</span><span class="s3">,</span><span class="s1"> 
        reliableHiddenOffsetsVal</span><span class="s3">, </span><span class="s1">reliableMarginRightVal</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Setup</span><span class="s1"> 
    div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    div.innerHTML = </span><span class="s4">&quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
    a = div.getElementsByTagName( </span><span class="s4">&quot;a&quot; </span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
    style = a &amp;&amp; a.style</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Finish early in limited (non-browser) environments</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !style ) { 
        </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
    } 
 
    style.cssText = </span><span class="s4">&quot;float:left;opacity:.5&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
    </span><span class="s0">// Make sure that element opacity exists (as opposed to filter)</span><span class="s1"> 
    support.opacity = style.opacity === </span><span class="s4">&quot;0.5&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Verify style float existence</span><span class="s1"> 
    </span><span class="s0">// (IE uses styleFloat instead of cssFloat)</span><span class="s1"> 
    support.cssFloat = !!style.cssFloat</span><span class="s3">;</span><span class="s1"> 
 
    div.style.backgroundClip = </span><span class="s4">&quot;content-box&quot;</span><span class="s3">;</span><span class="s1"> 
    div.cloneNode( </span><span class="s2">true </span><span class="s1">).style.backgroundClip = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
    support.clearCloneStyle = div.style.backgroundClip === </span><span class="s4">&quot;content-box&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: Firefox&lt;29, Android 2.3</span><span class="s1"> 
    </span><span class="s0">// Vendor-prefix box-sizing</span><span class="s1"> 
    support.boxSizing = style.boxSizing === </span><span class="s4">&quot;&quot; </span><span class="s1">|| style.MozBoxSizing === </span><span class="s4">&quot;&quot; </span><span class="s1">|| 
        style.WebkitBoxSizing === </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
    jQuery.extend(support</span><span class="s3">, </span><span class="s1">{ 
        reliableHiddenOffsets: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( reliableHiddenOffsetsVal == </span><span class="s2">null </span><span class="s1">) { 
                computeStyleTests()</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">reliableHiddenOffsetsVal</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        boxSizingReliable: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( boxSizingReliableVal == </span><span class="s2">null </span><span class="s1">) { 
                computeStyleTests()</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">boxSizingReliableVal</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        pixelPosition: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( pixelPositionVal == </span><span class="s2">null </span><span class="s1">) { 
                computeStyleTests()</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">pixelPositionVal</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Support: Android 2.3</span><span class="s1"> 
        reliableMarginRight: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( reliableMarginRightVal == </span><span class="s2">null </span><span class="s1">) { 
                computeStyleTests()</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">reliableMarginRightVal</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">function </span><span class="s1">computeStyleTests() { 
        </span><span class="s0">// Minified: var b,c,d,j</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">div</span><span class="s3">, </span><span class="s1">body</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">contents</span><span class="s3">;</span><span class="s1"> 
 
        body = document.getElementsByTagName( </span><span class="s4">&quot;body&quot; </span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !body || !body.style ) { 
            </span><span class="s0">// Test fired too early or in an unsupported environment, exit.</span><span class="s1"> 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Setup</span><span class="s1"> 
        div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        container = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        container.style.cssText = </span><span class="s4">&quot;position:absolute;border:0;width:0;height:0;top:0;left:-9999px&quot;</span><span class="s3">;</span><span class="s1"> 
        body.appendChild( container ).appendChild( div )</span><span class="s3">;</span><span class="s1"> 
 
        div.style.cssText = 
            </span><span class="s0">// Support: Firefox&lt;29, Android 2.3</span><span class="s1"> 
            </span><span class="s0">// Vendor-prefix box-sizing</span><span class="s1"> 
            </span><span class="s4">&quot;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;&quot; </span><span class="s1">+ 
            </span><span class="s4">&quot;box-sizing:border-box;display:block;margin-top:1%;top:1%;&quot; </span><span class="s1">+ 
            </span><span class="s4">&quot;border:1px;padding:1px;width:4px;position:absolute&quot;</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
        </span><span class="s0">// Assume reasonable values in the absence of getComputedStyle</span><span class="s1"> 
        pixelPositionVal = boxSizingReliableVal = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
        reliableMarginRightVal = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Check for getComputedStyle so that this code is not run in IE&lt;9.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( window.getComputedStyle ) { 
            pixelPositionVal = ( window.getComputedStyle( div</span><span class="s3">, </span><span class="s2">null </span><span class="s1">) || {} ).top !== </span><span class="s4">&quot;1%&quot;</span><span class="s3">;</span><span class="s1"> 
            boxSizingReliableVal = 
                ( window.getComputedStyle( div</span><span class="s3">, </span><span class="s2">null </span><span class="s1">) || { width: </span><span class="s4">&quot;4px&quot; </span><span class="s1">} ).width === </span><span class="s4">&quot;4px&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Support: Android 2.3</span><span class="s1"> 
            </span><span class="s0">// Div with explicit width and no margin-right incorrectly</span><span class="s1"> 
            </span><span class="s0">// gets computed margin-right based on width of container (#3333)</span><span class="s1"> 
            </span><span class="s0">// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span><span class="s1"> 
            contents = div.appendChild( document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Reset CSS: box-sizing; display; margin; border; padding</span><span class="s1"> 
            contents.style.cssText = div.style.cssText = 
                </span><span class="s0">// Support: Firefox&lt;29, Android 2.3</span><span class="s1"> 
                </span><span class="s0">// Vendor-prefix box-sizing</span><span class="s1"> 
                </span><span class="s4">&quot;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;&quot; </span><span class="s1">+ 
                </span><span class="s4">&quot;box-sizing:content-box;display:block;margin:0;border:0;padding:0&quot;</span><span class="s3">;</span><span class="s1"> 
            contents.style.marginRight = contents.style.width = </span><span class="s4">&quot;0&quot;</span><span class="s3">;</span><span class="s1"> 
            div.style.width = </span><span class="s4">&quot;1px&quot;</span><span class="s3">;</span><span class="s1"> 
 
            reliableMarginRightVal = 
                !parseFloat( ( window.getComputedStyle( contents</span><span class="s3">, </span><span class="s2">null </span><span class="s1">) || {} ).marginRight )</span><span class="s3">;</span><span class="s1"> 
 
            div.removeChild( contents )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Support: IE8</span><span class="s1"> 
        </span><span class="s0">// Check if table cells still have offsetWidth/Height when they are set</span><span class="s1"> 
        </span><span class="s0">// to display:none and there are still other visible table cells in a</span><span class="s1"> 
        </span><span class="s0">// table row; if so, offsetWidth/Height are not reliable for use when</span><span class="s1"> 
        </span><span class="s0">// determining if an element has been hidden directly using</span><span class="s1"> 
        </span><span class="s0">// display:none (it is still safe to use offsets if a parent element is</span><span class="s1"> 
        </span><span class="s0">// hidden; don safety goggles and see bug #4512 for more information).</span><span class="s1"> 
        div.innerHTML = </span><span class="s4">&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
        contents = div.getElementsByTagName( </span><span class="s4">&quot;td&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        contents[ </span><span class="s5">0 </span><span class="s1">].style.cssText = </span><span class="s4">&quot;margin:0;border:0;padding:0;display:none&quot;</span><span class="s3">;</span><span class="s1"> 
        reliableHiddenOffsetsVal = contents[ </span><span class="s5">0 </span><span class="s1">].offsetHeight === </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( reliableHiddenOffsetsVal ) { 
            contents[ </span><span class="s5">0 </span><span class="s1">].style.display = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
            contents[ </span><span class="s5">1 </span><span class="s1">].style.display = </span><span class="s4">&quot;none&quot;</span><span class="s3">;</span><span class="s1"> 
            reliableHiddenOffsetsVal = contents[ </span><span class="s5">0 </span><span class="s1">].offsetHeight === </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        body.removeChild( container )</span><span class="s3">;</span><span class="s1"> 
    } 
 
})()</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// A method for quickly swapping in/out CSS properties to get correct calculations.</span><span class="s1"> 
jQuery.swap = </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">args ) { 
    </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">name</span><span class="s3">,</span><span class="s1"> 
        old = {}</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Remember the old values, and insert the new ones</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
        old[ name ] = elem.style[ name ]</span><span class="s3">;</span><span class="s1"> 
        elem.style[ name ] = options[ name ]</span><span class="s3">;</span><span class="s1"> 
    } 
 
    ret = callback.apply( elem</span><span class="s3">, </span><span class="s1">args || [] )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Revert the old values</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
        elem.style[ name ] = old[ name ]</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var</span><span class="s1"> 
        ralpha = </span><span class="s4">/alpha\([^)]*\)/i</span><span class="s3">,</span><span class="s1"> 
    ropacity = </span><span class="s4">/opacity\s*=\s*([^)]*)/</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;</span><span class="s1"> 
    </span><span class="s0">// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display</span><span class="s1"> 
    rdisplayswap = </span><span class="s4">/^(none|table(?!-c[ea]).+)/</span><span class="s3">,</span><span class="s1"> 
    rnumsplit = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^(&quot; </span><span class="s1">+ pnum + </span><span class="s4">&quot;)(.*)$&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    rrelNum = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^([+-])=(&quot; </span><span class="s1">+ pnum + </span><span class="s4">&quot;)&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
    cssShow = { position: </span><span class="s4">&quot;absolute&quot;</span><span class="s3">, </span><span class="s1">visibility: </span><span class="s4">&quot;hidden&quot;</span><span class="s3">, </span><span class="s1">display: </span><span class="s4">&quot;block&quot; </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
    cssNormalTransform = { 
        letterSpacing: </span><span class="s4">&quot;0&quot;</span><span class="s3">,</span><span class="s1"> 
        fontWeight: </span><span class="s4">&quot;400&quot;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    cssPrefixes = [ </span><span class="s4">&quot;Webkit&quot;</span><span class="s3">, </span><span class="s4">&quot;O&quot;</span><span class="s3">, </span><span class="s4">&quot;Moz&quot;</span><span class="s3">, </span><span class="s4">&quot;ms&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// return a css property mapped to a potentially vendor prefixed property</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">vendorPropName( style</span><span class="s3">, </span><span class="s1">name ) { 
 
    </span><span class="s0">// shortcut for names that are not vendor prefixed</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">style ) { 
        </span><span class="s2">return </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// check for vendor prefixed names</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">capName = name.charAt(</span><span class="s5">0</span><span class="s1">).toUpperCase() + name.slice(</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
        origName = name</span><span class="s3">,</span><span class="s1"> 
        i = cssPrefixes.length</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">while </span><span class="s1">( i-- ) { 
        name = cssPrefixes[ i ] + capName</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">style ) { 
            </span><span class="s2">return </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">origName</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">showHide( elements</span><span class="s3">, </span><span class="s1">show ) { 
    </span><span class="s2">var </span><span class="s1">display</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">hidden</span><span class="s3">,</span><span class="s1"> 
        values = []</span><span class="s3">,</span><span class="s1"> 
        index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        length = elements.length</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length</span><span class="s3">; </span><span class="s1">index++ ) { 
        elem = elements[ index ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem.style ) { 
            </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
        } 
 
        values[ index ] = jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;olddisplay&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        display = elem.style.display</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( show ) { 
            </span><span class="s0">// Reset the inline display of this element to learn if it is</span><span class="s1"> 
            </span><span class="s0">// being hidden by cascaded rules or not</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !values[ index ] &amp;&amp; display === </span><span class="s4">&quot;none&quot; </span><span class="s1">) { 
                elem.style.display = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Set elements which have been overridden with display: none</span><span class="s1"> 
            </span><span class="s0">// in a stylesheet to whatever the default browser style is</span><span class="s1"> 
            </span><span class="s0">// for such an element</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( elem.style.display === </span><span class="s4">&quot;&quot; </span><span class="s1">&amp;&amp; isHidden( elem ) ) { 
                values[ index ] = jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;olddisplay&quot;</span><span class="s3">, </span><span class="s1">defaultDisplay(elem.nodeName) )</span><span class="s3">;</span><span class="s1"> 
            } 
        } </span><span class="s2">else </span><span class="s1">{ 
            hidden = isHidden( elem )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( display &amp;&amp; display !== </span><span class="s4">&quot;none&quot; </span><span class="s1">|| !hidden ) { 
                jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;olddisplay&quot;</span><span class="s3">, </span><span class="s1">hidden ? display : jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s0">// Set the display of most of the elements in a second loop</span><span class="s1"> 
    </span><span class="s0">// to avoid the constant reflow</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( index = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index &lt; length</span><span class="s3">; </span><span class="s1">index++ ) { 
        elem = elements[ index ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem.style ) { 
            </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( !show || elem.style.display === </span><span class="s4">&quot;none&quot; </span><span class="s1">|| elem.style.display === </span><span class="s4">&quot;&quot; </span><span class="s1">) { 
            elem.style.display = show ? values[ index ] || </span><span class="s4">&quot;&quot; </span><span class="s1">: </span><span class="s4">&quot;none&quot;</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">elements</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">setPositiveNumber( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">subtract ) { 
    </span><span class="s2">var </span><span class="s1">matches = rnumsplit.exec( value )</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">matches ? 
        </span><span class="s0">// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks</span><span class="s1"> 
        Math.max( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">matches[ </span><span class="s5">1 </span><span class="s1">] - ( subtract || </span><span class="s5">0 </span><span class="s1">) ) + ( matches[ </span><span class="s5">2 </span><span class="s1">] || </span><span class="s4">&quot;px&quot; </span><span class="s1">) : 
        value</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">augmentWidthOrHeight( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">, </span><span class="s1">isBorderBox</span><span class="s3">, </span><span class="s1">styles ) { 
    </span><span class="s2">var </span><span class="s1">i = extra === ( isBorderBox ? </span><span class="s4">&quot;border&quot; </span><span class="s1">: </span><span class="s4">&quot;content&quot; </span><span class="s1">) ? 
        </span><span class="s0">// If we already have the right measurement, avoid augmentation</span><span class="s1"> 
        </span><span class="s5">4 </span><span class="s1">: 
        </span><span class="s0">// Otherwise initialize for horizontal or vertical properties</span><span class="s1"> 
        name === </span><span class="s4">&quot;width&quot; </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
        val = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; </span><span class="s5">4</span><span class="s3">; </span><span class="s1">i += </span><span class="s5">2 </span><span class="s1">) { 
        </span><span class="s0">// both box models exclude margin, so add it if we want it</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s4">&quot;margin&quot; </span><span class="s1">) { 
            val += jQuery.css( elem</span><span class="s3">, </span><span class="s1">extra + cssExpand[ i ]</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( isBorderBox ) { 
            </span><span class="s0">// border-box includes padding, so remove it if we want content</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s4">&quot;content&quot; </span><span class="s1">) { 
                val -= jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;padding&quot; </span><span class="s1">+ cssExpand[ i ]</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// at this point, extra isn't border nor margin, so remove border</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( extra !== </span><span class="s4">&quot;margin&quot; </span><span class="s1">) { 
                val -= jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;border&quot; </span><span class="s1">+ cssExpand[ i ] + </span><span class="s4">&quot;Width&quot;</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
            } 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// at this point, extra isn't content, so add padding</span><span class="s1"> 
            val += jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;padding&quot; </span><span class="s1">+ cssExpand[ i ]</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// at this point, extra isn't content nor padding, so add border</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( extra !== </span><span class="s4">&quot;padding&quot; </span><span class="s1">) { 
                val += jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;border&quot; </span><span class="s1">+ cssExpand[ i ] + </span><span class="s4">&quot;Width&quot;</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">val</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">getWidthOrHeight( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">extra ) { 
 
    </span><span class="s0">// Start with offset property, which is equivalent to the border-box value</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">valueIsBorderBox = </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        val = name === </span><span class="s4">&quot;width&quot; </span><span class="s1">? elem.offsetWidth : elem.offsetHeight</span><span class="s3">,</span><span class="s1"> 
        styles = getStyles( elem )</span><span class="s3">,</span><span class="s1"> 
        isBorderBox = support.boxSizing &amp;&amp; jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;boxSizing&quot;</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s1">styles ) === </span><span class="s4">&quot;border-box&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// some non-html elements return undefined for offsetWidth, so check for null/undefined</span><span class="s1"> 
    </span><span class="s0">// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285</span><span class="s1"> 
    </span><span class="s0">// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( val &lt;= </span><span class="s5">0 </span><span class="s1">|| val == </span><span class="s2">null </span><span class="s1">) { 
        </span><span class="s0">// Fall back to computed then uncomputed css if necessary</span><span class="s1"> 
        val = curCSS( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( val &lt; </span><span class="s5">0 </span><span class="s1">|| val == </span><span class="s2">null </span><span class="s1">) { 
            val = elem.style[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Computed unit is not pixels. Stop here and return.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( rnumnonpx.test(val) ) { 
            </span><span class="s2">return </span><span class="s1">val</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// we need the check for style in case a browser which returns unreliable values</span><span class="s1"> 
        </span><span class="s0">// for getComputedStyle silently falls back to the reliable elem.style</span><span class="s1"> 
        valueIsBorderBox = isBorderBox &amp;&amp; ( support.boxSizingReliable() || val === elem.style[ name ] )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Normalize &quot;&quot;, auto, and prepare for extra</span><span class="s1"> 
        val = parseFloat( val ) || </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// use the active box-sizing model to add/subtract irrelevant styles</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">( val + 
        augmentWidthOrHeight( 
            elem</span><span class="s3">,</span><span class="s1"> 
            name</span><span class="s3">,</span><span class="s1"> 
            extra || ( isBorderBox ? </span><span class="s4">&quot;border&quot; </span><span class="s1">: </span><span class="s4">&quot;content&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            valueIsBorderBox</span><span class="s3">,</span><span class="s1"> 
            styles 
        ) 
    ) + </span><span class="s4">&quot;px&quot;</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.extend({ 
    </span><span class="s0">// Add in style property hooks for overriding the default</span><span class="s1"> 
    </span><span class="s0">// behavior of getting and setting a style property</span><span class="s1"> 
    cssHooks: { 
        opacity: { 
            get: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">computed ) { 
                </span><span class="s2">if </span><span class="s1">( computed ) { 
                    </span><span class="s0">// We should always get a number back from opacity</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">ret = curCSS( elem</span><span class="s3">, </span><span class="s4">&quot;opacity&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">ret === </span><span class="s4">&quot;&quot; </span><span class="s1">? </span><span class="s4">&quot;1&quot; </span><span class="s1">: ret</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Don't automatically add &quot;px&quot; to these possibly-unitless properties</span><span class="s1"> 
    cssNumber: { 
        </span><span class="s4">&quot;columnCount&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;fillOpacity&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;flexGrow&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;flexShrink&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;fontWeight&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;lineHeight&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;opacity&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;order&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;orphans&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;widows&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;zIndex&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;zoom&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Add in properties whose names you wish to fix before</span><span class="s1"> 
    </span><span class="s0">// setting or getting the value</span><span class="s1"> 
    cssProps: { 
        </span><span class="s0">// normalize float css property</span><span class="s1"> 
        </span><span class="s4">&quot;float&quot;</span><span class="s1">: support.cssFloat ? </span><span class="s4">&quot;cssFloat&quot; </span><span class="s1">: </span><span class="s4">&quot;styleFloat&quot;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Get and set the style property on a DOM Node</span><span class="s1"> 
    style: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extra ) { 
        </span><span class="s0">// Don't set styles on text and comment nodes</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem || elem.nodeType === </span><span class="s5">3 </span><span class="s1">|| elem.nodeType === </span><span class="s5">8 </span><span class="s1">|| !elem.style ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Make sure that we're working with the right name</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">,</span><span class="s1"> 
            origName = jQuery.camelCase( name )</span><span class="s3">,</span><span class="s1"> 
            style = elem.style</span><span class="s3">;</span><span class="s1"> 
 
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style</span><span class="s3">, </span><span class="s1">origName ) )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// gets hook for the prefixed version</span><span class="s1"> 
        </span><span class="s0">// followed by the unprefixed version</span><span class="s1"> 
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Check if we're setting a value</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
            type = </span><span class="s2">typeof </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// convert relative number strings (+= or -=) to relative numbers. #7345</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; (ret = rrelNum.exec( value )) ) { 
                value = ( ret[</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1 </span><span class="s1">) * ret[</span><span class="s5">2</span><span class="s1">] + parseFloat( jQuery.css( elem</span><span class="s3">, </span><span class="s1">name ) )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// Fixes bug #9237</span><span class="s1"> 
                type = </span><span class="s4">&quot;number&quot;</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Make sure that null and NaN values aren't set. See: #7116</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( value == </span><span class="s2">null </span><span class="s1">|| value !== value ) { 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// If a number was passed in, add 'px' to the (except for certain CSS properties)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;number&quot; </span><span class="s1">&amp;&amp; !jQuery.cssNumber[ origName ] ) { 
                value += </span><span class="s4">&quot;px&quot;</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,</span><span class="s1"> 
            </span><span class="s0">// but it would mean to define eight (for every problematic property) identical functions</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !support.clearCloneStyle &amp;&amp; value === </span><span class="s4">&quot;&quot; </span><span class="s1">&amp;&amp; name.indexOf(</span><span class="s4">&quot;background&quot;</span><span class="s1">) === </span><span class="s5">0 </span><span class="s1">) { 
                style[ name ] = </span><span class="s4">&quot;inherit&quot;</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// If a hook was provided, use that value, otherwise just set the specified value</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !hooks || !(</span><span class="s4">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks) || (value = hooks.set( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extra )) !== undefined ) { 
 
                </span><span class="s0">// Support: IE</span><span class="s1"> 
                </span><span class="s0">// Swallow errors from 'invalid' CSS values (#5509)</span><span class="s1"> 
                </span><span class="s2">try </span><span class="s1">{ 
                    style[ name ] = value</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">catch</span><span class="s1">(e) {} 
            } 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// If a hook was provided get the non-computed value from there</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.get( elem</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s1">extra )) !== undefined ) { 
                </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Otherwise just get the value from the style object</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">style[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    css: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">extra</span><span class="s3">, </span><span class="s1">styles ) { 
        </span><span class="s2">var </span><span class="s1">num</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">,</span><span class="s1"> 
            origName = jQuery.camelCase( name )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Make sure that we're working with the right name</span><span class="s1"> 
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style</span><span class="s3">, </span><span class="s1">origName ) )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// gets hook for the prefixed version</span><span class="s1"> 
        </span><span class="s0">// followed by the unprefixed version</span><span class="s1"> 
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If a hook was provided get the computed value from there</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks ) { 
            val = hooks.get( elem</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s1">extra )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Otherwise, if a way to get the computed value exists, use that</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( val === undefined ) { 
            val = curCSS( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">//convert &quot;normal&quot; to computed value</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( val === </span><span class="s4">&quot;normal&quot; </span><span class="s1">&amp;&amp; name </span><span class="s2">in </span><span class="s1">cssNormalTransform ) { 
            val = cssNormalTransform[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Return, converting to number if forced or a qualifier was provided and val looks numeric</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s4">&quot;&quot; </span><span class="s1">|| extra ) { 
            num = parseFloat( val )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">extra === </span><span class="s2">true </span><span class="s1">|| jQuery.isNumeric( num ) ? num || </span><span class="s5">0 </span><span class="s1">: val</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return </span><span class="s1">val</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.each([ </span><span class="s4">&quot;height&quot;</span><span class="s3">, </span><span class="s4">&quot;width&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
    jQuery.cssHooks[ name ] = { 
        get: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">computed</span><span class="s3">, </span><span class="s1">extra ) { 
            </span><span class="s2">if </span><span class="s1">( computed ) { 
                </span><span class="s0">// certain elements can have dimension info if we invisibly show them</span><span class="s1"> 
                </span><span class="s0">// however, it must have a current display style that would benefit from this</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">rdisplayswap.test( jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">) ) &amp;&amp; elem.offsetWidth === </span><span class="s5">0 </span><span class="s1">? 
                    jQuery.swap( elem</span><span class="s3">, </span><span class="s1">cssShow</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">return </span><span class="s1">getWidthOrHeight( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">extra )</span><span class="s3">;</span><span class="s1"> 
                    }) : 
                    getWidthOrHeight( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">extra )</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extra ) { 
            </span><span class="s2">var </span><span class="s1">styles = extra &amp;&amp; getStyles( elem )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">setPositiveNumber( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extra ? 
                augmentWidthOrHeight( 
                    elem</span><span class="s3">,</span><span class="s1"> 
                    name</span><span class="s3">,</span><span class="s1"> 
                    extra</span><span class="s3">,</span><span class="s1"> 
                    support.boxSizing &amp;&amp; jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;boxSizing&quot;</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s1">styles ) === </span><span class="s4">&quot;border-box&quot;</span><span class="s3">,</span><span class="s1"> 
                    styles 
                ) : </span><span class="s5">0</span><span class="s1"> 
            )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">if </span><span class="s1">( !support.opacity ) { 
    jQuery.cssHooks.opacity = { 
        get: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">computed ) { 
            </span><span class="s0">// IE uses filters for opacity</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || </span><span class="s4">&quot;&quot; </span><span class="s1">) ? 
                ( </span><span class="s5">0.01 </span><span class="s1">* parseFloat( RegExp.$1 ) ) + </span><span class="s4">&quot;&quot; </span><span class="s1">: 
                computed ? </span><span class="s4">&quot;1&quot; </span><span class="s1">: </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">var </span><span class="s1">style = elem.style</span><span class="s3">,</span><span class="s1"> 
                currentStyle = elem.currentStyle</span><span class="s3">,</span><span class="s1"> 
                opacity = jQuery.isNumeric( value ) ? </span><span class="s4">&quot;alpha(opacity=&quot; </span><span class="s1">+ value * </span><span class="s5">100 </span><span class="s1">+ </span><span class="s4">&quot;)&quot; </span><span class="s1">: </span><span class="s4">&quot;&quot;</span><span class="s3">,</span><span class="s1"> 
                filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// IE has trouble with opacity if it does not have layout</span><span class="s1"> 
            </span><span class="s0">// Force it by setting the zoom level</span><span class="s1"> 
            style.zoom = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652</span><span class="s1"> 
            </span><span class="s0">// if value === &quot;&quot;, then remove inline opacity #12685</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( ( value &gt;= </span><span class="s5">1 </span><span class="s1">|| value === </span><span class="s4">&quot;&quot; </span><span class="s1">) &amp;&amp; 
                    jQuery.trim( filter.replace( ralpha</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">) ) === </span><span class="s4">&quot;&quot; </span><span class="s1">&amp;&amp; 
                    style.removeAttribute ) { 
 
                </span><span class="s0">// Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave &quot;filter:&quot; in the cssText</span><span class="s1"> 
                </span><span class="s0">// if &quot;filter:&quot; is present at all, clearType is disabled, we want to avoid this</span><span class="s1"> 
                </span><span class="s0">// style.removeAttribute is IE Only, but so apparently is this code path...</span><span class="s1"> 
                style.removeAttribute( </span><span class="s4">&quot;filter&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// if there is no filter style applied in a css rule or unset inline opacity, we are done</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( value === </span><span class="s4">&quot;&quot; </span><span class="s1">|| currentStyle &amp;&amp; !currentStyle.filter ) { 
                    </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// otherwise, set new filter values</span><span class="s1"> 
            style.filter = ralpha.test( filter ) ? 
                filter.replace( ralpha</span><span class="s3">, </span><span class="s1">opacity ) : 
                filter + </span><span class="s4">&quot; &quot; </span><span class="s1">+ opacity</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">computed ) { 
        </span><span class="s2">if </span><span class="s1">( computed ) { 
            </span><span class="s0">// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right</span><span class="s1"> 
            </span><span class="s0">// Work around by temporarily setting element display to inline-block</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">jQuery.swap( elem</span><span class="s3">, </span><span class="s1">{ </span><span class="s4">&quot;display&quot;</span><span class="s1">: </span><span class="s4">&quot;inline-block&quot; </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
                curCSS</span><span class="s3">, </span><span class="s1">[ elem</span><span class="s3">, </span><span class="s4">&quot;marginRight&quot; </span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
)</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// These hooks are used by animate to expand properties</span><span class="s1"> 
jQuery.each({ 
    margin: </span><span class="s4">&quot;&quot;</span><span class="s3">,</span><span class="s1"> 
    padding: </span><span class="s4">&quot;&quot;</span><span class="s3">,</span><span class="s1"> 
    border: </span><span class="s4">&quot;Width&quot;</span><span class="s1"> 
}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( prefix</span><span class="s3">, </span><span class="s1">suffix ) { 
    jQuery.cssHooks[ prefix + suffix ] = { 
        expand: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                expanded = {}</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// assumes a single number if not a string</span><span class="s1"> 
                parts = </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s4">&quot;string&quot; </span><span class="s1">? value.split(</span><span class="s4">&quot; &quot;</span><span class="s1">) : [ value ]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; </span><span class="s5">4</span><span class="s3">; </span><span class="s1">i++ ) { 
                expanded[ prefix + cssExpand[ i ] + suffix ] = 
                    parts[ i ] || parts[ i - </span><span class="s5">2 </span><span class="s1">] || parts[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">expanded</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( !rmargin.test( prefix ) ) { 
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    css: </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">var </span><span class="s1">styles</span><span class="s3">, </span><span class="s1">len</span><span class="s3">,</span><span class="s1"> 
                map = {}</span><span class="s3">,</span><span class="s1"> 
                i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isArray( name ) ) { 
                styles = getStyles( elem )</span><span class="s3">;</span><span class="s1"> 
                len = name.length</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                    map[ name[ i ] ] = jQuery.css( elem</span><span class="s3">, </span><span class="s1">name[ i ]</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s1">styles )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">return </span><span class="s1">map</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">value !== undefined ? 
                jQuery.style( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value ) : 
                jQuery.css( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">arguments.length &gt; </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    show: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">showHide( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    hide: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">showHide( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    toggle: </span><span class="s2">function</span><span class="s1">( state ) { 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">state === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">state ? </span><span class="s2">this</span><span class="s1">.show() : </span><span class="s2">this</span><span class="s1">.hide()</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( isHidden( </span><span class="s2">this </span><span class="s1">) ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).show()</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                jQuery( </span><span class="s2">this </span><span class="s1">).hide()</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">function </span><span class="s1">Tween( elem</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">easing ) { 
    </span><span class="s2">return new </span><span class="s1">Tween.prototype.init( elem</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">easing )</span><span class="s3">;</span><span class="s1"> 
} 
jQuery.Tween = Tween</span><span class="s3">;</span><span class="s1"> 
 
Tween.prototype = { 
    constructor: Tween</span><span class="s3">,</span><span class="s1"> 
    init: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">unit ) { 
        </span><span class="s2">this</span><span class="s1">.elem = elem</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.prop = prop</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.easing = easing || </span><span class="s4">&quot;swing&quot;</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.options = options</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.start = </span><span class="s2">this</span><span class="s1">.now = </span><span class="s2">this</span><span class="s1">.cur()</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.end = end</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.unit = unit || ( jQuery.cssNumber[ prop ] ? </span><span class="s4">&quot;&quot; </span><span class="s1">: </span><span class="s4">&quot;px&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    cur: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">hooks = Tween.propHooks[ </span><span class="s2">this</span><span class="s1">.prop ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">hooks &amp;&amp; hooks.get ? 
            hooks.get( </span><span class="s2">this </span><span class="s1">) : 
            Tween.propHooks._default.get( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    run: </span><span class="s2">function</span><span class="s1">( percent ) { 
        </span><span class="s2">var </span><span class="s1">eased</span><span class="s3">,</span><span class="s1"> 
            hooks = Tween.propHooks[ </span><span class="s2">this</span><span class="s1">.prop ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.options.duration ) { 
            </span><span class="s2">this</span><span class="s1">.pos = eased = jQuery.easing[ </span><span class="s2">this</span><span class="s1">.easing ]( 
                percent</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.options.duration * percent</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.options.duration 
            )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">this</span><span class="s1">.pos = eased = percent</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">this</span><span class="s1">.now = ( </span><span class="s2">this</span><span class="s1">.end - </span><span class="s2">this</span><span class="s1">.start ) * eased + </span><span class="s2">this</span><span class="s1">.start</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.options.step ) { 
            </span><span class="s2">this</span><span class="s1">.options.step.call( </span><span class="s2">this</span><span class="s1">.elem</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.now</span><span class="s3">, </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; hooks.set ) { 
            hooks.set( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            Tween.propHooks._default.set( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
Tween.prototype.init.prototype = Tween.prototype</span><span class="s3">;</span><span class="s1"> 
 
Tween.propHooks = { 
    _default: { 
        get: </span><span class="s2">function</span><span class="s1">( tween ) { 
            </span><span class="s2">var </span><span class="s1">result</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( tween.elem[ tween.prop ] != </span><span class="s2">null </span><span class="s1">&amp;&amp; 
                (!tween.elem.style || tween.elem.style[ tween.prop ] == </span><span class="s2">null</span><span class="s1">) ) { 
                </span><span class="s2">return </span><span class="s1">tween.elem[ tween.prop ]</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// passing an empty string as a 3rd parameter to .css will automatically</span><span class="s1"> 
            </span><span class="s0">// attempt a parseFloat and fallback to a string if the parse fails</span><span class="s1"> 
            </span><span class="s0">// so, simple values such as &quot;10px&quot; are parsed to Float.</span><span class="s1"> 
            </span><span class="s0">// complex values such as &quot;rotate(1rad)&quot; are returned as is.</span><span class="s1"> 
            result = jQuery.css( tween.elem</span><span class="s3">, </span><span class="s1">tween.prop</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">!result || result === </span><span class="s4">&quot;auto&quot; </span><span class="s1">? </span><span class="s5">0 </span><span class="s1">: result</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
        set: </span><span class="s2">function</span><span class="s1">( tween ) { 
            </span><span class="s0">// use step hook for back compat - use cssHook if its there - use .style if its</span><span class="s1"> 
            </span><span class="s0">// available and use plain properties where available</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.fx.step[ tween.prop ] ) { 
                jQuery.fx.step[ tween.prop ]( tween )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != </span><span class="s2">null </span><span class="s1">|| jQuery.cssHooks[ tween.prop ] ) ) { 
                jQuery.style( tween.elem</span><span class="s3">, </span><span class="s1">tween.prop</span><span class="s3">, </span><span class="s1">tween.now + tween.unit )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                tween.elem[ tween.prop ] = tween.now</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Support: IE &lt;=9</span><span class="s1"> 
</span><span class="s0">// Panic based approach to setting things on disconnected nodes</span><span class="s1"> 
 
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = { 
    set: </span><span class="s2">function</span><span class="s1">( tween ) { 
        </span><span class="s2">if </span><span class="s1">( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) { 
            tween.elem[ tween.prop ] = tween.now</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.easing = { 
    linear: </span><span class="s2">function</span><span class="s1">( p ) { 
        </span><span class="s2">return </span><span class="s1">p</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    swing: </span><span class="s2">function</span><span class="s1">( p ) { 
        </span><span class="s2">return </span><span class="s5">0.5 </span><span class="s1">- Math.cos( p * Math.PI ) / </span><span class="s5">2</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx = Tween.prototype.init</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Back Compat &lt;1.8 extension point</span><span class="s1"> 
jQuery.fx.step = {}</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s2">var</span><span class="s1"> 
    fxNow</span><span class="s3">, </span><span class="s1">timerId</span><span class="s3">,</span><span class="s1"> 
    rfxtypes = </span><span class="s4">/^(?:toggle|show|hide)$/</span><span class="s3">,</span><span class="s1"> 
    rfxnum = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s4">&quot;^(?:([+-])=|)(&quot; </span><span class="s1">+ pnum + </span><span class="s4">&quot;)([a-z%]*)$&quot;</span><span class="s3">, </span><span class="s4">&quot;i&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    rrun = </span><span class="s4">/queueHooks$/</span><span class="s3">,</span><span class="s1"> 
    animationPrefilters = [ defaultPrefilter ]</span><span class="s3">,</span><span class="s1"> 
    tweeners = { 
        </span><span class="s4">&quot;*&quot;</span><span class="s1">: [ </span><span class="s2">function</span><span class="s1">( prop</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">var </span><span class="s1">tween = </span><span class="s2">this</span><span class="s1">.createTween( prop</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">,</span><span class="s1"> 
                target = tween.cur()</span><span class="s3">,</span><span class="s1"> 
                parts = rfxnum.exec( value )</span><span class="s3">,</span><span class="s1"> 
                unit = parts &amp;&amp; parts[ </span><span class="s5">3 </span><span class="s1">] || ( jQuery.cssNumber[ prop ] ? </span><span class="s4">&quot;&quot; </span><span class="s1">: </span><span class="s4">&quot;px&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Starting value computation is required for potential unit mismatches</span><span class="s1"> 
                start = ( jQuery.cssNumber[ prop ] || unit !== </span><span class="s4">&quot;px&quot; </span><span class="s1">&amp;&amp; +target ) &amp;&amp; 
                    rfxnum.exec( jQuery.css( tween.elem</span><span class="s3">, </span><span class="s1">prop ) )</span><span class="s3">,</span><span class="s1"> 
                scale = </span><span class="s5">1</span><span class="s3">,</span><span class="s1"> 
                maxIterations = </span><span class="s5">20</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( start &amp;&amp; start[ </span><span class="s5">3 </span><span class="s1">] !== unit ) { 
                </span><span class="s0">// Trust units reported by jQuery.css</span><span class="s1"> 
                unit = unit || start[ </span><span class="s5">3 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Make sure we update the tween properties later on</span><span class="s1"> 
                parts = parts || []</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Iteratively approximate from a nonzero starting point</span><span class="s1"> 
                start = +target || </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">do </span><span class="s1">{ 
                    </span><span class="s0">// If previous iteration zeroed out, double until we get *something*</span><span class="s1"> 
                    </span><span class="s0">// Use a string for doubling factor so we don't accidentally see scale as unchanged below</span><span class="s1"> 
                    scale = scale || </span><span class="s4">&quot;.5&quot;</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Adjust and apply</span><span class="s1"> 
                    start = start / scale</span><span class="s3">;</span><span class="s1"> 
                    jQuery.style( tween.elem</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">start + unit )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Update scale, tolerating zero or NaN from tween.cur()</span><span class="s1"> 
                </span><span class="s0">// And breaking the loop if scale is unchanged or perfect, or if we've just had enough</span><span class="s1"> 
                } </span><span class="s2">while </span><span class="s1">( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== </span><span class="s5">1 </span><span class="s1">&amp;&amp; --maxIterations )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Update tween properties</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( parts ) { 
                start = tween.start = +start || +target || </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                tween.unit = unit</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// If a +=/-= token was provided, we're doing a relative animation</span><span class="s1"> 
                tween.end = parts[ </span><span class="s5">1 </span><span class="s1">] ? 
                    start + ( parts[ </span><span class="s5">1 </span><span class="s1">] + </span><span class="s5">1 </span><span class="s1">) * parts[ </span><span class="s5">2 </span><span class="s1">] : 
                    +parts[ </span><span class="s5">2 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return </span><span class="s1">tween</span><span class="s3">;</span><span class="s1"> 
        } ] 
    }</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Animations created synchronously will run synchronously</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createFxNow() { 
    setTimeout(</span><span class="s2">function</span><span class="s1">() { 
        fxNow = undefined</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">( fxNow = jQuery.now() )</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Generate parameters to create a standard animation</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">genFx( type</span><span class="s3">, </span><span class="s1">includeWidth ) { 
    </span><span class="s2">var </span><span class="s1">which</span><span class="s3">,</span><span class="s1"> 
        attrs = { height: type }</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// if we include width, step value is 1 to do all cssExpand values,</span><span class="s1"> 
    </span><span class="s0">// if we don't include width, step value is 2 to skip over Left and Right</span><span class="s1"> 
    includeWidth = includeWidth ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; </span><span class="s5">4 </span><span class="s3">; </span><span class="s1">i += </span><span class="s5">2 </span><span class="s1">- includeWidth ) { 
        which = cssExpand[ i ]</span><span class="s3">;</span><span class="s1"> 
        attrs[ </span><span class="s4">&quot;margin&quot; </span><span class="s1">+ which ] = attrs[ </span><span class="s4">&quot;padding&quot; </span><span class="s1">+ which ] = type</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( includeWidth ) { 
        attrs.opacity = attrs.width = type</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">attrs</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">function </span><span class="s1">createTween( value</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">animation ) { 
    </span><span class="s2">var </span><span class="s1">tween</span><span class="s3">,</span><span class="s1"> 
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ </span><span class="s4">&quot;*&quot; </span><span class="s1">] )</span><span class="s3">,</span><span class="s1"> 
        index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        length = collection.length</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length</span><span class="s3">; </span><span class="s1">index++ ) { 
        </span><span class="s2">if </span><span class="s1">( (tween = collection[ index ].call( animation</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">value )) ) { 
 
            </span><span class="s0">// we're done with this property</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">tween</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
} 
 
</span><span class="s2">function </span><span class="s1">defaultPrefilter( elem</span><span class="s3">, </span><span class="s1">props</span><span class="s3">, </span><span class="s1">opts ) { 
    </span><span class="s0">/* jshint validthis: true */</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">toggle</span><span class="s3">, </span><span class="s1">tween</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">, </span><span class="s1">oldfire</span><span class="s3">, </span><span class="s1">display</span><span class="s3">, </span><span class="s1">checkDisplay</span><span class="s3">,</span><span class="s1"> 
        anim = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
        orig = {}</span><span class="s3">,</span><span class="s1"> 
        style = elem.style</span><span class="s3">,</span><span class="s1"> 
        hidden = elem.nodeType &amp;&amp; isHidden( elem )</span><span class="s3">,</span><span class="s1"> 
        dataShow = jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;fxshow&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// handle queue: false promises</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !opts.queue ) { 
        hooks = jQuery._queueHooks( elem</span><span class="s3">, </span><span class="s4">&quot;fx&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( hooks.unqueued == </span><span class="s2">null </span><span class="s1">) { 
            hooks.unqueued = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            oldfire = hooks.empty.fire</span><span class="s3">;</span><span class="s1"> 
            hooks.empty.fire = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( !hooks.unqueued ) { 
                    oldfire()</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">;</span><span class="s1"> 
        } 
        hooks.unqueued++</span><span class="s3">;</span><span class="s1"> 
 
        anim.always(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// doing this makes sure that the complete handler will be called</span><span class="s1"> 
            </span><span class="s0">// before this completes</span><span class="s1"> 
            anim.always(</span><span class="s2">function</span><span class="s1">() { 
                hooks.unqueued--</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !jQuery.queue( elem</span><span class="s3">, </span><span class="s4">&quot;fx&quot; </span><span class="s1">).length ) { 
                    hooks.empty.fire()</span><span class="s3">;</span><span class="s1"> 
                } 
            })</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// height/width overflow pass</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; ( </span><span class="s4">&quot;height&quot; </span><span class="s2">in </span><span class="s1">props || </span><span class="s4">&quot;width&quot; </span><span class="s2">in </span><span class="s1">props ) ) { 
        </span><span class="s0">// Make sure that nothing sneaks out</span><span class="s1"> 
        </span><span class="s0">// Record all 3 overflow attributes because IE does not</span><span class="s1"> 
        </span><span class="s0">// change the overflow attribute when overflowX and</span><span class="s1"> 
        </span><span class="s0">// overflowY are set to the same value</span><span class="s1"> 
        opts.overflow = [ style.overflow</span><span class="s3">, </span><span class="s1">style.overflowX</span><span class="s3">, </span><span class="s1">style.overflowY ]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Set display property to inline-block for height/width</span><span class="s1"> 
        </span><span class="s0">// animations on inline elements that are having width/height animated</span><span class="s1"> 
        display = jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Test default display if display is currently &quot;none&quot;</span><span class="s1"> 
        checkDisplay = display === </span><span class="s4">&quot;none&quot; </span><span class="s1">? 
            jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;olddisplay&quot; </span><span class="s1">) || defaultDisplay( elem.nodeName ) : display</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( checkDisplay === </span><span class="s4">&quot;inline&quot; </span><span class="s1">&amp;&amp; jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;float&quot; </span><span class="s1">) === </span><span class="s4">&quot;none&quot; </span><span class="s1">) { 
 
            </span><span class="s0">// inline-level elements accept inline-block;</span><span class="s1"> 
            </span><span class="s0">// block-level elements need to be inline with layout</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === </span><span class="s4">&quot;inline&quot; </span><span class="s1">) { 
                style.display = </span><span class="s4">&quot;inline-block&quot;</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                style.zoom = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s2">if </span><span class="s1">( opts.overflow ) { 
        style.overflow = </span><span class="s4">&quot;hidden&quot;</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !support.shrinkWrapBlocks() ) { 
            anim.always(</span><span class="s2">function</span><span class="s1">() { 
                style.overflow = opts.overflow[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                style.overflowX = opts.overflow[ </span><span class="s5">1 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                style.overflowY = opts.overflow[ </span><span class="s5">2 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// show/hide pass</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">props ) { 
        value = props[ prop ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( rfxtypes.exec( value ) ) { 
            </span><span class="s2">delete </span><span class="s1">props[ prop ]</span><span class="s3">;</span><span class="s1"> 
            toggle = toggle || value === </span><span class="s4">&quot;toggle&quot;</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( value === ( hidden ? </span><span class="s4">&quot;hide&quot; </span><span class="s1">: </span><span class="s4">&quot;show&quot; </span><span class="s1">) ) { 
 
                </span><span class="s0">// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( value === </span><span class="s4">&quot;show&quot; </span><span class="s1">&amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) { 
                    hidden = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s2">continue</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem</span><span class="s3">, </span><span class="s1">prop )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Any non-fx value stops us from restoring the original display value</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            display = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">if </span><span class="s1">( !jQuery.isEmptyObject( orig ) ) { 
        </span><span class="s2">if </span><span class="s1">( dataShow ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s4">&quot;hidden&quot; </span><span class="s2">in </span><span class="s1">dataShow ) { 
                hidden = dataShow.hidden</span><span class="s3">;</span><span class="s1"> 
            } 
        } </span><span class="s2">else </span><span class="s1">{ 
            dataShow = jQuery._data( elem</span><span class="s3">, </span><span class="s4">&quot;fxshow&quot;</span><span class="s3">, </span><span class="s1">{} )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// store state if its toggle - enables .stop().toggle() to &quot;reverse&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( toggle ) { 
            dataShow.hidden = !hidden</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( hidden ) { 
            jQuery( elem ).show()</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            anim.done(</span><span class="s2">function</span><span class="s1">() { 
                jQuery( elem ).hide()</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
        anim.done(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">prop</span><span class="s3">;</span><span class="s1"> 
            jQuery._removeData( elem</span><span class="s3">, </span><span class="s4">&quot;fxshow&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">orig ) { 
                jQuery.style( elem</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">orig[ prop ] )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">orig ) { 
            tween = createTween( hidden ? dataShow[ prop ] : </span><span class="s5">0</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">anim )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( !( prop </span><span class="s2">in </span><span class="s1">dataShow ) ) { 
                dataShow[ prop ] = tween.start</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( hidden ) { 
                    tween.end = tween.start</span><span class="s3">;</span><span class="s1"> 
                    tween.start = prop === </span><span class="s4">&quot;width&quot; </span><span class="s1">|| prop === </span><span class="s4">&quot;height&quot; </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
    </span><span class="s0">// If this is a noop like .hide().hide(), restore an overwritten display value</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( (display === </span><span class="s4">&quot;none&quot; </span><span class="s1">? defaultDisplay( elem.nodeName ) : display) === </span><span class="s4">&quot;inline&quot; </span><span class="s1">) { 
        style.display = display</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s2">function </span><span class="s1">propFilter( props</span><span class="s3">, </span><span class="s1">specialEasing ) { 
    </span><span class="s2">var </span><span class="s1">index</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// camelCase, specialEasing and expand cssHook pass</span><span class="s1"> 
    </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">props ) { 
        name = jQuery.camelCase( index )</span><span class="s3">;</span><span class="s1"> 
        easing = specialEasing[ name ]</span><span class="s3">;</span><span class="s1"> 
        value = props[ index ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.isArray( value ) ) { 
            easing = value[ </span><span class="s5">1 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
            value = props[ index ] = value[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( index !== name ) { 
            props[ name ] = value</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">props[ index ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        hooks = jQuery.cssHooks[ name ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;expand&quot; </span><span class="s2">in </span><span class="s1">hooks ) { 
            value = hooks.expand( value )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">props[ name ]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// not quite $.extend, this wont overwrite keys already present.</span><span class="s1"> 
            </span><span class="s0">// also - reusing 'index' from above because we have the correct &quot;name&quot;</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">value ) { 
                </span><span class="s2">if </span><span class="s1">( !( index </span><span class="s2">in </span><span class="s1">props ) ) { 
                    props[ index ] = value[ index ]</span><span class="s3">;</span><span class="s1"> 
                    specialEasing[ index ] = easing</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } </span><span class="s2">else </span><span class="s1">{ 
            specialEasing[ name ] = easing</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
} 
 
</span><span class="s2">function </span><span class="s1">Animation( elem</span><span class="s3">, </span><span class="s1">properties</span><span class="s3">, </span><span class="s1">options ) { 
    </span><span class="s2">var </span><span class="s1">result</span><span class="s3">,</span><span class="s1"> 
        stopped</span><span class="s3">,</span><span class="s1"> 
        index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
        length = animationPrefilters.length</span><span class="s3">,</span><span class="s1"> 
        deferred = jQuery.Deferred().always( </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// don't match elem in the :animated selector</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">tick.elem</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">,</span><span class="s1"> 
        tick = </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( stopped ) { 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">var </span><span class="s1">currentTime = fxNow || createFxNow()</span><span class="s3">,</span><span class="s1"> 
                remaining = Math.max( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">animation.startTime + animation.duration - currentTime )</span><span class="s3">,</span><span class="s1"> 
                </span><span class="s0">// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)</span><span class="s1"> 
                temp = remaining / animation.duration || </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                percent = </span><span class="s5">1 </span><span class="s1">- temp</span><span class="s3">,</span><span class="s1"> 
                index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                length = animation.tweens.length</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length </span><span class="s3">; </span><span class="s1">index++ ) { 
                animation.tweens[ index ].run( percent )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            deferred.notifyWith( elem</span><span class="s3">, </span><span class="s1">[ animation</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">remaining ])</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( percent &lt; </span><span class="s5">1 </span><span class="s1">&amp;&amp; length ) { 
                </span><span class="s2">return </span><span class="s1">remaining</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                deferred.resolveWith( elem</span><span class="s3">, </span><span class="s1">[ animation ] )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
        animation = deferred.promise({ 
            elem: elem</span><span class="s3">,</span><span class="s1"> 
            props: jQuery.extend( {}</span><span class="s3">, </span><span class="s1">properties )</span><span class="s3">,</span><span class="s1"> 
            opts: jQuery.extend( </span><span class="s2">true</span><span class="s3">, </span><span class="s1">{ specialEasing: {} }</span><span class="s3">, </span><span class="s1">options )</span><span class="s3">,</span><span class="s1"> 
            originalProperties: properties</span><span class="s3">,</span><span class="s1"> 
            originalOptions: options</span><span class="s3">,</span><span class="s1"> 
            startTime: fxNow || createFxNow()</span><span class="s3">,</span><span class="s1"> 
            duration: options.duration</span><span class="s3">,</span><span class="s1"> 
            tweens: []</span><span class="s3">,</span><span class="s1"> 
            createTween: </span><span class="s2">function</span><span class="s1">( prop</span><span class="s3">, </span><span class="s1">end ) { 
                </span><span class="s2">var </span><span class="s1">tween = jQuery.Tween( elem</span><span class="s3">, </span><span class="s1">animation.opts</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">, </span><span class="s1">end</span><span class="s3">,</span><span class="s1"> 
                        animation.opts.specialEasing[ prop ] || animation.opts.easing )</span><span class="s3">;</span><span class="s1"> 
                animation.tweens.push( tween )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">tween</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
            stop: </span><span class="s2">function</span><span class="s1">( gotoEnd ) { 
                </span><span class="s2">var </span><span class="s1">index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                    </span><span class="s0">// if we are going to the end, we want to run all the tweens</span><span class="s1"> 
                    </span><span class="s0">// otherwise we skip this part</span><span class="s1"> 
                    length = gotoEnd ? animation.tweens.length : </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( stopped ) { 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                } 
                stopped = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length </span><span class="s3">; </span><span class="s1">index++ ) { 
                    animation.tweens[ index ].run( </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// resolve when we played the last frame</span><span class="s1"> 
                </span><span class="s0">// otherwise, reject</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( gotoEnd ) { 
                    deferred.resolveWith( elem</span><span class="s3">, </span><span class="s1">[ animation</span><span class="s3">, </span><span class="s1">gotoEnd ] )</span><span class="s3">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    deferred.rejectWith( elem</span><span class="s3">, </span><span class="s1">[ animation</span><span class="s3">, </span><span class="s1">gotoEnd ] )</span><span class="s3">;</span><span class="s1"> 
                } 
                </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">,</span><span class="s1"> 
        props = animation.props</span><span class="s3">;</span><span class="s1"> 
 
    propFilter( props</span><span class="s3">, </span><span class="s1">animation.opts.specialEasing )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length </span><span class="s3">; </span><span class="s1">index++ ) { 
        result = animationPrefilters[ index ].call( animation</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">props</span><span class="s3">, </span><span class="s1">animation.opts )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( result ) { 
            </span><span class="s2">return </span><span class="s1">result</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    jQuery.map( props</span><span class="s3">, </span><span class="s1">createTween</span><span class="s3">, </span><span class="s1">animation )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( animation.opts.start ) ) { 
        animation.opts.start.call( elem</span><span class="s3">, </span><span class="s1">animation )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    jQuery.fx.timer( 
        jQuery.extend( tick</span><span class="s3">, </span><span class="s1">{ 
            elem: elem</span><span class="s3">,</span><span class="s1"> 
            anim: animation</span><span class="s3">,</span><span class="s1"> 
            queue: animation.opts.queue 
        }) 
    )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// attach callbacks from options</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">animation.progress( animation.opts.progress ) 
        .done( animation.opts.done</span><span class="s3">, </span><span class="s1">animation.opts.complete ) 
        .fail( animation.opts.fail ) 
        .always( animation.opts.always )</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.Animation = jQuery.extend( Animation</span><span class="s3">, </span><span class="s1">{ 
    tweener: </span><span class="s2">function</span><span class="s1">( props</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( props ) ) { 
            callback = props</span><span class="s3">;</span><span class="s1"> 
            props = [ </span><span class="s4">&quot;*&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            props = props.split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">var </span><span class="s1">prop</span><span class="s3">,</span><span class="s1"> 
            index = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            length = props.length</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">index &lt; length </span><span class="s3">; </span><span class="s1">index++ ) { 
            prop = props[ index ]</span><span class="s3">;</span><span class="s1"> 
            tweeners[ prop ] = tweeners[ prop ] || []</span><span class="s3">;</span><span class="s1"> 
            tweeners[ prop ].unshift( callback )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    prefilter: </span><span class="s2">function</span><span class="s1">( callback</span><span class="s3">, </span><span class="s1">prepend ) { 
        </span><span class="s2">if </span><span class="s1">( prepend ) { 
            animationPrefilters.unshift( callback )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            animationPrefilters.push( callback )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.speed = </span><span class="s2">function</span><span class="s1">( speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">fn ) { 
    </span><span class="s2">var </span><span class="s1">opt = speed &amp;&amp; </span><span class="s2">typeof </span><span class="s1">speed === </span><span class="s4">&quot;object&quot; </span><span class="s1">? jQuery.extend( {}</span><span class="s3">, </span><span class="s1">speed ) : { 
        complete: fn || !fn &amp;&amp; easing || 
            jQuery.isFunction( speed ) &amp;&amp; speed</span><span class="s3">,</span><span class="s1"> 
        duration: speed</span><span class="s3">,</span><span class="s1"> 
        easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing 
    }</span><span class="s3">;</span><span class="s1"> 
 
    opt.duration = jQuery.fx.off ? </span><span class="s5">0 </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">opt.duration === </span><span class="s4">&quot;number&quot; </span><span class="s1">? opt.duration : 
        opt.duration </span><span class="s2">in </span><span class="s1">jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( opt.queue == </span><span class="s2">null </span><span class="s1">|| opt.queue === </span><span class="s2">true </span><span class="s1">) { 
        opt.queue = </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// Queueing</span><span class="s1"> 
    opt.old = opt.complete</span><span class="s3">;</span><span class="s1"> 
 
    opt.complete = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( opt.old ) ) { 
            opt.old.call( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( opt.queue ) { 
            jQuery.dequeue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">opt.queue )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return </span><span class="s1">opt</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    fadeTo: </span><span class="s2">function</span><span class="s1">( speed</span><span class="s3">, </span><span class="s1">to</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback ) { 
 
        </span><span class="s0">// show any hidden elements after setting opacity to 0</span><span class="s1"> 
        </span><span class="s2">return this</span><span class="s1">.filter( isHidden ).css( </span><span class="s4">&quot;opacity&quot;</span><span class="s3">, </span><span class="s5">0 </span><span class="s1">).show() 
 
            </span><span class="s0">// animate to the value specified</span><span class="s1"> 
            .end().animate({ opacity: to }</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    animate: </span><span class="s2">function</span><span class="s1">( prop</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">var </span><span class="s1">empty = jQuery.isEmptyObject( prop )</span><span class="s3">,</span><span class="s1"> 
            optall = jQuery.speed( speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback )</span><span class="s3">,</span><span class="s1"> 
            doAnimation = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s0">// Operate on a copy of prop so per-property easing won't be lost</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">anim = Animation( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">jQuery.extend( {}</span><span class="s3">, </span><span class="s1">prop )</span><span class="s3">, </span><span class="s1">optall )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Empty animations, or finishing resolves immediately</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( empty || jQuery._data( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;finish&quot; </span><span class="s1">) ) { 
                    anim.stop( </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">;</span><span class="s1"> 
            doAnimation.finish = doAnimation</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">empty || optall.queue === </span><span class="s2">false </span><span class="s1">? 
            </span><span class="s2">this</span><span class="s1">.each( doAnimation ) : 
            </span><span class="s2">this</span><span class="s1">.queue( optall.queue</span><span class="s3">, </span><span class="s1">doAnimation )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    stop: </span><span class="s2">function</span><span class="s1">( type</span><span class="s3">, </span><span class="s1">clearQueue</span><span class="s3">, </span><span class="s1">gotoEnd ) { 
        </span><span class="s2">var </span><span class="s1">stopQueue = </span><span class="s2">function</span><span class="s1">( hooks ) { 
            </span><span class="s2">var </span><span class="s1">stop = hooks.stop</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">hooks.stop</span><span class="s3">;</span><span class="s1"> 
            stop( gotoEnd )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            gotoEnd = clearQueue</span><span class="s3">;</span><span class="s1"> 
            clearQueue = type</span><span class="s3">;</span><span class="s1"> 
            type = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( clearQueue &amp;&amp; type !== </span><span class="s2">false </span><span class="s1">) { 
            </span><span class="s2">this</span><span class="s1">.queue( type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">, </span><span class="s1">[] )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">dequeue = </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
                index = type != </span><span class="s2">null </span><span class="s1">&amp;&amp; type + </span><span class="s4">&quot;queueHooks&quot;</span><span class="s3">,</span><span class="s1"> 
                timers = jQuery.timers</span><span class="s3">,</span><span class="s1"> 
                data = jQuery._data( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( index ) { 
                </span><span class="s2">if </span><span class="s1">( data[ index ] &amp;&amp; data[ index ].stop ) { 
                    stopQueue( data[ index ] )</span><span class="s3">;</span><span class="s1"> 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">data ) { 
                    </span><span class="s2">if </span><span class="s1">( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) { 
                        stopQueue( data[ index ] )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
            </span><span class="s2">for </span><span class="s1">( index = timers.length</span><span class="s3">; </span><span class="s1">index--</span><span class="s3">; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( timers[ index ].elem === </span><span class="s2">this </span><span class="s1">&amp;&amp; (type == </span><span class="s2">null </span><span class="s1">|| timers[ index ].queue === type) ) { 
                    timers[ index ].anim.stop( gotoEnd )</span><span class="s3">;</span><span class="s1"> 
                    dequeue = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                    timers.splice( index</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// start the next in the queue if the last step wasn't forced</span><span class="s1"> 
            </span><span class="s0">// timers currently will call their complete callbacks, which will dequeue</span><span class="s1"> 
            </span><span class="s0">// but only if they were gotoEnd</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( dequeue || !gotoEnd ) { 
                jQuery.dequeue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    finish: </span><span class="s2">function</span><span class="s1">( type ) { 
        </span><span class="s2">if </span><span class="s1">( type !== </span><span class="s2">false </span><span class="s1">) { 
            type = type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">index</span><span class="s3">,</span><span class="s1"> 
                data = jQuery._data( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                queue = data[ type + </span><span class="s4">&quot;queue&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                hooks = data[ type + </span><span class="s4">&quot;queueHooks&quot; </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
                timers = jQuery.timers</span><span class="s3">,</span><span class="s1"> 
                length = queue ? queue.length : </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// enable finishing flag on private data</span><span class="s1"> 
            data.finish = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// empty the queue first</span><span class="s1"> 
            jQuery.queue( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">[] )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; hooks.stop ) { 
                hooks.stop.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// look for any active animations, and finish them</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( index = timers.length</span><span class="s3">; </span><span class="s1">index--</span><span class="s3">; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( timers[ index ].elem === </span><span class="s2">this </span><span class="s1">&amp;&amp; timers[ index ].queue === type ) { 
                    timers[ index ].anim.stop( </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    timers.splice( index</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// look for any animations in the old queue and finish them</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( index = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index &lt; length</span><span class="s3">; </span><span class="s1">index++ ) { 
                </span><span class="s2">if </span><span class="s1">( queue[ index ] &amp;&amp; queue[ index ].finish ) { 
                    queue[ index ].finish.call( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
 
            </span><span class="s0">// turn off finishing flag</span><span class="s1"> 
            </span><span class="s2">delete </span><span class="s1">data.finish</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.each([ </span><span class="s4">&quot;toggle&quot;</span><span class="s3">, </span><span class="s4">&quot;show&quot;</span><span class="s3">, </span><span class="s4">&quot;hide&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
    </span><span class="s2">var </span><span class="s1">cssFn = jQuery.fn[ name ]</span><span class="s3">;</span><span class="s1"> 
    jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">return </span><span class="s1">speed == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">speed === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">? 
            cssFn.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments ) : 
            </span><span class="s2">this</span><span class="s1">.animate( genFx( name</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Generate shortcuts for custom animations</span><span class="s1"> 
jQuery.each({ 
    slideDown: genFx(</span><span class="s4">&quot;show&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    slideUp: genFx(</span><span class="s4">&quot;hide&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    slideToggle: genFx(</span><span class="s4">&quot;toggle&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
    fadeIn: { opacity: </span><span class="s4">&quot;show&quot; </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
    fadeOut: { opacity: </span><span class="s4">&quot;hide&quot; </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
    fadeToggle: { opacity: </span><span class="s4">&quot;toggle&quot; </span><span class="s1">} 
}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">props ) { 
    jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">return this</span><span class="s1">.animate( props</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">easing</span><span class="s3">, </span><span class="s1">callback )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.timers = []</span><span class="s3">;</span><span class="s1"> 
jQuery.fx.tick = </span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">var </span><span class="s1">timer</span><span class="s3">,</span><span class="s1"> 
        timers = jQuery.timers</span><span class="s3">,</span><span class="s1"> 
        i = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
    fxNow = jQuery.now()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; timers.length</span><span class="s3">; </span><span class="s1">i++ ) { 
        timer = timers[ i ]</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s0">// Checks the timer has not already been removed</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !timer() &amp;&amp; timers[ i ] === timer ) { 
            timers.splice( i--</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s2">if </span><span class="s1">( !timers.length ) { 
        jQuery.fx.stop()</span><span class="s3">;</span><span class="s1"> 
    } 
    fxNow = undefined</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx.timer = </span><span class="s2">function</span><span class="s1">( timer ) { 
    jQuery.timers.push( timer )</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( timer() ) { 
        jQuery.fx.start()</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        jQuery.timers.pop()</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx.interval = </span><span class="s5">13</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx.start = </span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">if </span><span class="s1">( !timerId ) { 
        timerId = setInterval( jQuery.fx.tick</span><span class="s3">, </span><span class="s1">jQuery.fx.interval )</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx.stop = </span><span class="s2">function</span><span class="s1">() { 
    clearInterval( timerId )</span><span class="s3">;</span><span class="s1"> 
    timerId = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fx.speeds = { 
    slow: </span><span class="s5">600</span><span class="s3">,</span><span class="s1"> 
    fast: </span><span class="s5">200</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s0">// Default speed</span><span class="s1"> 
    _default: </span><span class="s5">400</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Based off of the plugin by Clint Helfers, with permission.</span><span class="s1"> 
</span><span class="s0">// http://blindsignals.com/index.php/2009/07/jquery-delay/</span><span class="s1"> 
jQuery.fn.delay = </span><span class="s2">function</span><span class="s1">( time</span><span class="s3">, </span><span class="s1">type ) { 
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time</span><span class="s3">;</span><span class="s1"> 
    type = type || </span><span class="s4">&quot;fx&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">return this</span><span class="s1">.queue( type</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( next</span><span class="s3">, </span><span class="s1">hooks ) { 
        </span><span class="s2">var </span><span class="s1">timeout = setTimeout( next</span><span class="s3">, </span><span class="s1">time )</span><span class="s3">;</span><span class="s1"> 
        hooks.stop = </span><span class="s2">function</span><span class="s1">() { 
            clearTimeout( timeout )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
(</span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s0">// Minified: var a,b,c,d,e</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">input</span><span class="s3">, </span><span class="s1">div</span><span class="s3">, </span><span class="s1">select</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">opt</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Setup</span><span class="s1"> 
    div = document.createElement( </span><span class="s4">&quot;div&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    div.setAttribute( </span><span class="s4">&quot;className&quot;</span><span class="s3">, </span><span class="s4">&quot;t&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    div.innerHTML = </span><span class="s4">&quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;&quot;</span><span class="s3">;</span><span class="s1"> 
    a = div.getElementsByTagName(</span><span class="s4">&quot;a&quot;</span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// First batch of tests.</span><span class="s1"> 
    select = document.createElement(</span><span class="s4">&quot;select&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    opt = select.appendChild( document.createElement(</span><span class="s4">&quot;option&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
    input = div.getElementsByTagName(</span><span class="s4">&quot;input&quot;</span><span class="s1">)[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
    a.style.cssText = </span><span class="s4">&quot;top:1px&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)</span><span class="s1"> 
    support.getSetAttribute = div.className !== </span><span class="s4">&quot;t&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Get the style information from getAttribute</span><span class="s1"> 
    </span><span class="s0">// (IE uses .cssText instead)</span><span class="s1"> 
    support.style = </span><span class="s4">/top/</span><span class="s1">.test( a.getAttribute(</span><span class="s4">&quot;style&quot;</span><span class="s1">) )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure that URLs aren't manipulated</span><span class="s1"> 
    </span><span class="s0">// (IE normalizes it by default)</span><span class="s1"> 
    support.hrefNormalized = a.getAttribute(</span><span class="s4">&quot;href&quot;</span><span class="s1">) === </span><span class="s4">&quot;/a&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Check the default checkbox/radio value (&quot;&quot; on WebKit; &quot;on&quot; elsewhere)</span><span class="s1"> 
    support.checkOn = !!input.value</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure that a selected-by-default option has a working selected property.</span><span class="s1"> 
    </span><span class="s0">// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)</span><span class="s1"> 
    support.optSelected = opt.selected</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Tests for enctype support on a form (#6743)</span><span class="s1"> 
    support.enctype = !!document.createElement(</span><span class="s4">&quot;form&quot;</span><span class="s1">).enctype</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Make sure that the options inside disabled selects aren't marked as disabled</span><span class="s1"> 
    </span><span class="s0">// (WebKit marks them as disabled)</span><span class="s1"> 
    select.disabled = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
    support.optDisabled = !opt.disabled</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE8 only</span><span class="s1"> 
    </span><span class="s0">// Check if we can trust getAttribute(&quot;value&quot;)</span><span class="s1"> 
    input = document.createElement( </span><span class="s4">&quot;input&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    input.setAttribute( </span><span class="s4">&quot;value&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    support.input = input.getAttribute( </span><span class="s4">&quot;value&quot; </span><span class="s1">) === </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Check if an input maintains its value after becoming a radio</span><span class="s1"> 
    input.value = </span><span class="s4">&quot;t&quot;</span><span class="s3">;</span><span class="s1"> 
    input.setAttribute( </span><span class="s4">&quot;type&quot;</span><span class="s3">, </span><span class="s4">&quot;radio&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    support.radioValue = input.value === </span><span class="s4">&quot;t&quot;</span><span class="s3">;</span><span class="s1"> 
})()</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">rreturn = </span><span class="s4">/\r/g</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    val: </span><span class="s2">function</span><span class="s1">( value ) { 
        </span><span class="s2">var </span><span class="s1">hooks</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">isFunction</span><span class="s3">,</span><span class="s1"> 
            elem = </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !arguments.length ) { 
            </span><span class="s2">if </span><span class="s1">( elem ) { 
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.get( elem</span><span class="s3">, </span><span class="s4">&quot;value&quot; </span><span class="s1">)) !== undefined ) { 
                    </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
                } 
 
                ret = elem.value</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">return typeof </span><span class="s1">ret === </span><span class="s4">&quot;string&quot; </span><span class="s1">? 
                    </span><span class="s0">// handle most common string cases</span><span class="s1"> 
                    ret.replace(rreturn</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">) : 
                    </span><span class="s0">// handle cases where value is null/undef or number</span><span class="s1"> 
                    ret == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">&quot;&quot; </span><span class="s1">: ret</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        isFunction = jQuery.isFunction( value )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( i ) { 
            </span><span class="s2">var </span><span class="s1">val</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType !== </span><span class="s5">1 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( isFunction ) { 
                val = value.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">jQuery( </span><span class="s2">this </span><span class="s1">).val() )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                val = value</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Treat null/undefined as &quot;&quot;; convert numbers to string</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( val == </span><span class="s2">null </span><span class="s1">) { 
                val = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s4">&quot;number&quot; </span><span class="s1">) { 
                val += </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( jQuery.isArray( val ) ) { 
                val = jQuery.map( val</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( value ) { 
                    </span><span class="s2">return </span><span class="s1">value == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">&quot;&quot; </span><span class="s1">: value + </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
                })</span><span class="s3">;</span><span class="s1"> 
            } 
 
            hooks = jQuery.valHooks[ </span><span class="s2">this</span><span class="s1">.type ] || jQuery.valHooks[ </span><span class="s2">this</span><span class="s1">.nodeName.toLowerCase() ]</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// If set returns undefined, fall back to normal setting</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !hooks || !(</span><span class="s4">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks) || hooks.set( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s4">&quot;value&quot; </span><span class="s1">) === undefined ) { 
                </span><span class="s2">this</span><span class="s1">.value = val</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    valHooks: { 
        option: { 
            get: </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">val = jQuery.find.attr( elem</span><span class="s3">, </span><span class="s4">&quot;value&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">val != </span><span class="s2">null </span><span class="s1">? 
                    val : 
                    </span><span class="s0">// Support: IE10-11+</span><span class="s1"> 
                    </span><span class="s0">// option.text throws exceptions (#14686, #14858)</span><span class="s1"> 
                    jQuery.trim( jQuery.text( elem ) )</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
        select: { 
            get: </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">value</span><span class="s3">, </span><span class="s1">option</span><span class="s3">,</span><span class="s1"> 
                    options = elem.options</span><span class="s3">,</span><span class="s1"> 
                    index = elem.selectedIndex</span><span class="s3">,</span><span class="s1"> 
                    one = elem.type === </span><span class="s4">&quot;select-one&quot; </span><span class="s1">|| index &lt; </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                    values = one ? </span><span class="s2">null </span><span class="s1">: []</span><span class="s3">,</span><span class="s1"> 
                    max = one ? index + </span><span class="s5">1 </span><span class="s1">: options.length</span><span class="s3">,</span><span class="s1"> 
                    i = index &lt; </span><span class="s5">0 </span><span class="s1">? 
                        max : 
                        one ? index : </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Loop through all the selected options</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; max</span><span class="s3">; </span><span class="s1">i++ ) { 
                    option = options[ i ]</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// oldIE doesn't update selected after form reset (#2551)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( ( option.selected || i === index ) &amp;&amp; 
                            </span><span class="s0">// Don't return options that are disabled or in a disabled optgroup</span><span class="s1"> 
                            ( support.optDisabled ? !option.disabled : option.getAttribute(</span><span class="s4">&quot;disabled&quot;</span><span class="s1">) === </span><span class="s2">null </span><span class="s1">) &amp;&amp; 
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode</span><span class="s3">, </span><span class="s4">&quot;optgroup&quot; </span><span class="s1">) ) ) { 
 
                        </span><span class="s0">// Get the specific value for the option</span><span class="s1"> 
                        value = jQuery( option ).val()</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// We don't need an array for one selects</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( one ) { 
                            </span><span class="s2">return </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        </span><span class="s0">// Multi-Selects return an array</span><span class="s1"> 
                        values.push( value )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">values</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
 
            set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
                </span><span class="s2">var </span><span class="s1">optionSet</span><span class="s3">, </span><span class="s1">option</span><span class="s3">,</span><span class="s1"> 
                    options = elem.options</span><span class="s3">,</span><span class="s1"> 
                    values = jQuery.makeArray( value )</span><span class="s3">,</span><span class="s1"> 
                    i = options.length</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                    option = options[ i ]</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( jQuery.inArray( jQuery.valHooks.option.get( option )</span><span class="s3">, </span><span class="s1">values ) &gt;= </span><span class="s5">0 </span><span class="s1">) { 
 
                        </span><span class="s0">// Support: IE6</span><span class="s1"> 
                        </span><span class="s0">// When new option element is added to select box we need to</span><span class="s1"> 
                        </span><span class="s0">// force reflow of newly added node in order to workaround delay</span><span class="s1"> 
                        </span><span class="s0">// of initialization properties</span><span class="s1"> 
                        </span><span class="s2">try </span><span class="s1">{ 
                            option.selected = optionSet = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
                        } </span><span class="s2">catch </span><span class="s1">( _ ) { 
 
                            </span><span class="s0">// Will be executed only in IE6</span><span class="s1"> 
                            option.scrollHeight</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        option.selected = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
                </span><span class="s0">// Force browsers to behave consistently when non-matching value is set</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !optionSet ) { 
                    elem.selectedIndex = -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">return </span><span class="s1">options</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Radios and checkboxes getter/setter</span><span class="s1"> 
jQuery.each([ </span><span class="s4">&quot;radio&quot;</span><span class="s3">, </span><span class="s4">&quot;checkbox&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
    jQuery.valHooks[ </span><span class="s2">this </span><span class="s1">] = { 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">if </span><span class="s1">( jQuery.isArray( value ) ) { 
                </span><span class="s2">return </span><span class="s1">( elem.checked = jQuery.inArray( jQuery(elem).val()</span><span class="s3">, </span><span class="s1">value ) &gt;= </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !support.checkOn ) { 
        jQuery.valHooks[ </span><span class="s2">this </span><span class="s1">].get = </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s0">// Support: Webkit</span><span class="s1"> 
            </span><span class="s0">// &quot;&quot; is returned instead of &quot;on&quot; if a value isn't specified</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">elem.getAttribute(</span><span class="s4">&quot;value&quot;</span><span class="s1">) === </span><span class="s2">null </span><span class="s1">? </span><span class="s4">&quot;on&quot; </span><span class="s1">: elem.value</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s2">var </span><span class="s1">nodeHook</span><span class="s3">, </span><span class="s1">boolHook</span><span class="s3">,</span><span class="s1"> 
    attrHandle = jQuery.expr.attrHandle</span><span class="s3">,</span><span class="s1"> 
    ruseDefault = </span><span class="s4">/^(?:checked|selected)$/i</span><span class="s3">,</span><span class="s1"> 
    getSetAttribute = support.getSetAttribute</span><span class="s3">,</span><span class="s1"> 
    getSetInput = support.input</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    attr: </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">jQuery.attr</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">arguments.length &gt; </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeAttr: </span><span class="s2">function</span><span class="s1">( name ) { 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            jQuery.removeAttr( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    attr: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">var </span><span class="s1">hooks</span><span class="s3">, </span><span class="s1">ret</span><span class="s3">,</span><span class="s1"> 
            nType = elem.nodeType</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// don't get/set attributes on text, comment and attribute nodes</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem || nType === </span><span class="s5">3 </span><span class="s1">|| nType === </span><span class="s5">8 </span><span class="s1">|| nType === </span><span class="s5">2 </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Fallback to prop when attributes are not supported</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.getAttribute === strundefined ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.prop( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// All attributes are lowercase</span><span class="s1"> 
        </span><span class="s0">// Grab necessary hook if one is defined</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( nType !== </span><span class="s5">1 </span><span class="s1">|| !jQuery.isXMLDoc( elem ) ) { 
            name = name.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
            hooks = jQuery.attrHooks[ name ] || 
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
 
            </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">null </span><span class="s1">) { 
                jQuery.removeAttr( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.set( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name )) !== undefined ) { 
                </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                elem.setAttribute( name</span><span class="s3">, </span><span class="s1">value + </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
            } 
 
        } </span><span class="s2">else if </span><span class="s1">( hooks &amp;&amp; </span><span class="s4">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.get( elem</span><span class="s3">, </span><span class="s1">name )) !== </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            ret = jQuery.find.attr( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Non-existent attributes return null, we normalize to undefined</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ret == </span><span class="s2">null </span><span class="s1">? 
                undefined : 
                ret</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeAttr: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">var </span><span class="s1">name</span><span class="s3">, </span><span class="s1">propName</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            attrNames = value &amp;&amp; value.match( rnotwhite )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( attrNames &amp;&amp; elem.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
            </span><span class="s2">while </span><span class="s1">( (name = attrNames[i++]) ) { 
                propName = jQuery.propFix[ name ] || name</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Boolean attributes get special treatment (#10870)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( jQuery.expr.match.bool.test( name ) ) { 
                    </span><span class="s0">// Set corresponding property to false</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) { 
                        elem[ propName ] = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
                    </span><span class="s0">// Also clear defaultChecked/defaultSelected (if appropriate)</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        elem[ jQuery.camelCase( </span><span class="s4">&quot;default-&quot; </span><span class="s1">+ name ) ] = 
                            elem[ propName ] = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                </span><span class="s0">// See #9699 for explanation of this approach (setting first, then removal)</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    jQuery.attr( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
 
                elem.removeAttribute( getSetAttribute ? name : propName )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    attrHooks: { 
        type: { 
            set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
                </span><span class="s2">if </span><span class="s1">( !support.radioValue &amp;&amp; value === </span><span class="s4">&quot;radio&quot; </span><span class="s1">&amp;&amp; jQuery.nodeName(elem</span><span class="s3">, </span><span class="s4">&quot;input&quot;</span><span class="s1">) ) { 
                    </span><span class="s0">// Setting the type on a radio button after the value resets the value in IE6-9</span><span class="s1"> 
                    </span><span class="s0">// Reset value to default in case type is set after value during creation</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">val = elem.value</span><span class="s3">;</span><span class="s1"> 
                    elem.setAttribute( </span><span class="s4">&quot;type&quot;</span><span class="s3">, </span><span class="s1">value )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( val ) { 
                        elem.value = val</span><span class="s3">;</span><span class="s1"> 
                    } 
                    </span><span class="s2">return </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Hook for boolean attributes</span><span class="s1"> 
boolHook = { 
    set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name ) { 
        </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
            </span><span class="s0">// Remove boolean attributes when set to false</span><span class="s1"> 
            jQuery.removeAttr( elem</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ) { 
            </span><span class="s0">// IE&lt;8 needs the *property* name</span><span class="s1"> 
            elem.setAttribute( !getSetAttribute &amp;&amp; jQuery.propFix[ name ] || name</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Use defaultChecked and defaultSelected for oldIE</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            elem[ jQuery.camelCase( </span><span class="s4">&quot;default-&quot; </span><span class="s1">+ name ) ] = elem[ name ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Retrieve booleans specially</span><span class="s1"> 
jQuery.each( jQuery.expr.match.bool.source.match( </span><span class="s4">/\w+/g </span><span class="s1">)</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
 
    </span><span class="s2">var </span><span class="s1">getter = attrHandle[ name ] || jQuery.find.attr</span><span class="s3">;</span><span class="s1"> 
 
    attrHandle[ name ] = getSetInput &amp;&amp; getSetAttribute || !ruseDefault.test( name ) ? 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
            </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">handle</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !isXML ) { 
                </span><span class="s0">// Avoid an infinite loop by temporarily removing this function from the getter</span><span class="s1"> 
                handle = attrHandle[ name ]</span><span class="s3">;</span><span class="s1"> 
                attrHandle[ name ] = ret</span><span class="s3">;</span><span class="s1"> 
                ret = getter( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) != </span><span class="s2">null </span><span class="s1">? 
                    name.toLowerCase() : 
                    </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                attrHandle[ name ] = handle</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
        } : 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
            </span><span class="s2">if </span><span class="s1">( !isXML ) { 
                </span><span class="s2">return </span><span class="s1">elem[ jQuery.camelCase( </span><span class="s4">&quot;default-&quot; </span><span class="s1">+ name ) ] ? 
                    name.toLowerCase() : 
                    </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// fix oldIE attroperties</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !getSetInput || !getSetAttribute ) { 
    jQuery.attrHooks.value = { 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name ) { 
            </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( elem</span><span class="s3">, </span><span class="s4">&quot;input&quot; </span><span class="s1">) ) { 
                </span><span class="s0">// Does not return so that setAttribute is also used</span><span class="s1"> 
                elem.defaultValue = value</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s0">// Use nodeHook if defined (#1954); otherwise setAttribute is fine</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">nodeHook &amp;&amp; nodeHook.set( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// IE6/7 do not support getting/setting some attributes with get/setAttribute</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !getSetAttribute ) { 
 
    </span><span class="s0">// Use this for any attribute in IE6/7</span><span class="s1"> 
    </span><span class="s0">// This fixes almost every IE6/7 issue</span><span class="s1"> 
    nodeHook = { 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name ) { 
            </span><span class="s0">// Set the existing or create a new attribute node</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">ret = elem.getAttributeNode( name )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !ret ) { 
                elem.setAttributeNode( 
                    (ret = elem.ownerDocument.createAttribute( name )) 
                )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            ret.value = value += </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Break association with cloned elements by also using setAttribute (#9646)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( name === </span><span class="s4">&quot;value&quot; </span><span class="s1">|| value === elem.getAttribute( name ) ) { 
                </span><span class="s2">return </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Some attributes are constructed with empty-string values when not defined</span><span class="s1"> 
    attrHandle.id = attrHandle.name = attrHandle.coords = 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">isXML ) { 
            </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !isXML ) { 
                </span><span class="s2">return </span><span class="s1">(ret = elem.getAttributeNode( name )) &amp;&amp; ret.value !== </span><span class="s4">&quot;&quot; </span><span class="s1">? 
                    ret.value : 
                    </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Fixing value retrieval on a button requires this module</span><span class="s1"> 
    jQuery.valHooks.button = { 
        get: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name ) { 
            </span><span class="s2">var </span><span class="s1">ret = elem.getAttributeNode( name )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( ret &amp;&amp; ret.specified ) { 
                </span><span class="s2">return </span><span class="s1">ret.value</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">,</span><span class="s1"> 
        set: nodeHook.set 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Set contenteditable to false on removals(#10429)</span><span class="s1"> 
    </span><span class="s0">// Setting to empty string throws an error as an invalid value</span><span class="s1"> 
    jQuery.attrHooks.contenteditable = { 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name ) { 
            nodeHook.set( elem</span><span class="s3">, </span><span class="s1">value === </span><span class="s4">&quot;&quot; </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: value</span><span class="s3">, </span><span class="s1">name )</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Set width and height to auto instead of 0 on empty string( Bug #8150 )</span><span class="s1"> 
    </span><span class="s0">// This is for removals</span><span class="s1"> 
    jQuery.each([ </span><span class="s4">&quot;width&quot;</span><span class="s3">, </span><span class="s4">&quot;height&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
        jQuery.attrHooks[ name ] = { 
            set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
                </span><span class="s2">if </span><span class="s1">( value === </span><span class="s4">&quot;&quot; </span><span class="s1">) { 
                    elem.setAttribute( name</span><span class="s3">, </span><span class="s4">&quot;auto&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s2">if </span><span class="s1">( !support.style ) { 
    jQuery.attrHooks.style = { 
        get: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s0">// Return undefined in the case of empty string</span><span class="s1"> 
            </span><span class="s0">// Note: IE uppercases css property names, but if we were to .toLowerCase()</span><span class="s1"> 
            </span><span class="s0">// .cssText, that would destroy case senstitivity in URL's, like in &quot;background&quot;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">elem.style.cssText || undefined</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
        set: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">return </span><span class="s1">( elem.style.cssText = value + </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
 
 
 
</span><span class="s2">var </span><span class="s1">rfocusable = </span><span class="s4">/^(?:input|select|textarea|button|object)$/i</span><span class="s3">,</span><span class="s1"> 
    rclickable = </span><span class="s4">/^(?:a|area)$/i</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    prop: </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">jQuery.prop</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">arguments.length &gt; </span><span class="s5">1 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeProp: </span><span class="s2">function</span><span class="s1">( name ) { 
        name = jQuery.propFix[ name ] || name</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// try/catch handles cases where IE balks (such as removing a property on window)</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s2">this</span><span class="s1">[ name ] = undefined</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">delete this</span><span class="s1">[ name ]</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">catch</span><span class="s1">( e ) {} 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.extend({ 
    propFix: { 
        </span><span class="s4">&quot;for&quot;</span><span class="s1">: </span><span class="s4">&quot;htmlFor&quot;</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;class&quot;</span><span class="s1">: </span><span class="s4">&quot;className&quot;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    prop: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value ) { 
        </span><span class="s2">var </span><span class="s1">ret</span><span class="s3">, </span><span class="s1">hooks</span><span class="s3">, </span><span class="s1">notxml</span><span class="s3">,</span><span class="s1"> 
            nType = elem.nodeType</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// don't get/set properties on text, comment and attribute nodes</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !elem || nType === </span><span class="s5">3 </span><span class="s1">|| nType === </span><span class="s5">8 </span><span class="s1">|| nType === </span><span class="s5">2 </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        notxml = nType !== </span><span class="s5">1 </span><span class="s1">|| !jQuery.isXMLDoc( elem )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( notxml ) { 
            </span><span class="s0">// Fix name and attach hooks</span><span class="s1"> 
            name = jQuery.propFix[ name ] || name</span><span class="s3">;</span><span class="s1"> 
            hooks = jQuery.propHooks[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
            </span><span class="s2">return </span><span class="s1">hooks &amp;&amp; </span><span class="s4">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.set( elem</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">name )) !== undefined ? 
                ret : 
                ( elem[ name ] = value )</span><span class="s3">;</span><span class="s1"> 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">return </span><span class="s1">hooks &amp;&amp; </span><span class="s4">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; (ret = hooks.get( elem</span><span class="s3">, </span><span class="s1">name )) !== </span><span class="s2">null </span><span class="s1">? 
                ret : 
                elem[ name ]</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    propHooks: { 
        tabIndex: { 
            get: </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s0">// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set</span><span class="s1"> 
                </span><span class="s0">// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/</span><span class="s1"> 
                </span><span class="s0">// Use proper attribute retrieval(#12072)</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">tabindex = jQuery.find.attr( elem</span><span class="s3">, </span><span class="s4">&quot;tabindex&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">return </span><span class="s1">tabindex ? 
                    parseInt( tabindex</span><span class="s3">, </span><span class="s5">10 </span><span class="s1">) : 
                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ? 
                        </span><span class="s5">0 </span><span class="s1">: 
                        -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Some attributes require a special call on IE</span><span class="s1"> 
</span><span class="s0">// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.hrefNormalized ) { 
    </span><span class="s0">// href/datepicker property should get the full normalized URL (#10299/#12915)</span><span class="s1"> 
    jQuery.each([ </span><span class="s4">&quot;href&quot;</span><span class="s3">, </span><span class="s4">&quot;src&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
        jQuery.propHooks[ name ] = { 
            get: </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">elem.getAttribute( name</span><span class="s3">, </span><span class="s5">4 </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Support: Safari, IE9+</span><span class="s1"> 
</span><span class="s0">// mis-reports the default selected property of an option</span><span class="s1"> 
</span><span class="s0">// Accessing the parent's selectedIndex property fixes it</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.optSelected ) { 
    jQuery.propHooks.selected = { 
        get: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">var </span><span class="s1">parent = elem.parentNode</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( parent ) { 
                parent.selectedIndex</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Make sure that it also works with optgroups, see #5701</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( parent.parentNode ) { 
                    parent.parentNode.selectedIndex</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
            </span><span class="s2">return null</span><span class="s3">;</span><span class="s1"> 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.each([ 
    </span><span class="s4">&quot;tabIndex&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;readOnly&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;maxLength&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;cellSpacing&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;cellPadding&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;rowSpan&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;colSpan&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;useMap&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;frameBorder&quot;</span><span class="s3">,</span><span class="s1"> 
    </span><span class="s4">&quot;contentEditable&quot;</span><span class="s1"> 
]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
    jQuery.propFix[ </span><span class="s2">this</span><span class="s1">.toLowerCase() ] = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// IE6/7 call enctype encoding</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( !support.enctype ) { 
    jQuery.propFix.enctype = </span><span class="s4">&quot;encoding&quot;</span><span class="s3">;</span><span class="s1"> 
} 
 
 
 
 
</span><span class="s2">var </span><span class="s1">rclass = </span><span class="s4">/[\t\r\n\f]/g</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    addClass: </span><span class="s2">function</span><span class="s1">( value ) { 
        </span><span class="s2">var </span><span class="s1">classes</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">, </span><span class="s1">clazz</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">finalValue</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            len = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            proceed = </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; value</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( j ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).addClass( value.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.className ) )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( proceed ) { 
            </span><span class="s0">// The disjunction here is for better compressibility (see removeClass)</span><span class="s1"> 
            classes = ( value || </span><span class="s4">&quot;&quot; </span><span class="s1">).match( rnotwhite ) || []</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                elem = </span><span class="s2">this</span><span class="s1">[ i ]</span><span class="s3">;</span><span class="s1"> 
                cur = elem.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; ( elem.className ? 
                    ( </span><span class="s4">&quot; &quot; </span><span class="s1">+ elem.className + </span><span class="s4">&quot; &quot; </span><span class="s1">).replace( rclass</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">) : 
                    </span><span class="s4">&quot; &quot;</span><span class="s1"> 
                )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( cur ) { 
                    j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( (clazz = classes[j++]) ) { 
                        </span><span class="s2">if </span><span class="s1">( cur.indexOf( </span><span class="s4">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s4">&quot; &quot; </span><span class="s1">) &lt; </span><span class="s5">0 </span><span class="s1">) { 
                            cur += clazz + </span><span class="s4">&quot; &quot;</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    </span><span class="s0">// only assign if different to avoid unneeded rendering.</span><span class="s1"> 
                    finalValue = jQuery.trim( cur )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( elem.className !== finalValue ) { 
                        elem.className = finalValue</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    removeClass: </span><span class="s2">function</span><span class="s1">( value ) { 
        </span><span class="s2">var </span><span class="s1">classes</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">cur</span><span class="s3">, </span><span class="s1">clazz</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">finalValue</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            len = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">,</span><span class="s1"> 
            proceed = arguments.length === </span><span class="s5">0 </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; value</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( j ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).removeClass( value.call( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.className ) )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( proceed ) { 
            classes = ( value || </span><span class="s4">&quot;&quot; </span><span class="s1">).match( rnotwhite ) || []</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; len</span><span class="s3">; </span><span class="s1">i++ ) { 
                elem = </span><span class="s2">this</span><span class="s1">[ i ]</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// This expression is here for better compressibility (see addClass)</span><span class="s1"> 
                cur = elem.nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; ( elem.className ? 
                    ( </span><span class="s4">&quot; &quot; </span><span class="s1">+ elem.className + </span><span class="s4">&quot; &quot; </span><span class="s1">).replace( rclass</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">) : 
                    </span><span class="s4">&quot;&quot;</span><span class="s1"> 
                )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( cur ) { 
                    j = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( (clazz = classes[j++]) ) { 
                        </span><span class="s0">// Remove *all* instances</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( cur.indexOf( </span><span class="s4">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s4">&quot; &quot; </span><span class="s1">) &gt;= </span><span class="s5">0 </span><span class="s1">) { 
                            cur = cur.replace( </span><span class="s4">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s4">&quot; &quot;</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    </span><span class="s0">// only assign if different to avoid unneeded rendering.</span><span class="s1"> 
                    finalValue = value ? jQuery.trim( cur ) : </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( elem.className !== finalValue ) { 
                        elem.className = finalValue</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    toggleClass: </span><span class="s2">function</span><span class="s1">( value</span><span class="s3">, </span><span class="s1">stateVal ) { 
        </span><span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">stateVal === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">&amp;&amp; type === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">stateVal ? </span><span class="s2">this</span><span class="s1">.addClass( value ) : </span><span class="s2">this</span><span class="s1">.removeClass( value )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( i ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).toggleClass( value.call(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.className</span><span class="s3">, </span><span class="s1">stateVal)</span><span class="s3">, </span><span class="s1">stateVal )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( type === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s0">// toggle individual class names</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">className</span><span class="s3">,</span><span class="s1"> 
                    i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
                    self = jQuery( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                    classNames = value.match( rnotwhite ) || []</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">while </span><span class="s1">( (className = classNames[ i++ ]) ) { 
                    </span><span class="s0">// check each className given, space separated list</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( self.hasClass( className ) ) { 
                        self.removeClass( className )</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        self.addClass( className )</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
            </span><span class="s0">// Toggle whole class name</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( type === strundefined || type === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.className ) { 
                    </span><span class="s0">// store className if set</span><span class="s1"> 
                    jQuery._data( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;__className__&quot;</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.className )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// If the element has a class name or if we're passed &quot;false&quot;,</span><span class="s1"> 
                </span><span class="s0">// then remove the whole classname (if there was one, the above saved it).</span><span class="s1"> 
                </span><span class="s0">// Otherwise bring back whatever was previously saved (if anything),</span><span class="s1"> 
                </span><span class="s0">// falling back to the empty string if nothing was stored.</span><span class="s1"> 
                </span><span class="s2">this</span><span class="s1">.className = </span><span class="s2">this</span><span class="s1">.className || value === </span><span class="s2">false </span><span class="s1">? </span><span class="s4">&quot;&quot; </span><span class="s1">: jQuery._data( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;__className__&quot; </span><span class="s1">) || </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    hasClass: </span><span class="s2">function</span><span class="s1">( selector ) { 
        </span><span class="s2">var </span><span class="s1">className = </span><span class="s4">&quot; &quot; </span><span class="s1">+ selector + </span><span class="s4">&quot; &quot;</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s3">; </span><span class="s1">i &lt; l</span><span class="s3">; </span><span class="s1">i++ ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[i].nodeType === </span><span class="s5">1 </span><span class="s1">&amp;&amp; (</span><span class="s4">&quot; &quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">[i].className + </span><span class="s4">&quot; &quot;</span><span class="s1">).replace(rclass</span><span class="s3">, </span><span class="s4">&quot; &quot;</span><span class="s1">).indexOf( className ) &gt;= </span><span class="s5">0 </span><span class="s1">) { 
                </span><span class="s2">return true</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s0">// Return jQuery for attributes-only inclusion</span><span class="s1"> 
 
 
jQuery.each( (</span><span class="s4">&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; </span><span class="s1">+ 
    </span><span class="s4">&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; </span><span class="s1">+ 
    </span><span class="s4">&quot;change select submit keydown keypress keyup error contextmenu&quot;</span><span class="s1">).split(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">name ) { 
 
    </span><span class="s0">// Handle event binding</span><span class="s1"> 
    jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( data</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">return </span><span class="s1">arguments.length &gt; </span><span class="s5">0 </span><span class="s1">? 
            </span><span class="s2">this</span><span class="s1">.on( name</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn ) : 
            </span><span class="s2">this</span><span class="s1">.trigger( name )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    hover: </span><span class="s2">function</span><span class="s1">( fnOver</span><span class="s3">, </span><span class="s1">fnOut ) { 
        </span><span class="s2">return this</span><span class="s1">.mouseenter( fnOver ).mouseleave( fnOut || fnOver )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    bind: </span><span class="s2">function</span><span class="s1">( types</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">return this</span><span class="s1">.on( types</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    unbind: </span><span class="s2">function</span><span class="s1">( types</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">return this</span><span class="s1">.off( types</span><span class="s3">, </span><span class="s2">null</span><span class="s3">, </span><span class="s1">fn )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    delegate: </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s2">return this</span><span class="s1">.on( types</span><span class="s3">, </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">fn )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    undelegate: </span><span class="s2">function</span><span class="s1">( selector</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">fn ) { 
        </span><span class="s0">// ( namespace ) or ( selector, types [, fn] )</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">arguments.length === </span><span class="s5">1 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">.off( selector</span><span class="s3">, </span><span class="s4">&quot;**&quot; </span><span class="s1">) : </span><span class="s2">this</span><span class="s1">.off( types</span><span class="s3">, </span><span class="s1">selector || </span><span class="s4">&quot;**&quot;</span><span class="s3">, </span><span class="s1">fn )</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var </span><span class="s1">nonce = jQuery.now()</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">rquery = (</span><span class="s4">/\?/</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
 
 
</span><span class="s2">var </span><span class="s1">rvalidtokens = </span><span class="s4">/(,)|(\[|{)|(}|])|&quot;(?:[^&quot;\\\r\n]|\\[&quot;\\\/bfnrt]|\\u[\da-fA-F]{4})*&quot;\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g</span><span class="s3">;</span><span class="s1"> 
 
jQuery.parseJSON = </span><span class="s2">function</span><span class="s1">( data ) { 
    </span><span class="s0">// Attempt to parse using the native JSON parser first</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( window.JSON &amp;&amp; window.JSON.parse ) { 
        </span><span class="s0">// Support: Android 2.3</span><span class="s1"> 
        </span><span class="s0">// Workaround failure to string-cast null input</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">window.JSON.parse( data + </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">requireNonComma</span><span class="s3">,</span><span class="s1"> 
        depth = </span><span class="s2">null</span><span class="s3">,</span><span class="s1"> 
        str = jQuery.trim( data + </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains</span><span class="s1"> 
    </span><span class="s0">// after removing valid tokens</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">str &amp;&amp; !jQuery.trim( str.replace( rvalidtokens</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( token</span><span class="s3">, </span><span class="s1">comma</span><span class="s3">, </span><span class="s1">open</span><span class="s3">, </span><span class="s1">close ) { 
 
        </span><span class="s0">// Force termination if we see a misplaced comma</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( requireNonComma &amp;&amp; comma ) { 
            depth = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Perform no more replacements after returning to outermost depth</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( depth === </span><span class="s5">0 </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">token</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Commas must not follow &quot;[&quot;, &quot;{&quot;, or &quot;,&quot;</span><span class="s1"> 
        requireNonComma = open || comma</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Determine new depth</span><span class="s1"> 
        </span><span class="s0">// array/object open (&quot;[&quot; or &quot;{&quot;): depth += true - false (increment)</span><span class="s1"> 
        </span><span class="s0">// array/object close (&quot;]&quot; or &quot;}&quot;): depth += false - true (decrement)</span><span class="s1"> 
        </span><span class="s0">// other cases (&quot;,&quot; or primitive): depth += true - true (numeric cast)</span><span class="s1"> 
        depth += !close - !open</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Remove this token</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
    }) ) ? 
        ( Function( </span><span class="s4">&quot;return &quot; </span><span class="s1">+ str ) )() : 
        jQuery.error( </span><span class="s4">&quot;Invalid JSON: &quot; </span><span class="s1">+ data )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Cross-browser xml parsing</span><span class="s1"> 
jQuery.parseXML = </span><span class="s2">function</span><span class="s1">( data ) { 
    </span><span class="s2">var </span><span class="s1">xml</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">;</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !data || </span><span class="s2">typeof </span><span class="s1">data !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
        </span><span class="s2">return null</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">try </span><span class="s1">{ 
        </span><span class="s2">if </span><span class="s1">( window.DOMParser ) { </span><span class="s0">// Standard</span><span class="s1"> 
            tmp = </span><span class="s2">new </span><span class="s1">DOMParser()</span><span class="s3">;</span><span class="s1"> 
            xml = tmp.parseFromString( data</span><span class="s3">, </span><span class="s4">&quot;text/xml&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ </span><span class="s0">// IE</span><span class="s1"> 
            xml = </span><span class="s2">new </span><span class="s1">ActiveXObject( </span><span class="s4">&quot;Microsoft.XMLDOM&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            xml.async = </span><span class="s4">&quot;false&quot;</span><span class="s3">;</span><span class="s1"> 
            xml.loadXML( data )</span><span class="s3">;</span><span class="s1"> 
        } 
    } </span><span class="s2">catch</span><span class="s1">( e ) { 
        xml = undefined</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">if </span><span class="s1">( !xml || !xml.documentElement || xml.getElementsByTagName( </span><span class="s4">&quot;parsererror&quot; </span><span class="s1">).length ) { 
        jQuery.error( </span><span class="s4">&quot;Invalid XML: &quot; </span><span class="s1">+ data )</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">return </span><span class="s1">xml</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s2">var</span><span class="s1"> 
    </span><span class="s0">// Document location</span><span class="s1"> 
    ajaxLocParts</span><span class="s3">,</span><span class="s1"> 
    ajaxLocation</span><span class="s3">,</span><span class="s1"> 
 
    rhash = </span><span class="s4">/#.*$/</span><span class="s3">,</span><span class="s1"> 
    rts = </span><span class="s4">/([?&amp;])_=[^&amp;]*/</span><span class="s3">,</span><span class="s1"> 
    rheaders = </span><span class="s4">/^(.*?):[ \t]*([^\r\n]*)\r?$/mg</span><span class="s3">, </span><span class="s0">// IE leaves an \r character at EOL</span><span class="s1"> 
    </span><span class="s0">// #7653, #8125, #8152: local protocol detection</span><span class="s1"> 
    rlocalProtocol = </span><span class="s4">/^(?:about|app|app-storage|.+-extension|file|res|widget):$/</span><span class="s3">,</span><span class="s1"> 
    rnoContent = </span><span class="s4">/^(?:GET|HEAD)$/</span><span class="s3">,</span><span class="s1"> 
    rprotocol = </span><span class="s4">/^\/\//</span><span class="s3">,</span><span class="s1"> 
    rurl = </span><span class="s4">/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">/* Prefilters 
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example) 
     * 2) These are called: 
     *    - BEFORE asking for a transport 
     *    - AFTER param serialization (s.data is a string if s.processData is true) 
     * 3) key is the dataType 
     * 4) the catchall symbol &quot;*&quot; can be used 
     * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed 
     */</span><span class="s1"> 
    prefilters = {}</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">/* Transports bindings 
     * 1) key is the dataType 
     * 2) the catchall symbol &quot;*&quot; can be used 
     * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed 
     */</span><span class="s1"> 
    transports = {}</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression</span><span class="s1"> 
    allTypes = </span><span class="s4">&quot;*/&quot;</span><span class="s1">.concat(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// #8138, IE may throw an exception when accessing</span><span class="s1"> 
</span><span class="s0">// a field from window.location if document.domain has been set</span><span class="s1"> 
</span><span class="s2">try </span><span class="s1">{ 
    ajaxLocation = location.href</span><span class="s3">;</span><span class="s1"> 
} </span><span class="s2">catch</span><span class="s1">( e ) { 
    </span><span class="s0">// Use the href attribute of an A element</span><span class="s1"> 
    </span><span class="s0">// since IE will modify it given document.location</span><span class="s1"> 
    ajaxLocation = document.createElement( </span><span class="s4">&quot;a&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    ajaxLocation.href = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
    ajaxLocation = ajaxLocation.href</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Segment location into parts</span><span class="s1"> 
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || []</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">addToPrefiltersOrTransports( structure ) { 
 
    </span><span class="s0">// dataTypeExpression is optional and defaults to &quot;*&quot;</span><span class="s1"> 
    </span><span class="s2">return function</span><span class="s1">( dataTypeExpression</span><span class="s3">, </span><span class="s1">func ) { 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">dataTypeExpression !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            func = dataTypeExpression</span><span class="s3">;</span><span class="s1"> 
            dataTypeExpression = </span><span class="s4">&quot;*&quot;</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">var </span><span class="s1">dataType</span><span class="s3">,</span><span class="s1"> 
            i = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || []</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( func ) ) { 
            </span><span class="s0">// For each dataType in the dataTypeExpression</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( (dataType = dataTypes[i++]) ) { 
                </span><span class="s0">// Prepend if requested</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( dataType.charAt( </span><span class="s5">0 </span><span class="s1">) === </span><span class="s4">&quot;+&quot; </span><span class="s1">) { 
                    dataType = dataType.slice( </span><span class="s5">1 </span><span class="s1">) || </span><span class="s4">&quot;*&quot;</span><span class="s3">;</span><span class="s1"> 
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func )</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Otherwise append</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    (structure[ dataType ] = structure[ dataType ] || []).push( func )</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
    }</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Base inspection function for prefilters and transports</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">inspectPrefiltersOrTransports( structure</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">originalOptions</span><span class="s3">, </span><span class="s1">jqXHR ) { 
 
    </span><span class="s2">var </span><span class="s1">inspected = {}</span><span class="s3">,</span><span class="s1"> 
        seekingTransport = ( structure === transports )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">function </span><span class="s1">inspect( dataType ) { 
        </span><span class="s2">var </span><span class="s1">selected</span><span class="s3">;</span><span class="s1"> 
        inspected[ dataType ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        jQuery.each( structure[ dataType ] || []</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">prefilterOrFactory ) { 
            </span><span class="s2">var </span><span class="s1">dataTypeOrTransport = prefilterOrFactory( options</span><span class="s3">, </span><span class="s1">originalOptions</span><span class="s3">, </span><span class="s1">jqXHR )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">dataTypeOrTransport === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) { 
                options.dataTypes.unshift( dataTypeOrTransport )</span><span class="s3">;</span><span class="s1"> 
                inspect( dataTypeOrTransport )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">return false</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( seekingTransport ) { 
                </span><span class="s2">return </span><span class="s1">!( selected = dataTypeOrTransport )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">selected</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">inspect( options.dataTypes[ </span><span class="s5">0 </span><span class="s1">] ) || !inspected[ </span><span class="s4">&quot;*&quot; </span><span class="s1">] &amp;&amp; inspect( </span><span class="s4">&quot;*&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// A special extend for ajax options</span><span class="s1"> 
</span><span class="s0">// that takes &quot;flat&quot; options (not to be deep extended)</span><span class="s1"> 
</span><span class="s0">// Fixes #9887</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">ajaxExtend( target</span><span class="s3">, </span><span class="s1">src ) { 
    </span><span class="s2">var </span><span class="s1">deep</span><span class="s3">, </span><span class="s1">key</span><span class="s3">,</span><span class="s1"> 
        flatOptions = jQuery.ajaxSettings.flatOptions || {}</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">src ) { 
        </span><span class="s2">if </span><span class="s1">( src[ key ] !== undefined ) { 
            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ]</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
    </span><span class="s2">if </span><span class="s1">( deep ) { 
        jQuery.extend( </span><span class="s2">true</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">deep )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">target</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">/* Handles responses to an ajax request: 
 * - finds the right dataType (mediates between content-type and expected dataType) 
 * - returns the corresponding response 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">ajaxHandleResponses( s</span><span class="s3">, </span><span class="s1">jqXHR</span><span class="s3">, </span><span class="s1">responses ) { 
    </span><span class="s2">var </span><span class="s1">firstDataType</span><span class="s3">, </span><span class="s1">ct</span><span class="s3">, </span><span class="s1">finalDataType</span><span class="s3">, </span><span class="s1">type</span><span class="s3">,</span><span class="s1"> 
        contents = s.contents</span><span class="s3">,</span><span class="s1"> 
        dataTypes = s.dataTypes</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Remove auto dataType and get content-type in the process</span><span class="s1"> 
    </span><span class="s2">while </span><span class="s1">( dataTypes[ </span><span class="s5">0 </span><span class="s1">] === </span><span class="s4">&quot;*&quot; </span><span class="s1">) { 
        dataTypes.shift()</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( ct === undefined ) { 
            ct = s.mimeType || jqXHR.getResponseHeader(</span><span class="s4">&quot;Content-Type&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Check if we're dealing with a known content-type</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( ct ) { 
        </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">contents ) { 
            </span><span class="s2">if </span><span class="s1">( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) { 
                dataTypes.unshift( type )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s0">// Check to see if we have a response for the expected dataType</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( dataTypes[ </span><span class="s5">0 </span><span class="s1">] </span><span class="s2">in </span><span class="s1">responses ) { 
        finalDataType = dataTypes[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">else </span><span class="s1">{ 
        </span><span class="s0">// Try convertible dataTypes</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">responses ) { 
            </span><span class="s2">if </span><span class="s1">( !dataTypes[ </span><span class="s5">0 </span><span class="s1">] || s.converters[ type + </span><span class="s4">&quot; &quot; </span><span class="s1">+ dataTypes[</span><span class="s5">0</span><span class="s1">] ] ) { 
                finalDataType = type</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">if </span><span class="s1">( !firstDataType ) { 
                firstDataType = type</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
        </span><span class="s0">// Or just use first one</span><span class="s1"> 
        finalDataType = finalDataType || firstDataType</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// If we found a dataType</span><span class="s1"> 
    </span><span class="s0">// We add the dataType to the list if needed</span><span class="s1"> 
    </span><span class="s0">// and return the corresponding response</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( finalDataType ) { 
        </span><span class="s2">if </span><span class="s1">( finalDataType !== dataTypes[ </span><span class="s5">0 </span><span class="s1">] ) { 
            dataTypes.unshift( finalDataType )</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">return </span><span class="s1">responses[ finalDataType ]</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s0">/* Chain conversions given the request and the original response 
 * Also sets the responseXXX fields on the jqXHR instance 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">ajaxConvert( s</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">jqXHR</span><span class="s3">, </span><span class="s1">isSuccess ) { 
    </span><span class="s2">var </span><span class="s1">conv2</span><span class="s3">, </span><span class="s1">current</span><span class="s3">, </span><span class="s1">conv</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">prev</span><span class="s3">,</span><span class="s1"> 
        converters = {}</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">// Work with a copy of dataTypes in case we need to modify it for conversion</span><span class="s1"> 
        dataTypes = s.dataTypes.slice()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Create converters map with lowercased keys</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( dataTypes[ </span><span class="s5">1 </span><span class="s1">] ) { 
        </span><span class="s2">for </span><span class="s1">( conv </span><span class="s2">in </span><span class="s1">s.converters ) { 
            converters[ conv.toLowerCase() ] = s.converters[ conv ]</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    current = dataTypes.shift()</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Convert to each sequential dataType</span><span class="s1"> 
    </span><span class="s2">while </span><span class="s1">( current ) { 
 
        </span><span class="s2">if </span><span class="s1">( s.responseFields[ current ] ) { 
            jqXHR[ s.responseFields[ current ] ] = response</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Apply the dataFilter if provided</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) { 
            response = s.dataFilter( response</span><span class="s3">, </span><span class="s1">s.dataType )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        prev = current</span><span class="s3">;</span><span class="s1"> 
        current = dataTypes.shift()</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( current ) { 
 
            </span><span class="s0">// There's only work to do if current dataType is non-auto</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( current === </span><span class="s4">&quot;*&quot; </span><span class="s1">) { 
 
                current = prev</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Convert response if prev dataType is non-auto and differs from current</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( prev !== </span><span class="s4">&quot;*&quot; </span><span class="s1">&amp;&amp; prev !== current ) { 
 
                </span><span class="s0">// Seek a direct converter</span><span class="s1"> 
                conv = converters[ prev + </span><span class="s4">&quot; &quot; </span><span class="s1">+ current ] || converters[ </span><span class="s4">&quot;* &quot; </span><span class="s1">+ current ]</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// If none found, seek a pair</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !conv ) { 
                    </span><span class="s2">for </span><span class="s1">( conv2 </span><span class="s2">in </span><span class="s1">converters ) { 
 
                        </span><span class="s0">// If conv2 outputs current</span><span class="s1"> 
                        tmp = conv2.split( </span><span class="s4">&quot; &quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( tmp[ </span><span class="s5">1 </span><span class="s1">] === current ) { 
 
                            </span><span class="s0">// If prev can be converted to accepted input</span><span class="s1"> 
                            conv = converters[ prev + </span><span class="s4">&quot; &quot; </span><span class="s1">+ tmp[ </span><span class="s5">0 </span><span class="s1">] ] || 
                                converters[ </span><span class="s4">&quot;* &quot; </span><span class="s1">+ tmp[ </span><span class="s5">0 </span><span class="s1">] ]</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( conv ) { 
                                </span><span class="s0">// Condense equivalence converters</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( conv === </span><span class="s2">true </span><span class="s1">) { 
                                    conv = converters[ conv2 ]</span><span class="s3">;</span><span class="s1"> 
 
                                </span><span class="s0">// Otherwise, insert the intermediate dataType</span><span class="s1"> 
                                } </span><span class="s2">else if </span><span class="s1">( converters[ conv2 ] !== </span><span class="s2">true </span><span class="s1">) { 
                                    current = tmp[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                                    dataTypes.unshift( tmp[ </span><span class="s5">1 </span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
                                } 
                                </span><span class="s2">break</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Apply converter (if not an equivalence)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( conv !== </span><span class="s2">true </span><span class="s1">) { 
 
                    </span><span class="s0">// Unless errors are allowed to bubble, catch and return them</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( conv &amp;&amp; s[ </span><span class="s4">&quot;throws&quot; </span><span class="s1">] ) { 
                        response = conv( response )</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        </span><span class="s2">try </span><span class="s1">{ 
                            response = conv( response )</span><span class="s3">;</span><span class="s1"> 
                        } </span><span class="s2">catch </span><span class="s1">( e ) { 
                            </span><span class="s2">return </span><span class="s1">{ state: </span><span class="s4">&quot;parsererror&quot;</span><span class="s3">, </span><span class="s1">error: conv ? e : </span><span class="s4">&quot;No conversion from &quot; </span><span class="s1">+ prev + </span><span class="s4">&quot; to &quot; </span><span class="s1">+ current }</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                } 
            } 
        } 
    } 
 
    </span><span class="s2">return </span><span class="s1">{ state: </span><span class="s4">&quot;success&quot;</span><span class="s3">, </span><span class="s1">data: response }</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.extend({ 
 
    </span><span class="s0">// Counter for holding the number of active queries</span><span class="s1"> 
    active: </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Last-Modified header cache for next request</span><span class="s1"> 
    lastModified: {}</span><span class="s3">,</span><span class="s1"> 
    etag: {}</span><span class="s3">,</span><span class="s1"> 
 
    ajaxSettings: { 
        url: ajaxLocation</span><span class="s3">,</span><span class="s1"> 
        type: </span><span class="s4">&quot;GET&quot;</span><span class="s3">,</span><span class="s1"> 
        isLocal: rlocalProtocol.test( ajaxLocParts[ </span><span class="s5">1 </span><span class="s1">] )</span><span class="s3">,</span><span class="s1"> 
        global: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        processData: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        async: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
        contentType: </span><span class="s4">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s0">/* 
        timeout: 0, 
        data: null, 
        dataType: null, 
        username: null, 
        password: null, 
        cache: null, 
        throws: false, 
        traditional: false, 
        headers: {}, 
        */</span><span class="s1"> 
 
        accepts: { 
            </span><span class="s4">&quot;*&quot;</span><span class="s1">: allTypes</span><span class="s3">,</span><span class="s1"> 
            text: </span><span class="s4">&quot;text/plain&quot;</span><span class="s3">,</span><span class="s1"> 
            html: </span><span class="s4">&quot;text/html&quot;</span><span class="s3">,</span><span class="s1"> 
            xml: </span><span class="s4">&quot;application/xml, text/xml&quot;</span><span class="s3">,</span><span class="s1"> 
            json: </span><span class="s4">&quot;application/json, text/javascript&quot;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        contents: { 
            xml: </span><span class="s4">/xml/</span><span class="s3">,</span><span class="s1"> 
            html: </span><span class="s4">/html/</span><span class="s3">,</span><span class="s1"> 
            json: </span><span class="s4">/json/</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        responseFields: { 
            xml: </span><span class="s4">&quot;responseXML&quot;</span><span class="s3">,</span><span class="s1"> 
            text: </span><span class="s4">&quot;responseText&quot;</span><span class="s3">,</span><span class="s1"> 
            json: </span><span class="s4">&quot;responseJSON&quot;</span><span class="s1"> 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// Data converters</span><span class="s1"> 
        </span><span class="s0">// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space</span><span class="s1"> 
        converters: { 
 
            </span><span class="s0">// Convert anything to text</span><span class="s1"> 
            </span><span class="s4">&quot;* text&quot;</span><span class="s1">: String</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Text to html (true = no transformation)</span><span class="s1"> 
            </span><span class="s4">&quot;text html&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Evaluate text as a json expression</span><span class="s1"> 
            </span><span class="s4">&quot;text json&quot;</span><span class="s1">: jQuery.parseJSON</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// Parse text as xml</span><span class="s1"> 
            </span><span class="s4">&quot;text xml&quot;</span><span class="s1">: jQuery.parseXML 
        }</span><span class="s3">,</span><span class="s1"> 
 
        </span><span class="s0">// For options that shouldn't be deep extended:</span><span class="s1"> 
        </span><span class="s0">// you can add your own custom options here if</span><span class="s1"> 
        </span><span class="s0">// and when you create one that shouldn't be</span><span class="s1"> 
        </span><span class="s0">// deep extended (see ajaxExtend)</span><span class="s1"> 
        flatOptions: { 
            url: </span><span class="s2">true</span><span class="s3">,</span><span class="s1"> 
            context: </span><span class="s2">true</span><span class="s1"> 
        } 
    }</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Creates a full fledged settings object into target</span><span class="s1"> 
    </span><span class="s0">// with both ajaxSettings and settings fields.</span><span class="s1"> 
    </span><span class="s0">// If target is omitted, writes into ajaxSettings.</span><span class="s1"> 
    ajaxSetup: </span><span class="s2">function</span><span class="s1">( target</span><span class="s3">, </span><span class="s1">settings ) { 
        </span><span class="s2">return </span><span class="s1">settings ? 
 
            </span><span class="s0">// Building a settings object</span><span class="s1"> 
            ajaxExtend( ajaxExtend( target</span><span class="s3">, </span><span class="s1">jQuery.ajaxSettings )</span><span class="s3">, </span><span class="s1">settings ) : 
 
            </span><span class="s0">// Extending ajaxSettings</span><span class="s1"> 
            ajaxExtend( jQuery.ajaxSettings</span><span class="s3">, </span><span class="s1">target )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    ajaxPrefilter: addToPrefiltersOrTransports( prefilters )</span><span class="s3">,</span><span class="s1"> 
    ajaxTransport: addToPrefiltersOrTransports( transports )</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Main method</span><span class="s1"> 
    ajax: </span><span class="s2">function</span><span class="s1">( url</span><span class="s3">, </span><span class="s1">options ) { 
 
        </span><span class="s0">// If url is an object, simulate pre-1.5 signature</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">url === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
            options = url</span><span class="s3">;</span><span class="s1"> 
            url = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Force options to be an object</span><span class="s1"> 
        options = options || {}</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">var </span><span class="s0">// Cross-domain detection vars</span><span class="s1"> 
            parts</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Loop variable</span><span class="s1"> 
            i</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// URL without anti-cache param</span><span class="s1"> 
            cacheURL</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Response headers as string</span><span class="s1"> 
            responseHeadersString</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// timeout handle</span><span class="s1"> 
            timeoutTimer</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// To know if global events are to be dispatched</span><span class="s1"> 
            fireGlobals</span><span class="s3">,</span><span class="s1"> 
 
            transport</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Response headers</span><span class="s1"> 
            responseHeaders</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Create the final options object</span><span class="s1"> 
            s = jQuery.ajaxSetup( {}</span><span class="s3">, </span><span class="s1">options )</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Callbacks context</span><span class="s1"> 
            callbackContext = s.context || s</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Context for global events is callbackContext if it is a DOM node or jQuery collection</span><span class="s1"> 
            globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ? 
                jQuery( callbackContext ) : 
                jQuery.event</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Deferreds</span><span class="s1"> 
            deferred = jQuery.Deferred()</span><span class="s3">,</span><span class="s1"> 
            completeDeferred = jQuery.Callbacks(</span><span class="s4">&quot;once memory&quot;</span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
            statusCode = s.statusCode || {}</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Headers (they are sent all at once)</span><span class="s1"> 
            requestHeaders = {}</span><span class="s3">,</span><span class="s1"> 
            requestHeadersNames = {}</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// The jqXHR state</span><span class="s1"> 
            state = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Default abort message</span><span class="s1"> 
            strAbort = </span><span class="s4">&quot;canceled&quot;</span><span class="s3">,</span><span class="s1"> 
            </span><span class="s0">// Fake xhr</span><span class="s1"> 
            jqXHR = { 
                readyState: </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Builds headers hashtable if needed</span><span class="s1"> 
                getResponseHeader: </span><span class="s2">function</span><span class="s1">( key ) { 
                    </span><span class="s2">var </span><span class="s1">match</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( state === </span><span class="s5">2 </span><span class="s1">) { 
                        </span><span class="s2">if </span><span class="s1">( !responseHeaders ) { 
                            responseHeaders = {}</span><span class="s3">;</span><span class="s1"> 
                            </span><span class="s2">while </span><span class="s1">( (match = rheaders.exec( responseHeadersString )) ) { 
                                responseHeaders[ match[</span><span class="s5">1</span><span class="s1">].toLowerCase() ] = match[ </span><span class="s5">2 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } 
                        match = responseHeaders[ key.toLowerCase() ]</span><span class="s3">;</span><span class="s1"> 
                    } 
                    </span><span class="s2">return </span><span class="s1">match == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: match</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Raw string</span><span class="s1"> 
                getAllResponseHeaders: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">state === </span><span class="s5">2 </span><span class="s1">? responseHeadersString : </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Caches the header</span><span class="s1"> 
                setRequestHeader: </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">value ) { 
                    </span><span class="s2">var </span><span class="s1">lname = name.toLowerCase()</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !state ) { 
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name</span><span class="s3">;</span><span class="s1"> 
                        requestHeaders[ name ] = value</span><span class="s3">;</span><span class="s1"> 
                    } 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Overrides response content-type header</span><span class="s1"> 
                overrideMimeType: </span><span class="s2">function</span><span class="s1">( type ) { 
                    </span><span class="s2">if </span><span class="s1">( !state ) { 
                        s.mimeType = type</span><span class="s3">;</span><span class="s1"> 
                    } 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
                statusCode: </span><span class="s2">function</span><span class="s1">( map ) { 
                    </span><span class="s2">var </span><span class="s1">code</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( map ) { 
                        </span><span class="s2">if </span><span class="s1">( state &lt; </span><span class="s5">2 </span><span class="s1">) { 
                            </span><span class="s2">for </span><span class="s1">( code </span><span class="s2">in </span><span class="s1">map ) { 
                                </span><span class="s0">// Lazy-add the new callback in a way that preserves old ones</span><span class="s1"> 
                                statusCode[ code ] = [ statusCode[ code ]</span><span class="s3">, </span><span class="s1">map[ code ] ]</span><span class="s3">;</span><span class="s1"> 
                            } 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            </span><span class="s0">// Execute the appropriate callbacks</span><span class="s1"> 
                            jqXHR.always( map[ jqXHR.status ] )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">,</span><span class="s1"> 
 
                </span><span class="s0">// Cancel the request</span><span class="s1"> 
                abort: </span><span class="s2">function</span><span class="s1">( statusText ) { 
                    </span><span class="s2">var </span><span class="s1">finalText = statusText || strAbort</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( transport ) { 
                        transport.abort( finalText )</span><span class="s3">;</span><span class="s1"> 
                    } 
                    done( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">finalText )</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
                } 
            }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Attach deferreds</span><span class="s1"> 
        deferred.promise( jqXHR ).complete = completeDeferred.add</span><span class="s3">;</span><span class="s1"> 
        jqXHR.success = jqXHR.done</span><span class="s3">;</span><span class="s1"> 
        jqXHR.error = jqXHR.fail</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Remove hash character (#7531: and string promotion)</span><span class="s1"> 
        </span><span class="s0">// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)</span><span class="s1"> 
        </span><span class="s0">// Handle falsy url in the settings object (#10093: consistency with old signature)</span><span class="s1"> 
        </span><span class="s0">// We also use the url parameter if available</span><span class="s1"> 
        s.url = ( ( url || s.url || ajaxLocation ) + </span><span class="s4">&quot;&quot; </span><span class="s1">).replace( rhash</span><span class="s3">, </span><span class="s4">&quot;&quot; </span><span class="s1">).replace( rprotocol</span><span class="s3">, </span><span class="s1">ajaxLocParts[ </span><span class="s5">1 </span><span class="s1">] + </span><span class="s4">&quot;//&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Alias method option to type as per ticket #12004</span><span class="s1"> 
        s.type = options.method || options.type || s.method || s.type</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Extract dataTypes list</span><span class="s1"> 
        s.dataTypes = jQuery.trim( s.dataType || </span><span class="s4">&quot;*&quot; </span><span class="s1">).toLowerCase().match( rnotwhite ) || [ </span><span class="s4">&quot;&quot; </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// A cross-domain request is in order when we have a protocol:host:port mismatch</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.crossDomain == </span><span class="s2">null </span><span class="s1">) { 
            parts = rurl.exec( s.url.toLowerCase() )</span><span class="s3">;</span><span class="s1"> 
            s.crossDomain = !!( parts &amp;&amp; 
                ( parts[ </span><span class="s5">1 </span><span class="s1">] !== ajaxLocParts[ </span><span class="s5">1 </span><span class="s1">] || parts[ </span><span class="s5">2 </span><span class="s1">] !== ajaxLocParts[ </span><span class="s5">2 </span><span class="s1">] || 
                    ( parts[ </span><span class="s5">3 </span><span class="s1">] || ( parts[ </span><span class="s5">1 </span><span class="s1">] === </span><span class="s4">&quot;http:&quot; </span><span class="s1">? </span><span class="s4">&quot;80&quot; </span><span class="s1">: </span><span class="s4">&quot;443&quot; </span><span class="s1">) ) !== 
                        ( ajaxLocParts[ </span><span class="s5">3 </span><span class="s1">] || ( ajaxLocParts[ </span><span class="s5">1 </span><span class="s1">] === </span><span class="s4">&quot;http:&quot; </span><span class="s1">? </span><span class="s4">&quot;80&quot; </span><span class="s1">: </span><span class="s4">&quot;443&quot; </span><span class="s1">) ) ) 
            )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Convert data if not already a string</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.data &amp;&amp; s.processData &amp;&amp; </span><span class="s2">typeof </span><span class="s1">s.data !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
            s.data = jQuery.param( s.data</span><span class="s3">, </span><span class="s1">s.traditional )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Apply prefilters</span><span class="s1"> 
        inspectPrefiltersOrTransports( prefilters</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">jqXHR )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If request was aborted inside a prefilter, stop there</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( state === </span><span class="s5">2 </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">jqXHR</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// We can fire global events as of now if asked to</span><span class="s1"> 
        </span><span class="s0">// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)</span><span class="s1"> 
        fireGlobals = jQuery.event &amp;&amp; s.global</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Watch for a new set of requests</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( fireGlobals &amp;&amp; jQuery.active++ === </span><span class="s5">0 </span><span class="s1">) { 
            jQuery.event.trigger(</span><span class="s4">&quot;ajaxStart&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Uppercase the type</span><span class="s1"> 
        s.type = s.type.toUpperCase()</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Determine if request has content</span><span class="s1"> 
        s.hasContent = !rnoContent.test( s.type )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Save the URL in case we're toying with the If-Modified-Since</span><span class="s1"> 
        </span><span class="s0">// and/or If-None-Match header later on</span><span class="s1"> 
        cacheURL = s.url</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// More options handling for requests with no content</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !s.hasContent ) { 
 
            </span><span class="s0">// If data is available, append data to url</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.data ) { 
                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? </span><span class="s4">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s4">&quot;?&quot; </span><span class="s1">) + s.data )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// #9682: remove data so that it's not used in an eventual retry</span><span class="s1"> 
                </span><span class="s2">delete </span><span class="s1">s.data</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Add anti-cache in url if needed</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.cache === </span><span class="s2">false </span><span class="s1">) { 
                s.url = rts.test( cacheURL ) ? 
 
                    </span><span class="s0">// If there is already a '_' parameter, set its value</span><span class="s1"> 
                    cacheURL.replace( rts</span><span class="s3">, </span><span class="s4">&quot;$1_=&quot; </span><span class="s1">+ nonce++ ) : 
 
                    </span><span class="s0">// Otherwise add one to the end</span><span class="s1"> 
                    cacheURL + ( rquery.test( cacheURL ) ? </span><span class="s4">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s4">&quot;?&quot; </span><span class="s1">) + </span><span class="s4">&quot;_=&quot; </span><span class="s1">+ nonce++</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.ifModified ) { 
            </span><span class="s2">if </span><span class="s1">( jQuery.lastModified[ cacheURL ] ) { 
                jqXHR.setRequestHeader( </span><span class="s4">&quot;If-Modified-Since&quot;</span><span class="s3">, </span><span class="s1">jQuery.lastModified[ cacheURL ] )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">if </span><span class="s1">( jQuery.etag[ cacheURL ] ) { 
                jqXHR.setRequestHeader( </span><span class="s4">&quot;If-None-Match&quot;</span><span class="s3">, </span><span class="s1">jQuery.etag[ cacheURL ] )</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s0">// Set the correct header, if data is being sent</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== </span><span class="s2">false </span><span class="s1">|| options.contentType ) { 
            jqXHR.setRequestHeader( </span><span class="s4">&quot;Content-Type&quot;</span><span class="s3">, </span><span class="s1">s.contentType )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Set the Accepts header for the server, depending on the dataType</span><span class="s1"> 
        jqXHR.setRequestHeader( 
            </span><span class="s4">&quot;Accept&quot;</span><span class="s3">,</span><span class="s1"> 
            s.dataTypes[ </span><span class="s5">0 </span><span class="s1">] &amp;&amp; s.accepts[ s.dataTypes[</span><span class="s5">0</span><span class="s1">] ] ? 
                s.accepts[ s.dataTypes[</span><span class="s5">0</span><span class="s1">] ] + ( s.dataTypes[ </span><span class="s5">0 </span><span class="s1">] !== </span><span class="s4">&quot;*&quot; </span><span class="s1">? </span><span class="s4">&quot;, &quot; </span><span class="s1">+ allTypes + </span><span class="s4">&quot;; q=0.01&quot; </span><span class="s1">: </span><span class="s4">&quot;&quot; </span><span class="s1">) : 
                s.accepts[ </span><span class="s4">&quot;*&quot; </span><span class="s1">] 
        )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Check for headers option</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">s.headers ) { 
            jqXHR.setRequestHeader( i</span><span class="s3">, </span><span class="s1">s.headers[ i ] )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Allow custom headers/mimetypes and early abort</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext</span><span class="s3">, </span><span class="s1">jqXHR</span><span class="s3">, </span><span class="s1">s ) === </span><span class="s2">false </span><span class="s1">|| state === </span><span class="s5">2 </span><span class="s1">) ) { 
            </span><span class="s0">// Abort if not done already and return</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">jqXHR.abort()</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// aborting is no longer a cancellation</span><span class="s1"> 
        strAbort = </span><span class="s4">&quot;abort&quot;</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Install callbacks on deferreds</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ success: </span><span class="s5">1</span><span class="s3">, </span><span class="s1">error: </span><span class="s5">1</span><span class="s3">, </span><span class="s1">complete: </span><span class="s5">1 </span><span class="s1">} ) { 
            jqXHR[ i ]( s[ i ] )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Get transport</span><span class="s1"> 
        transport = inspectPrefiltersOrTransports( transports</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">jqXHR )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// If no transport, we auto-abort</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !transport ) { 
            done( -</span><span class="s5">1</span><span class="s3">, </span><span class="s4">&quot;No Transport&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            jqXHR.readyState = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Send global event</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                globalEventContext.trigger( </span><span class="s4">&quot;ajaxSend&quot;</span><span class="s3">, </span><span class="s1">[ jqXHR</span><span class="s3">, </span><span class="s1">s ] )</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s0">// Timeout</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.async &amp;&amp; s.timeout &gt; </span><span class="s5">0 </span><span class="s1">) { 
                timeoutTimer = setTimeout(</span><span class="s2">function</span><span class="s1">() { 
                    jqXHR.abort(</span><span class="s4">&quot;timeout&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                }</span><span class="s3">, </span><span class="s1">s.timeout )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">try </span><span class="s1">{ 
                state = </span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
                transport.send( requestHeaders</span><span class="s3">, </span><span class="s1">done )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">( e ) { 
                </span><span class="s0">// Propagate exception as error if not done</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( state &lt; </span><span class="s5">2 </span><span class="s1">) { 
                    done( -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">e )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// Simply rethrow otherwise</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s2">throw </span><span class="s1">e</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s0">// Callback for when everything is done</span><span class="s1"> 
        </span><span class="s2">function </span><span class="s1">done( status</span><span class="s3">, </span><span class="s1">nativeStatusText</span><span class="s3">, </span><span class="s1">responses</span><span class="s3">, </span><span class="s1">headers ) { 
            </span><span class="s2">var </span><span class="s1">isSuccess</span><span class="s3">, </span><span class="s1">success</span><span class="s3">, </span><span class="s1">error</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">modified</span><span class="s3">,</span><span class="s1"> 
                statusText = nativeStatusText</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Called once</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( state === </span><span class="s5">2 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// State is &quot;done&quot; now</span><span class="s1"> 
            state = </span><span class="s5">2</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Clear timeout if it exists</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( timeoutTimer ) { 
                clearTimeout( timeoutTimer )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Dereference transport for early garbage collection</span><span class="s1"> 
            </span><span class="s0">// (no matter how long the jqXHR object will be used)</span><span class="s1"> 
            transport = undefined</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Cache response headers</span><span class="s1"> 
            responseHeadersString = headers || </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Set readyState</span><span class="s1"> 
            jqXHR.readyState = status &gt; </span><span class="s5">0 </span><span class="s1">? </span><span class="s5">4 </span><span class="s1">: </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Determine if successful</span><span class="s1"> 
            isSuccess = status &gt;= </span><span class="s5">200 </span><span class="s1">&amp;&amp; status &lt; </span><span class="s5">300 </span><span class="s1">|| status === </span><span class="s5">304</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Get response data</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( responses ) { 
                response = ajaxHandleResponses( s</span><span class="s3">, </span><span class="s1">jqXHR</span><span class="s3">, </span><span class="s1">responses )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Convert no matter what (that way responseXXX fields are always set)</span><span class="s1"> 
            response = ajaxConvert( s</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">jqXHR</span><span class="s3">, </span><span class="s1">isSuccess )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// If successful, handle type chaining</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( isSuccess ) { 
 
                </span><span class="s0">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( s.ifModified ) { 
                    modified = jqXHR.getResponseHeader(</span><span class="s4">&quot;Last-Modified&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( modified ) { 
                        jQuery.lastModified[ cacheURL ] = modified</span><span class="s3">;</span><span class="s1"> 
                    } 
                    modified = jqXHR.getResponseHeader(</span><span class="s4">&quot;etag&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( modified ) { 
                        jQuery.etag[ cacheURL ] = modified</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
 
                </span><span class="s0">// if no content</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( status === </span><span class="s5">204 </span><span class="s1">|| s.type === </span><span class="s4">&quot;HEAD&quot; </span><span class="s1">) { 
                    statusText = </span><span class="s4">&quot;nocontent&quot;</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// if not modified</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( status === </span><span class="s5">304 </span><span class="s1">) { 
                    statusText = </span><span class="s4">&quot;notmodified&quot;</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// If we have data, let's convert it</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    statusText = response.state</span><span class="s3">;</span><span class="s1"> 
                    success = response.data</span><span class="s3">;</span><span class="s1"> 
                    error = response.error</span><span class="s3">;</span><span class="s1"> 
                    isSuccess = !error</span><span class="s3">;</span><span class="s1"> 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s0">// We extract error from statusText</span><span class="s1"> 
                </span><span class="s0">// then normalize statusText and status for non-aborts</span><span class="s1"> 
                error = statusText</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( status || !statusText ) { 
                    statusText = </span><span class="s4">&quot;error&quot;</span><span class="s3">;</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( status &lt; </span><span class="s5">0 </span><span class="s1">) { 
                        status = </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            } 
 
            </span><span class="s0">// Set data for the fake xhr object</span><span class="s1"> 
            jqXHR.status = status</span><span class="s3">;</span><span class="s1"> 
            jqXHR.statusText = ( nativeStatusText || statusText ) + </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Success/Error</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( isSuccess ) { 
                deferred.resolveWith( callbackContext</span><span class="s3">, </span><span class="s1">[ success</span><span class="s3">, </span><span class="s1">statusText</span><span class="s3">, </span><span class="s1">jqXHR ] )</span><span class="s3">;</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                deferred.rejectWith( callbackContext</span><span class="s3">, </span><span class="s1">[ jqXHR</span><span class="s3">, </span><span class="s1">statusText</span><span class="s3">, </span><span class="s1">error ] )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
            jqXHR.statusCode( statusCode )</span><span class="s3">;</span><span class="s1"> 
            statusCode = undefined</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                globalEventContext.trigger( isSuccess ? </span><span class="s4">&quot;ajaxSuccess&quot; </span><span class="s1">: </span><span class="s4">&quot;ajaxError&quot;</span><span class="s3">,</span><span class="s1"> 
                    [ jqXHR</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">isSuccess ? success : error ] )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Complete</span><span class="s1"> 
            completeDeferred.fireWith( callbackContext</span><span class="s3">, </span><span class="s1">[ jqXHR</span><span class="s3">, </span><span class="s1">statusText ] )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                globalEventContext.trigger( </span><span class="s4">&quot;ajaxComplete&quot;</span><span class="s3">, </span><span class="s1">[ jqXHR</span><span class="s3">, </span><span class="s1">s ] )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// Handle the global AJAX counter</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !( --jQuery.active ) ) { 
                    jQuery.event.trigger(</span><span class="s4">&quot;ajaxStop&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">jqXHR</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    getJSON: </span><span class="s2">function</span><span class="s1">( url</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.get( url</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s4">&quot;json&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    getScript: </span><span class="s2">function</span><span class="s1">( url</span><span class="s3">, </span><span class="s1">callback ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.get( url</span><span class="s3">, </span><span class="s1">undefined</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s4">&quot;script&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
jQuery.each( [ </span><span class="s4">&quot;get&quot;</span><span class="s3">, </span><span class="s4">&quot;post&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">method ) { 
    jQuery[ method ] = </span><span class="s2">function</span><span class="s1">( url</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">type ) { 
        </span><span class="s0">// shift arguments if data argument was omitted</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( data ) ) { 
            type = type || callback</span><span class="s3">;</span><span class="s1"> 
            callback = data</span><span class="s3">;</span><span class="s1"> 
            data = undefined</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return </span><span class="s1">jQuery.ajax({ 
            url: url</span><span class="s3">,</span><span class="s1"> 
            type: method</span><span class="s3">,</span><span class="s1"> 
            dataType: type</span><span class="s3">,</span><span class="s1"> 
            data: data</span><span class="s3">,</span><span class="s1"> 
            success: callback 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
jQuery._evalUrl = </span><span class="s2">function</span><span class="s1">( url ) { 
    </span><span class="s2">return </span><span class="s1">jQuery.ajax({ 
        url: url</span><span class="s3">,</span><span class="s1"> 
        type: </span><span class="s4">&quot;GET&quot;</span><span class="s3">,</span><span class="s1"> 
        dataType: </span><span class="s4">&quot;script&quot;</span><span class="s3">,</span><span class="s1"> 
        async: </span><span class="s2">false</span><span class="s3">,</span><span class="s1"> 
        global: </span><span class="s2">false</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s4">&quot;throws&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
jQuery.fn.extend({ 
    wrapAll: </span><span class="s2">function</span><span class="s1">( html ) { 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( html ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">(i) { 
                jQuery(</span><span class="s2">this</span><span class="s1">).wrapAll( html.call(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">i) )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] ) { 
            </span><span class="s0">// The elements to wrap the target around</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">wrap = jQuery( html</span><span class="s3">, </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">].ownerDocument ).eq(</span><span class="s5">0</span><span class="s1">).clone(</span><span class="s2">true</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">].parentNode ) { 
                wrap.insertBefore( </span><span class="s2">this</span><span class="s1">[</span><span class="s5">0</span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            wrap.map(</span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">while </span><span class="s1">( elem.firstChild &amp;&amp; elem.firstChild.nodeType === </span><span class="s5">1 </span><span class="s1">) { 
                    elem = elem.firstChild</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">return </span><span class="s1">elem</span><span class="s3">;</span><span class="s1"> 
            }).append( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    wrapInner: </span><span class="s2">function</span><span class="s1">( html ) { 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( html ) ) { 
            </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">(i) { 
                jQuery(</span><span class="s2">this</span><span class="s1">).wrapInner( html.call(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">i) )</span><span class="s3">;</span><span class="s1"> 
            })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">self = jQuery( </span><span class="s2">this </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                contents = self.contents()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( contents.length ) { 
                contents.wrapAll( html )</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                self.append( html )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    wrap: </span><span class="s2">function</span><span class="s1">( html ) { 
        </span><span class="s2">var </span><span class="s1">isFunction = jQuery.isFunction( html )</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">(i) { 
            jQuery( </span><span class="s2">this </span><span class="s1">).wrapAll( isFunction ? html.call(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">i) : html )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    unwrap: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.parent().each(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( !jQuery.nodeName( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;body&quot; </span><span class="s1">) ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).replaceWith( </span><span class="s2">this</span><span class="s1">.childNodes )</span><span class="s3">;</span><span class="s1"> 
            } 
        }).end()</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
jQuery.expr.filters.hidden = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s0">// Support: Opera &lt;= 12.12</span><span class="s1"> 
    </span><span class="s0">// Opera reports offsetWidths and offsetHeights less than zero on some elements</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">elem.offsetWidth &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; elem.offsetHeight &lt;= </span><span class="s5">0 </span><span class="s1">|| 
        (!support.reliableHiddenOffsets() &amp;&amp; 
            ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;display&quot; </span><span class="s1">)) === </span><span class="s4">&quot;none&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.expr.filters.visible = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s2">return </span><span class="s1">!jQuery.expr.filters.hidden( elem )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s2">var </span><span class="s1">r20 = </span><span class="s4">/%20/g</span><span class="s3">,</span><span class="s1"> 
    rbracket = </span><span class="s4">/\[\]$/</span><span class="s3">,</span><span class="s1"> 
    rCRLF = </span><span class="s4">/\r?\n/g</span><span class="s3">,</span><span class="s1"> 
    rsubmitterTypes = </span><span class="s4">/^(?:submit|button|image|reset|file)$/i</span><span class="s3">,</span><span class="s1"> 
    rsubmittable = </span><span class="s4">/^(?:input|select|textarea|keygen)/i</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">function </span><span class="s1">buildParams( prefix</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">traditional</span><span class="s3">, </span><span class="s1">add ) { 
    </span><span class="s2">var </span><span class="s1">name</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( jQuery.isArray( obj ) ) { 
        </span><span class="s0">// Serialize array item.</span><span class="s1"> 
        jQuery.each( obj</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">v ) { 
            </span><span class="s2">if </span><span class="s1">( traditional || rbracket.test( prefix ) ) { 
                </span><span class="s0">// Treat each array item as a scalar.</span><span class="s1"> 
                add( prefix</span><span class="s3">, </span><span class="s1">v )</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s0">// Item is non-scalar (array or object), encode its numeric index.</span><span class="s1"> 
                buildParams( prefix + </span><span class="s4">&quot;[&quot; </span><span class="s1">+ ( </span><span class="s2">typeof </span><span class="s1">v === </span><span class="s4">&quot;object&quot; </span><span class="s1">? i : </span><span class="s4">&quot;&quot; </span><span class="s1">) + </span><span class="s4">&quot;]&quot;</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">traditional</span><span class="s3">, </span><span class="s1">add )</span><span class="s3">;</span><span class="s1"> 
            } 
        })</span><span class="s3">;</span><span class="s1"> 
 
    } </span><span class="s2">else if </span><span class="s1">( !traditional &amp;&amp; jQuery.type( obj ) === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
        </span><span class="s0">// Serialize object item.</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">obj ) { 
            buildParams( prefix + </span><span class="s4">&quot;[&quot; </span><span class="s1">+ name + </span><span class="s4">&quot;]&quot;</span><span class="s3">, </span><span class="s1">obj[ name ]</span><span class="s3">, </span><span class="s1">traditional</span><span class="s3">, </span><span class="s1">add )</span><span class="s3">;</span><span class="s1"> 
        } 
 
    } </span><span class="s2">else </span><span class="s1">{ 
        </span><span class="s0">// Serialize scalar item.</span><span class="s1"> 
        add( prefix</span><span class="s3">, </span><span class="s1">obj )</span><span class="s3">;</span><span class="s1"> 
    } 
} 
 
</span><span class="s0">// Serialize an array of form elements or a set of</span><span class="s1"> 
</span><span class="s0">// key/values into a query string</span><span class="s1"> 
jQuery.param = </span><span class="s2">function</span><span class="s1">( a</span><span class="s3">, </span><span class="s1">traditional ) { 
    </span><span class="s2">var </span><span class="s1">prefix</span><span class="s3">,</span><span class="s1"> 
        s = []</span><span class="s3">,</span><span class="s1"> 
        add = </span><span class="s2">function</span><span class="s1">( key</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s0">// If value is a function, invoke it and return its value</span><span class="s1"> 
            value = jQuery.isFunction( value ) ? value() : ( value == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">&quot;&quot; </span><span class="s1">: value )</span><span class="s3">;</span><span class="s1"> 
            s[ s.length ] = encodeURIComponent( key ) + </span><span class="s4">&quot;=&quot; </span><span class="s1">+ encodeURIComponent( value )</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Set traditional to true for jQuery &lt;= 1.3.2 behavior.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( traditional === undefined ) { 
        traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// If an array was passed in, assume that it is an array of form elements.</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) { 
        </span><span class="s0">// Serialize the form elements</span><span class="s1"> 
        jQuery.each( a</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
            add( </span><span class="s2">this</span><span class="s1">.name</span><span class="s3">, </span><span class="s2">this</span><span class="s1">.value )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
    } </span><span class="s2">else </span><span class="s1">{ 
        </span><span class="s0">// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older</span><span class="s1"> 
        </span><span class="s0">// did it), otherwise encode params recursively.</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( prefix </span><span class="s2">in </span><span class="s1">a ) { 
            buildParams( prefix</span><span class="s3">, </span><span class="s1">a[ prefix ]</span><span class="s3">, </span><span class="s1">traditional</span><span class="s3">, </span><span class="s1">add )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">// Return the resulting serialization</span><span class="s1"> 
    </span><span class="s2">return </span><span class="s1">s.join( </span><span class="s4">&quot;&amp;&quot; </span><span class="s1">).replace( r20</span><span class="s3">, </span><span class="s4">&quot;+&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    serialize: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">jQuery.param( </span><span class="s2">this</span><span class="s1">.serializeArray() )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    serializeArray: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.map(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// Can add propHook for &quot;elements&quot; to filter or add form elements</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">elements = jQuery.prop( </span><span class="s2">this</span><span class="s3">, </span><span class="s4">&quot;elements&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">elements ? jQuery.makeArray( elements ) : </span><span class="s2">this</span><span class="s3">;</span><span class="s1"> 
        }) 
        .filter(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">type = </span><span class="s2">this</span><span class="s1">.type</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s0">// Use .is(&quot;:disabled&quot;) so that fieldset[disabled] works</span><span class="s1"> 
            </span><span class="s2">return this</span><span class="s1">.name &amp;&amp; !jQuery( </span><span class="s2">this </span><span class="s1">).is( </span><span class="s4">&quot;:disabled&quot; </span><span class="s1">) &amp;&amp; 
                rsubmittable.test( </span><span class="s2">this</span><span class="s1">.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp; 
                ( </span><span class="s2">this</span><span class="s1">.checked || !rcheckableType.test( type ) )</span><span class="s3">;</span><span class="s1"> 
        }) 
        .map(</span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">elem ) { 
            </span><span class="s2">var </span><span class="s1">val = jQuery( </span><span class="s2">this </span><span class="s1">).val()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">val == </span><span class="s2">null </span><span class="s1">? 
                </span><span class="s2">null </span><span class="s1">: 
                jQuery.isArray( val ) ? 
                    jQuery.map( val</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( val ) { 
                        </span><span class="s2">return </span><span class="s1">{ name: elem.name</span><span class="s3">, </span><span class="s1">value: val.replace( rCRLF</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s3">\r\n</span><span class="s4">&quot; </span><span class="s1">) }</span><span class="s3">;</span><span class="s1"> 
                    }) : 
                    { name: elem.name</span><span class="s3">, </span><span class="s1">value: val.replace( rCRLF</span><span class="s3">, </span><span class="s4">&quot;</span><span class="s3">\r\n</span><span class="s4">&quot; </span><span class="s1">) }</span><span class="s3">;</span><span class="s1"> 
        }).get()</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Create the request object</span><span class="s1"> 
</span><span class="s0">// (This is still attached to ajaxSettings for backward compatibility)</span><span class="s1"> 
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? 
    </span><span class="s0">// Support: IE6+</span><span class="s1"> 
    </span><span class="s2">function</span><span class="s1">() { 
 
        </span><span class="s0">// XHR cannot access local files, always use ActiveX for that case</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">!</span><span class="s2">this</span><span class="s1">.isLocal &amp;&amp; 
 
            </span><span class="s0">// Support: IE7-8</span><span class="s1"> 
            </span><span class="s0">// oldIE XHR does not support non-RFC2616 methods (#13240)</span><span class="s1"> 
            </span><span class="s0">// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx</span><span class="s1"> 
            </span><span class="s0">// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9</span><span class="s1"> 
            </span><span class="s0">// Although this check for six methods instead of eight</span><span class="s1"> 
            </span><span class="s0">// since IE also does not support &quot;trace&quot; and &quot;connect&quot;</span><span class="s1"> 
            </span><span class="s4">/^(get|post|head|put|delete|options)$/i</span><span class="s1">.test( </span><span class="s2">this</span><span class="s1">.type ) &amp;&amp; 
 
            createStandardXHR() || createActiveXHR()</span><span class="s3">;</span><span class="s1"> 
    } : 
    </span><span class="s0">// For all other browsers, use the standard XMLHttpRequest object</span><span class="s1"> 
    createStandardXHR</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s2">var </span><span class="s1">xhrId = </span><span class="s5">0</span><span class="s3">,</span><span class="s1"> 
    xhrCallbacks = {}</span><span class="s3">,</span><span class="s1"> 
    xhrSupported = jQuery.ajaxSettings.xhr()</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Support: IE&lt;10</span><span class="s1"> 
</span><span class="s0">// Open requests must be manually aborted on unload (#5280)</span><span class="s1"> 
</span><span class="s0">// See https://support.microsoft.com/kb/2856746 for more info</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( window.attachEvent ) { 
    window.attachEvent( </span><span class="s4">&quot;onunload&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">for </span><span class="s1">( </span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">xhrCallbacks ) { 
            xhrCallbacks[ key ]( undefined</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Determine support properties</span><span class="s1"> 
support.cors = !!xhrSupported &amp;&amp; ( </span><span class="s4">&quot;withCredentials&quot; </span><span class="s2">in </span><span class="s1">xhrSupported )</span><span class="s3">;</span><span class="s1"> 
xhrSupported = support.ajax = !!xhrSupported</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Create transport if the browser can provide an xhr</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( xhrSupported ) { 
 
    jQuery.ajaxTransport(</span><span class="s2">function</span><span class="s1">( options ) { 
        </span><span class="s0">// Cross domain only allowed if supported through XMLHttpRequest</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !options.crossDomain || support.cors ) { 
 
            </span><span class="s2">var </span><span class="s1">callback</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">{ 
                send: </span><span class="s2">function</span><span class="s1">( headers</span><span class="s3">, </span><span class="s1">complete ) { 
                    </span><span class="s2">var </span><span class="s1">i</span><span class="s3">,</span><span class="s1"> 
                        xhr = options.xhr()</span><span class="s3">,</span><span class="s1"> 
                        id = ++xhrId</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Open the socket</span><span class="s1"> 
                    xhr.open( options.type</span><span class="s3">, </span><span class="s1">options.url</span><span class="s3">, </span><span class="s1">options.async</span><span class="s3">, </span><span class="s1">options.username</span><span class="s3">, </span><span class="s1">options.password )</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Apply custom fields if provided</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( options.xhrFields ) { 
                        </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">options.xhrFields ) { 
                            xhr[ i ] = options.xhrFields[ i ]</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    </span><span class="s0">// Override mime type if needed</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( options.mimeType &amp;&amp; xhr.overrideMimeType ) { 
                        xhr.overrideMimeType( options.mimeType )</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// X-Requested-With header</span><span class="s1"> 
                    </span><span class="s0">// For cross-domain requests, seeing as conditions for a preflight are</span><span class="s1"> 
                    </span><span class="s0">// akin to a jigsaw puzzle, we simply never set it to be sure.</span><span class="s1"> 
                    </span><span class="s0">// (it can always be set on a per-request basis or even using ajaxSetup)</span><span class="s1"> 
                    </span><span class="s0">// For same-domain requests, won't change header if already provided.</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !options.crossDomain &amp;&amp; !headers[</span><span class="s4">&quot;X-Requested-With&quot;</span><span class="s1">] ) { 
                        headers[</span><span class="s4">&quot;X-Requested-With&quot;</span><span class="s1">] = </span><span class="s4">&quot;XMLHttpRequest&quot;</span><span class="s3">;</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Set headers</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">headers ) { 
                        </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
                        </span><span class="s0">// IE's ActiveXObject throws a 'Type Mismatch' exception when setting</span><span class="s1"> 
                        </span><span class="s0">// request header to a null-value.</span><span class="s1"> 
                        </span><span class="s0">//</span><span class="s1"> 
                        </span><span class="s0">// To keep consistent with other XHR implementations, cast the value</span><span class="s1"> 
                        </span><span class="s0">// to string and ignore `undefined`.</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( headers[ i ] !== undefined ) { 
                            xhr.setRequestHeader( i</span><span class="s3">, </span><span class="s1">headers[ i ] + </span><span class="s4">&quot;&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
 
                    </span><span class="s0">// Do send the request</span><span class="s1"> 
                    </span><span class="s0">// This may raise an exception which is actually</span><span class="s1"> 
                    </span><span class="s0">// handled in jQuery.ajax (so no try/catch here)</span><span class="s1"> 
                    xhr.send( ( options.hasContent &amp;&amp; options.data ) || </span><span class="s2">null </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Listener</span><span class="s1"> 
                    callback = </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">isAbort ) { 
                        </span><span class="s2">var </span><span class="s1">status</span><span class="s3">, </span><span class="s1">statusText</span><span class="s3">, </span><span class="s1">responses</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// Was never called and is aborted or complete</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( callback &amp;&amp; ( isAbort || xhr.readyState === </span><span class="s5">4 </span><span class="s1">) ) { 
                            </span><span class="s0">// Clean up</span><span class="s1"> 
                            </span><span class="s2">delete </span><span class="s1">xhrCallbacks[ id ]</span><span class="s3">;</span><span class="s1"> 
                            callback = undefined</span><span class="s3">;</span><span class="s1"> 
                            xhr.onreadystatechange = jQuery.noop</span><span class="s3">;</span><span class="s1"> 
 
                            </span><span class="s0">// Abort manually if needed</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( isAbort ) { 
                                </span><span class="s2">if </span><span class="s1">( xhr.readyState !== </span><span class="s5">4 </span><span class="s1">) { 
                                    xhr.abort()</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } </span><span class="s2">else </span><span class="s1">{ 
                                responses = {}</span><span class="s3">;</span><span class="s1"> 
                                status = xhr.status</span><span class="s3">;</span><span class="s1"> 
 
                                </span><span class="s0">// Support: IE&lt;10</span><span class="s1"> 
                                </span><span class="s0">// Accessing binary-data responseText throws an exception</span><span class="s1"> 
                                </span><span class="s0">// (#11426)</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">xhr.responseText === </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
                                    responses.text = xhr.responseText</span><span class="s3">;</span><span class="s1"> 
                                } 
 
                                </span><span class="s0">// Firefox throws an exception when accessing</span><span class="s1"> 
                                </span><span class="s0">// statusText for faulty cross-domain requests</span><span class="s1"> 
                                </span><span class="s2">try </span><span class="s1">{ 
                                    statusText = xhr.statusText</span><span class="s3">;</span><span class="s1"> 
                                } </span><span class="s2">catch</span><span class="s1">( e ) { 
                                    </span><span class="s0">// We normalize with Webkit giving an empty statusText</span><span class="s1"> 
                                    statusText = </span><span class="s4">&quot;&quot;</span><span class="s3">;</span><span class="s1"> 
                                } 
 
                                </span><span class="s0">// Filter status for non standard behaviors</span><span class="s1"> 
 
                                </span><span class="s0">// If the request is local and we have data: assume a success</span><span class="s1"> 
                                </span><span class="s0">// (success with no data won't get notified, that's the best we</span><span class="s1"> 
                                </span><span class="s0">// can do given current implementations)</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( !status &amp;&amp; options.isLocal &amp;&amp; !options.crossDomain ) { 
                                    status = responses.text ? </span><span class="s5">200 </span><span class="s1">: </span><span class="s5">404</span><span class="s3">;</span><span class="s1"> 
                                </span><span class="s0">// IE - #1450: sometimes returns 1223 when it should be 204</span><span class="s1"> 
                                } </span><span class="s2">else if </span><span class="s1">( status === </span><span class="s5">1223 </span><span class="s1">) { 
                                    status = </span><span class="s5">204</span><span class="s3">;</span><span class="s1"> 
                                } 
                            } 
                        } 
 
                        </span><span class="s0">// Call complete if needed</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( responses ) { 
                            complete( status</span><span class="s3">, </span><span class="s1">statusText</span><span class="s3">, </span><span class="s1">responses</span><span class="s3">, </span><span class="s1">xhr.getAllResponseHeaders() )</span><span class="s3">;</span><span class="s1"> 
                        } 
                    }</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s2">if </span><span class="s1">( !options.async ) { 
                        </span><span class="s0">// if we're in sync mode we fire the callback</span><span class="s1"> 
                        callback()</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( xhr.readyState === </span><span class="s5">4 </span><span class="s1">) { 
                        </span><span class="s0">// (IE6 &amp; IE7) if it's in cache and has been</span><span class="s1"> 
                        </span><span class="s0">// retrieved directly we need to fire the callback</span><span class="s1"> 
                        setTimeout( callback )</span><span class="s3">;</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        </span><span class="s0">// Add to the list of active xhr callbacks</span><span class="s1"> 
                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback</span><span class="s3">;</span><span class="s1"> 
                    } 
                }</span><span class="s3">,</span><span class="s1"> 
 
                abort: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( callback ) { 
                        callback( undefined</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                    } 
                } 
            }</span><span class="s3">;</span><span class="s1"> 
        } 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
</span><span class="s0">// Functions to create xhrs</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">createStandardXHR() { 
    </span><span class="s2">try </span><span class="s1">{ 
        </span><span class="s2">return new </span><span class="s1">window.XMLHttpRequest()</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">catch</span><span class="s1">( e ) {} 
} 
 
</span><span class="s2">function </span><span class="s1">createActiveXHR() { 
    </span><span class="s2">try </span><span class="s1">{ 
        </span><span class="s2">return new </span><span class="s1">window.ActiveXObject( </span><span class="s4">&quot;Microsoft.XMLHTTP&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    } </span><span class="s2">catch</span><span class="s1">( e ) {} 
} 
 
 
 
 
</span><span class="s0">// Install script dataType</span><span class="s1"> 
jQuery.ajaxSetup({ 
    accepts: { 
        script: </span><span class="s4">&quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    contents: { 
        script: </span><span class="s4">/(?:java|ecma)script/</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
    converters: { 
        </span><span class="s4">&quot;text script&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( text ) { 
            jQuery.globalEval( text )</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">text</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Handle cache's special case and global</span><span class="s1"> 
jQuery.ajaxPrefilter( </span><span class="s4">&quot;script&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( s ) { 
    </span><span class="s2">if </span><span class="s1">( s.cache === undefined ) { 
        s.cache = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">if </span><span class="s1">( s.crossDomain ) { 
        s.type = </span><span class="s4">&quot;GET&quot;</span><span class="s3">;</span><span class="s1"> 
        s.global = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Bind script tag hack transport</span><span class="s1"> 
jQuery.ajaxTransport( </span><span class="s4">&quot;script&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">(s) { 
 
    </span><span class="s0">// This transport only deals with cross domain requests</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( s.crossDomain ) { 
 
        </span><span class="s2">var </span><span class="s1">script</span><span class="s3">,</span><span class="s1"> 
            head = document.head || jQuery(</span><span class="s4">&quot;head&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] || document.documentElement</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">return </span><span class="s1">{ 
 
            send: </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">callback ) { 
 
                script = document.createElement(</span><span class="s4">&quot;script&quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
                script.async = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( s.scriptCharset ) { 
                    script.charset = s.scriptCharset</span><span class="s3">;</span><span class="s1"> 
                } 
 
                script.src = s.url</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Attach handlers for all browsers</span><span class="s1"> 
                script.onload = script.onreadystatechange = </span><span class="s2">function</span><span class="s1">( _</span><span class="s3">, </span><span class="s1">isAbort ) { 
 
                    </span><span class="s2">if </span><span class="s1">( isAbort || !script.readyState || </span><span class="s4">/loaded|complete/</span><span class="s1">.test( script.readyState ) ) { 
 
                        </span><span class="s0">// Handle memory leak in IE</span><span class="s1"> 
                        script.onload = script.onreadystatechange = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// Remove the script</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( script.parentNode ) { 
                            script.parentNode.removeChild( script )</span><span class="s3">;</span><span class="s1"> 
                        } 
 
                        </span><span class="s0">// Dereference the script</span><span class="s1"> 
                        script = </span><span class="s2">null</span><span class="s3">;</span><span class="s1"> 
 
                        </span><span class="s0">// Callback if not abort</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !isAbort ) { 
                            callback( </span><span class="s5">200</span><span class="s3">, </span><span class="s4">&quot;success&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                        } 
                    } 
                }</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending</span><span class="s1"> 
                </span><span class="s0">// Use native DOM manipulation to avoid our domManip AJAX trickery</span><span class="s1"> 
                head.insertBefore( script</span><span class="s3">, </span><span class="s1">head.firstChild )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">,</span><span class="s1"> 
 
            abort: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( script ) { 
                    script.onload( undefined</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
                } 
            } 
        }</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s2">var </span><span class="s1">oldCallbacks = []</span><span class="s3">,</span><span class="s1"> 
    rjsonp = </span><span class="s4">/(=)\?(?=&amp;|$)|\?\?/</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Default jsonp settings</span><span class="s1"> 
jQuery.ajaxSetup({ 
    jsonp: </span><span class="s4">&quot;callback&quot;</span><span class="s3">,</span><span class="s1"> 
    jsonpCallback: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">callback = oldCallbacks.pop() || ( jQuery.expando + </span><span class="s4">&quot;_&quot; </span><span class="s1">+ ( nonce++ ) )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">[ callback ] = </span><span class="s2">true</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">callback</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Detect, normalize options and install callbacks for jsonp requests</span><span class="s1"> 
jQuery.ajaxPrefilter( </span><span class="s4">&quot;json jsonp&quot;</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( s</span><span class="s3">, </span><span class="s1">originalSettings</span><span class="s3">, </span><span class="s1">jqXHR ) { 
 
    </span><span class="s2">var </span><span class="s1">callbackName</span><span class="s3">, </span><span class="s1">overwritten</span><span class="s3">, </span><span class="s1">responseContainer</span><span class="s3">,</span><span class="s1"> 
        jsonProp = s.jsonp !== </span><span class="s2">false </span><span class="s1">&amp;&amp; ( rjsonp.test( s.url ) ? 
            </span><span class="s4">&quot;url&quot; </span><span class="s1">: 
            </span><span class="s2">typeof </span><span class="s1">s.data === </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; !( s.contentType || </span><span class="s4">&quot;&quot; </span><span class="s1">).indexOf(</span><span class="s4">&quot;application/x-www-form-urlencoded&quot;</span><span class="s1">) &amp;&amp; rjsonp.test( s.data ) &amp;&amp; </span><span class="s4">&quot;data&quot;</span><span class="s1"> 
        )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( jsonProp || s.dataTypes[ </span><span class="s5">0 </span><span class="s1">] === </span><span class="s4">&quot;jsonp&quot; </span><span class="s1">) { 
 
        </span><span class="s0">// Get callback name, remembering preexisting value associated with it</span><span class="s1"> 
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ? 
            s.jsonpCallback() : 
            s.jsonpCallback</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Insert callback into url or form data</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jsonProp ) { 
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp</span><span class="s3">, </span><span class="s4">&quot;$1&quot; </span><span class="s1">+ callbackName )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( s.jsonp !== </span><span class="s2">false </span><span class="s1">) { 
            s.url += ( rquery.test( s.url ) ? </span><span class="s4">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s4">&quot;?&quot; </span><span class="s1">) + s.jsonp + </span><span class="s4">&quot;=&quot; </span><span class="s1">+ callbackName</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Use data converter to retrieve json after script execution</span><span class="s1"> 
        s.converters[</span><span class="s4">&quot;script json&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( !responseContainer ) { 
                jQuery.error( callbackName + </span><span class="s4">&quot; was not called&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">responseContainer[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// force json dataType</span><span class="s1"> 
        s.dataTypes[ </span><span class="s5">0 </span><span class="s1">] = </span><span class="s4">&quot;json&quot;</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Install callback</span><span class="s1"> 
        overwritten = window[ callbackName ]</span><span class="s3">;</span><span class="s1"> 
        window[ callbackName ] = </span><span class="s2">function</span><span class="s1">() { 
            responseContainer = arguments</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Clean-up function (fires after converters)</span><span class="s1"> 
        jqXHR.always(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s0">// Restore preexisting value</span><span class="s1"> 
            window[ callbackName ] = overwritten</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Save back as free</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s[ callbackName ] ) { 
                </span><span class="s0">// make sure that re-using the options doesn't screw things around</span><span class="s1"> 
                s.jsonpCallback = originalSettings.jsonpCallback</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s0">// save the callback name for future use</span><span class="s1"> 
                oldCallbacks.push( callbackName )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Call if it was a function and we have a response</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) { 
                overwritten( responseContainer[ </span><span class="s5">0 </span><span class="s1">] )</span><span class="s3">;</span><span class="s1"> 
            } 
 
            responseContainer = overwritten = undefined</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Delegate to script</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s4">&quot;script&quot;</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s0">// data: string of html</span><span class="s1"> 
</span><span class="s0">// context (optional): If specified, the fragment will be created in this context, defaults to document</span><span class="s1"> 
</span><span class="s0">// keepScripts (optional): If true, will include scripts passed in the html string</span><span class="s1"> 
jQuery.parseHTML = </span><span class="s2">function</span><span class="s1">( data</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">keepScripts ) { 
    </span><span class="s2">if </span><span class="s1">( !data || </span><span class="s2">typeof </span><span class="s1">data !== </span><span class="s4">&quot;string&quot; </span><span class="s1">) { 
        </span><span class="s2">return null</span><span class="s3">;</span><span class="s1"> 
    } 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context === </span><span class="s4">&quot;boolean&quot; </span><span class="s1">) { 
        keepScripts = context</span><span class="s3">;</span><span class="s1"> 
        context = </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
    } 
    context = context || document</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">var </span><span class="s1">parsed = rsingleTag.exec( data )</span><span class="s3">,</span><span class="s1"> 
        scripts = !keepScripts &amp;&amp; []</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Single tag</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( parsed ) { 
        </span><span class="s2">return </span><span class="s1">[ context.createElement( parsed[</span><span class="s5">1</span><span class="s1">] ) ]</span><span class="s3">;</span><span class="s1"> 
    } 
 
    parsed = jQuery.buildFragment( [ data ]</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">scripts )</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( scripts &amp;&amp; scripts.length ) { 
        jQuery( scripts ).remove()</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">jQuery.merge( []</span><span class="s3">, </span><span class="s1">parsed.childNodes )</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Keep a copy of the old load method</span><span class="s1"> 
</span><span class="s2">var </span><span class="s1">_load = jQuery.fn.load</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Load a url into a page 
 */</span><span class="s1"> 
jQuery.fn.load = </span><span class="s2">function</span><span class="s1">( url</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">callback ) { 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">url !== </span><span class="s4">&quot;string&quot; </span><span class="s1">&amp;&amp; _load ) { 
        </span><span class="s2">return </span><span class="s1">_load.apply( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">var </span><span class="s1">selector</span><span class="s3">, </span><span class="s1">response</span><span class="s3">, </span><span class="s1">type</span><span class="s3">,</span><span class="s1"> 
        self = </span><span class="s2">this</span><span class="s3">,</span><span class="s1"> 
        off = url.indexOf(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( off &gt;= </span><span class="s5">0 </span><span class="s1">) { 
        selector = jQuery.trim( url.slice( off</span><span class="s3">, </span><span class="s1">url.length ) )</span><span class="s3">;</span><span class="s1"> 
        url = url.slice( </span><span class="s5">0</span><span class="s3">, </span><span class="s1">off )</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// If it's a function</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( params ) ) { 
 
        </span><span class="s0">// We assume that it's the callback</span><span class="s1"> 
        callback = params</span><span class="s3">;</span><span class="s1"> 
        params = undefined</span><span class="s3">;</span><span class="s1"> 
 
    </span><span class="s0">// Otherwise, build a param string</span><span class="s1"> 
    } </span><span class="s2">else if </span><span class="s1">( params &amp;&amp; </span><span class="s2">typeof </span><span class="s1">params === </span><span class="s4">&quot;object&quot; </span><span class="s1">) { 
        type = </span><span class="s4">&quot;POST&quot;</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">// If we have elements to modify, make the request</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( self.length &gt; </span><span class="s5">0 </span><span class="s1">) { 
        jQuery.ajax({ 
            url: url</span><span class="s3">,</span><span class="s1"> 
 
            </span><span class="s0">// if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used</span><span class="s1"> 
            type: type</span><span class="s3">,</span><span class="s1"> 
            dataType: </span><span class="s4">&quot;html&quot;</span><span class="s3">,</span><span class="s1"> 
            data: params 
        }).done(</span><span class="s2">function</span><span class="s1">( responseText ) { 
 
            </span><span class="s0">// Save response for use in complete callback</span><span class="s1"> 
            response = arguments</span><span class="s3">;</span><span class="s1"> 
 
            self.html( selector ? 
 
                </span><span class="s0">// If a selector was specified, locate the right elements in a dummy div</span><span class="s1"> 
                </span><span class="s0">// Exclude scripts to avoid IE 'Permission Denied' errors</span><span class="s1"> 
                jQuery(</span><span class="s4">&quot;&lt;div&gt;&quot;</span><span class="s1">).append( jQuery.parseHTML( responseText ) ).find( selector ) : 
 
                </span><span class="s0">// Otherwise use the full result</span><span class="s1"> 
                responseText )</span><span class="s3">;</span><span class="s1"> 
 
        }).complete( callback &amp;&amp; </span><span class="s2">function</span><span class="s1">( jqXHR</span><span class="s3">, </span><span class="s1">status ) { 
            self.each( callback</span><span class="s3">, </span><span class="s1">response || [ jqXHR.responseText</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">jqXHR ] )</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return this</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s0">// Attach a bunch of functions for handling common AJAX events</span><span class="s1"> 
jQuery.each( [ </span><span class="s4">&quot;ajaxStart&quot;</span><span class="s3">, </span><span class="s4">&quot;ajaxStop&quot;</span><span class="s3">, </span><span class="s4">&quot;ajaxComplete&quot;</span><span class="s3">, </span><span class="s4">&quot;ajaxError&quot;</span><span class="s3">, </span><span class="s4">&quot;ajaxSuccess&quot;</span><span class="s3">, </span><span class="s4">&quot;ajaxSend&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">type ) { 
    jQuery.fn[ type ] = </span><span class="s2">function</span><span class="s1">( fn ) { 
        </span><span class="s2">return this</span><span class="s1">.on( type</span><span class="s3">, </span><span class="s1">fn )</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
jQuery.expr.filters.animated = </span><span class="s2">function</span><span class="s1">( elem ) { 
    </span><span class="s2">return </span><span class="s1">jQuery.grep(jQuery.timers</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( fn ) { 
        </span><span class="s2">return </span><span class="s1">elem === fn.elem</span><span class="s3">;</span><span class="s1"> 
    }).length</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
 
</span><span class="s2">var </span><span class="s1">docElem = window.document.documentElement</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s6">/** 
 * Gets a window from an element 
 */</span><span class="s1"> 
</span><span class="s2">function </span><span class="s1">getWindow( elem ) { 
    </span><span class="s2">return </span><span class="s1">jQuery.isWindow( elem ) ? 
        elem : 
        elem.nodeType === </span><span class="s5">9 </span><span class="s1">? 
            elem.defaultView || elem.parentWindow : 
            </span><span class="s2">false</span><span class="s3">;</span><span class="s1"> 
} 
 
jQuery.offset = { 
    setOffset: </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">i ) { 
        </span><span class="s2">var </span><span class="s1">curPosition</span><span class="s3">, </span><span class="s1">curLeft</span><span class="s3">, </span><span class="s1">curCSSTop</span><span class="s3">, </span><span class="s1">curTop</span><span class="s3">, </span><span class="s1">curOffset</span><span class="s3">, </span><span class="s1">curCSSLeft</span><span class="s3">, </span><span class="s1">calculatePosition</span><span class="s3">,</span><span class="s1"> 
            position = jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;position&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            curElem = jQuery( elem )</span><span class="s3">,</span><span class="s1"> 
            props = {}</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// set position first, in-case top/left are set even on static elem</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( position === </span><span class="s4">&quot;static&quot; </span><span class="s1">) { 
            elem.style.position = </span><span class="s4">&quot;relative&quot;</span><span class="s3">;</span><span class="s1"> 
        } 
 
        curOffset = curElem.offset()</span><span class="s3">;</span><span class="s1"> 
        curCSSTop = jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;top&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        curCSSLeft = jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;left&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        calculatePosition = ( position === </span><span class="s4">&quot;absolute&quot; </span><span class="s1">|| position === </span><span class="s4">&quot;fixed&quot; </span><span class="s1">) &amp;&amp; 
            jQuery.inArray(</span><span class="s4">&quot;auto&quot;</span><span class="s3">, </span><span class="s1">[ curCSSTop</span><span class="s3">, </span><span class="s1">curCSSLeft ] ) &gt; -</span><span class="s5">1</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// need to be able to calculate position if either top or left is auto and position is either absolute or fixed</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( calculatePosition ) { 
            curPosition = curElem.position()</span><span class="s3">;</span><span class="s1"> 
            curTop = curPosition.top</span><span class="s3">;</span><span class="s1"> 
            curLeft = curPosition.left</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            curTop = parseFloat( curCSSTop ) || </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
            curLeft = parseFloat( curCSSLeft ) || </span><span class="s5">0</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( options ) ) { 
            options = options.call( elem</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">curOffset )</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( options.top != </span><span class="s2">null </span><span class="s1">) { 
            props.top = ( options.top - curOffset.top ) + curTop</span><span class="s3">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">( options.left != </span><span class="s2">null </span><span class="s1">) { 
            props.left = ( options.left - curOffset.left ) + curLeft</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s4">&quot;using&quot; </span><span class="s2">in </span><span class="s1">options ) { 
            options.using.call( elem</span><span class="s3">, </span><span class="s1">props )</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            curElem.css( props )</span><span class="s3">;</span><span class="s1"> 
        } 
    } 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.extend({ 
    offset: </span><span class="s2">function</span><span class="s1">( options ) { 
        </span><span class="s2">if </span><span class="s1">( arguments.length ) { 
            </span><span class="s2">return </span><span class="s1">options === undefined ? 
                </span><span class="s2">this </span><span class="s1">: 
                </span><span class="s2">this</span><span class="s1">.each(</span><span class="s2">function</span><span class="s1">( i ) { 
                    jQuery.offset.setOffset( </span><span class="s2">this</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">i )</span><span class="s3">;</span><span class="s1"> 
                })</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">var </span><span class="s1">docElem</span><span class="s3">, </span><span class="s1">win</span><span class="s3">,</span><span class="s1"> 
            box = { top: </span><span class="s5">0</span><span class="s3">, </span><span class="s1">left: </span><span class="s5">0 </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
            elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">,</span><span class="s1"> 
            doc = elem &amp;&amp; elem.ownerDocument</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">( !doc ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        docElem = doc.documentElement</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// Make sure it's not a disconnected DOM node</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !jQuery.contains( docElem</span><span class="s3">, </span><span class="s1">elem ) ) { 
            </span><span class="s2">return </span><span class="s1">box</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// If we don't have gBCR, just use 0,0 rather than error</span><span class="s1"> 
        </span><span class="s0">// BlackBerry 5, iOS 3 (original iPhone)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.getBoundingClientRect !== strundefined ) { 
            box = elem.getBoundingClientRect()</span><span class="s3">;</span><span class="s1"> 
        } 
        win = getWindow( doc )</span><span class="s3">;</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">{ 
            top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || </span><span class="s5">0 </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || </span><span class="s5">0 </span><span class="s1">) 
        }</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    position: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">if </span><span class="s1">( !</span><span class="s2">this</span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">] ) { 
            </span><span class="s2">return</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">var </span><span class="s1">offsetParent</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">,</span><span class="s1"> 
            parentOffset = { top: </span><span class="s5">0</span><span class="s3">, </span><span class="s1">left: </span><span class="s5">0 </span><span class="s1">}</span><span class="s3">,</span><span class="s1"> 
            elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">;</span><span class="s1"> 
 
        </span><span class="s0">// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;position&quot; </span><span class="s1">) === </span><span class="s4">&quot;fixed&quot; </span><span class="s1">) { 
            </span><span class="s0">// we assume that getBoundingClientRect is available when computed position is fixed</span><span class="s1"> 
            offset = elem.getBoundingClientRect()</span><span class="s3">;</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s0">// Get *real* offsetParent</span><span class="s1"> 
            offsetParent = </span><span class="s2">this</span><span class="s1">.offsetParent()</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s0">// Get correct offsets</span><span class="s1"> 
            offset = </span><span class="s2">this</span><span class="s1">.offset()</span><span class="s3">;</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !jQuery.nodeName( offsetParent[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;html&quot; </span><span class="s1">) ) { 
                parentOffset = offsetParent.offset()</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">// Add offsetParent borders</span><span class="s1"> 
            parentOffset.top  += jQuery.css( offsetParent[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;borderTopWidth&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
            parentOffset.left += jQuery.css( offsetParent[ </span><span class="s5">0 </span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;borderLeftWidth&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">// Subtract parent offsets and element margins</span><span class="s1"> 
        </span><span class="s0">// note: when an element has margin: auto the offsetLeft and marginLeft</span><span class="s1"> 
        </span><span class="s0">// are the same in Safari causing offset.left to incorrectly be 0</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">{ 
            top:  offset.top  - parentOffset.top - jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;marginTop&quot;</span><span class="s3">, </span><span class="s2">true </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
            left: offset.left - parentOffset.left - jQuery.css( elem</span><span class="s3">, </span><span class="s4">&quot;marginLeft&quot;</span><span class="s3">, </span><span class="s2">true</span><span class="s1">) 
        }</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">,</span><span class="s1"> 
 
    offsetParent: </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return this</span><span class="s1">.map(</span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">offsetParent = </span><span class="s2">this</span><span class="s1">.offsetParent || docElem</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">while </span><span class="s1">( offsetParent &amp;&amp; ( !jQuery.nodeName( offsetParent</span><span class="s3">, </span><span class="s4">&quot;html&quot; </span><span class="s1">) &amp;&amp; jQuery.css( offsetParent</span><span class="s3">, </span><span class="s4">&quot;position&quot; </span><span class="s1">) === </span><span class="s4">&quot;static&quot; </span><span class="s1">) ) { 
                offsetParent = offsetParent.offsetParent</span><span class="s3">;</span><span class="s1"> 
            } 
            </span><span class="s2">return </span><span class="s1">offsetParent || docElem</span><span class="s3">;</span><span class="s1"> 
        })</span><span class="s3">;</span><span class="s1"> 
    } 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Create scrollLeft and scrollTop methods</span><span class="s1"> 
jQuery.each( { scrollLeft: </span><span class="s4">&quot;pageXOffset&quot;</span><span class="s3">, </span><span class="s1">scrollTop: </span><span class="s4">&quot;pageYOffset&quot; </span><span class="s1">}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( method</span><span class="s3">, </span><span class="s1">prop ) { 
    </span><span class="s2">var </span><span class="s1">top = </span><span class="s4">/Y/</span><span class="s1">.test( prop )</span><span class="s3">;</span><span class="s1"> 
 
    jQuery.fn[ method ] = </span><span class="s2">function</span><span class="s1">( val ) { 
        </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">val ) { 
            </span><span class="s2">var </span><span class="s1">win = getWindow( elem )</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">if </span><span class="s1">( val === undefined ) { 
                </span><span class="s2">return </span><span class="s1">win ? (prop </span><span class="s2">in </span><span class="s1">win) ? win[ prop ] : 
                    win.document.documentElement[ method ] : 
                    elem[ method ]</span><span class="s3">;</span><span class="s1"> 
            } 
 
            </span><span class="s2">if </span><span class="s1">( win ) { 
                win.scrollTo( 
                    !top ? val : jQuery( win ).scrollLeft()</span><span class="s3">,</span><span class="s1"> 
                    top ? val : jQuery( win ).scrollTop() 
                )</span><span class="s3">;</span><span class="s1"> 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                elem[ method ] = val</span><span class="s3">;</span><span class="s1"> 
            } 
        }</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">arguments.length</span><span class="s3">, </span><span class="s2">null </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
    }</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Add the top/left cssHooks using jQuery.fn.position</span><span class="s1"> 
</span><span class="s0">// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084</span><span class="s1"> 
</span><span class="s0">// getComputedStyle returns percent when specified for top/left/bottom/right</span><span class="s1"> 
</span><span class="s0">// rather than make the css module depend on the offset module, we just check for it here</span><span class="s1"> 
jQuery.each( [ </span><span class="s4">&quot;top&quot;</span><span class="s3">, </span><span class="s4">&quot;left&quot; </span><span class="s1">]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( i</span><span class="s3">, </span><span class="s1">prop ) { 
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition</span><span class="s3">,</span><span class="s1"> 
        </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">computed ) { 
            </span><span class="s2">if </span><span class="s1">( computed ) { 
                computed = curCSS( elem</span><span class="s3">, </span><span class="s1">prop )</span><span class="s3">;</span><span class="s1"> 
                </span><span class="s0">// if curCSS returns percentage, fallback to offset</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">rnumnonpx.test( computed ) ? 
                    jQuery( elem ).position()[ prop ] + </span><span class="s4">&quot;px&quot; </span><span class="s1">: 
                    computed</span><span class="s3">;</span><span class="s1"> 
            } 
        } 
    )</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods</span><span class="s1"> 
jQuery.each( { Height: </span><span class="s4">&quot;height&quot;</span><span class="s3">, </span><span class="s1">Width: </span><span class="s4">&quot;width&quot; </span><span class="s1">}</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( name</span><span class="s3">, </span><span class="s1">type ) { 
    jQuery.each( { padding: </span><span class="s4">&quot;inner&quot; </span><span class="s1">+ name</span><span class="s3">, </span><span class="s1">content: type</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s1">: </span><span class="s4">&quot;outer&quot; </span><span class="s1">+ name }</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( defaultExtra</span><span class="s3">, </span><span class="s1">funcName ) { 
        </span><span class="s0">// margin is only for outerHeight, outerWidth</span><span class="s1"> 
        jQuery.fn[ funcName ] = </span><span class="s2">function</span><span class="s1">( margin</span><span class="s3">, </span><span class="s1">value ) { 
            </span><span class="s2">var </span><span class="s1">chainable = arguments.length &amp;&amp; ( defaultExtra || </span><span class="s2">typeof </span><span class="s1">margin !== </span><span class="s4">&quot;boolean&quot; </span><span class="s1">)</span><span class="s3">,</span><span class="s1"> 
                extra = defaultExtra || ( margin === </span><span class="s2">true </span><span class="s1">|| value === </span><span class="s2">true </span><span class="s1">? </span><span class="s4">&quot;margin&quot; </span><span class="s1">: </span><span class="s4">&quot;border&quot; </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s3">, </span><span class="s2">function</span><span class="s1">( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">value ) { 
                </span><span class="s2">var </span><span class="s1">doc</span><span class="s3">;</span><span class="s1"> 
 
                </span><span class="s2">if </span><span class="s1">( jQuery.isWindow( elem ) ) { 
                    </span><span class="s0">// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there</span><span class="s1"> 
                    </span><span class="s0">// isn't a whole lot we can do. See pull request at this URL for discussion:</span><span class="s1"> 
                    </span><span class="s0">// https://github.com/jquery/jquery/pull/764</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">elem.document.documentElement[ </span><span class="s4">&quot;client&quot; </span><span class="s1">+ name ]</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s0">// Get document width or height</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s5">9 </span><span class="s1">) { 
                    doc = elem.documentElement</span><span class="s3">;</span><span class="s1"> 
 
                    </span><span class="s0">// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest</span><span class="s1"> 
                    </span><span class="s0">// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">Math.max( 
                        elem.body[ </span><span class="s4">&quot;scroll&quot; </span><span class="s1">+ name ]</span><span class="s3">, </span><span class="s1">doc[ </span><span class="s4">&quot;scroll&quot; </span><span class="s1">+ name ]</span><span class="s3">,</span><span class="s1"> 
                        elem.body[ </span><span class="s4">&quot;offset&quot; </span><span class="s1">+ name ]</span><span class="s3">, </span><span class="s1">doc[ </span><span class="s4">&quot;offset&quot; </span><span class="s1">+ name ]</span><span class="s3">,</span><span class="s1"> 
                        doc[ </span><span class="s4">&quot;client&quot; </span><span class="s1">+ name ] 
                    )</span><span class="s3">;</span><span class="s1"> 
                } 
 
                </span><span class="s2">return </span><span class="s1">value === undefined ? 
                    </span><span class="s0">// Get width or height on the element, requesting but not forcing parseFloat</span><span class="s1"> 
                    jQuery.css( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">extra ) : 
 
                    </span><span class="s0">// Set width or height on the element</span><span class="s1"> 
                    jQuery.style( elem</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">extra )</span><span class="s3">;</span><span class="s1"> 
            }</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">chainable ? margin : undefined</span><span class="s3">, </span><span class="s1">chainable</span><span class="s3">, </span><span class="s2">null </span><span class="s1">)</span><span class="s3">;</span><span class="s1"> 
        }</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
})</span><span class="s3">;</span><span class="s1"> 
 
 
</span><span class="s0">// The number of elements contained in the matched element set</span><span class="s1"> 
jQuery.fn.size = </span><span class="s2">function</span><span class="s1">() { 
    </span><span class="s2">return this</span><span class="s1">.length</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
jQuery.fn.andSelf = jQuery.fn.addBack</span><span class="s3">;</span><span class="s1"> 
 
 
 
 
</span><span class="s0">// Register as a named AMD module, since jQuery can be concatenated with other</span><span class="s1"> 
</span><span class="s0">// files that may use define, but not via a proper concatenation script that</span><span class="s1"> 
</span><span class="s0">// understands anonymous AMD modules. A named AMD is safest and most robust</span><span class="s1"> 
</span><span class="s0">// way to register. Lowercase jquery is used because AMD module names are</span><span class="s1"> 
</span><span class="s0">// derived from file names, and jQuery is normally delivered in a lowercase</span><span class="s1"> 
</span><span class="s0">// file name. Do this after creating the global so that if an AMD module wants</span><span class="s1"> 
</span><span class="s0">// to call noConflict to hide this version of jQuery, it will work.</span><span class="s1"> 
 
</span><span class="s0">// Note that for maximum portability, libraries that are not jQuery should</span><span class="s1"> 
</span><span class="s0">// declare themselves as anonymous modules, and avoid setting a global if an</span><span class="s1"> 
</span><span class="s0">// AMD loader is present. jQuery is a special case. For more information, see</span><span class="s1"> 
</span><span class="s0">// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</span><span class="s1"> 
 
</span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">define === </span><span class="s4">&quot;function&quot; </span><span class="s1">&amp;&amp; define.amd ) { 
    define( </span><span class="s4">&quot;jquery&quot;</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">return </span><span class="s1">jQuery</span><span class="s3">;</span><span class="s1"> 
    })</span><span class="s3">;</span><span class="s1"> 
} 
 
 
 
 
</span><span class="s2">var</span><span class="s1"> 
    </span><span class="s0">// Map over jQuery in case of overwrite</span><span class="s1"> 
    _jQuery = window.jQuery</span><span class="s3">,</span><span class="s1"> 
 
    </span><span class="s0">// Map over the $ in case of overwrite</span><span class="s1"> 
    _$ = window.$</span><span class="s3">;</span><span class="s1"> 
 
jQuery.noConflict = </span><span class="s2">function</span><span class="s1">( deep ) { 
    </span><span class="s2">if </span><span class="s1">( window.$ === jQuery ) { 
        window.$ = _$</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">if </span><span class="s1">( deep &amp;&amp; window.jQuery === jQuery ) { 
        window.jQuery = _jQuery</span><span class="s3">;</span><span class="s1"> 
    } 
 
    </span><span class="s2">return </span><span class="s1">jQuery</span><span class="s3">;</span><span class="s1"> 
}</span><span class="s3">;</span><span class="s1"> 
 
</span><span class="s0">// Expose jQuery and $ identifiers, even in</span><span class="s1"> 
</span><span class="s0">// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span><span class="s1"> 
</span><span class="s0">// and CommonJS for browser emulators (#13566)</span><span class="s1"> 
</span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">noGlobal === strundefined ) { 
    window.jQuery = window.$ = jQuery</span><span class="s3">;</span><span class="s1"> 
} 
 
 
 
 
</span><span class="s2">return </span><span class="s1">jQuery</span><span class="s3">;</span><span class="s1"> 
 
}))</span><span class="s3">;</span><span class="s1"> 
</span></pre>
</body>
</html>